diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/Makefile.in bochs_py/Makefile.in
--- bochs/Makefile.in	2010-03-01 13:27:09.000000000 +0100
+++ bochs_py/Makefile.in	2010-03-01 13:27:53.000000000 +0100
@@ -89,7 +89,7 @@
 CXXFLAGS = @CXXFLAGS@ @GUI_CXXFLAGS@ $(MCH_CFLAGS) $(FLA_FLAGS) @DEFINE_PLUGIN_PATH@ -DBX_SHARE_PATH='"$(sharedir)"'
 
 LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
+LIBS = @LIBS@ @PYTHON_LIB@
 # To compile with readline:
 #   linux needs just -lreadline
 #   solaris needs -lreadline -lcurses
@@ -117,7 +117,7 @@
 CXXFLAGS_CONSOLE = @CXXFLAGS@ $(MCH_CFLAGS) $(FLA_FLAGS)
 BXIMAGE_LINK_OPTS = @BXIMAGE_LINK_OPTS@
 
-BX_INCDIRS = -I. -I$(srcdir)/. -I@INSTRUMENT_DIR@ -I$(srcdir)/@INSTRUMENT_DIR@
+BX_INCDIRS = -I. -I$(srcdir)/. -I@INSTRUMENT_DIR@ -I$(srcdir)/@INSTRUMENT_DIR@ -I@PYTHON_INCLUDES@
 
 #SUBDIRS = iodev bx_debug
 
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/bx_debug/Makefile.in bochs_py/bx_debug/Makefile.in
--- bochs/bx_debug/Makefile.in	2010-02-22 19:36:35.000000000 +0100
+++ bochs_py/bx_debug/Makefile.in	2010-02-22 19:35:38.000000000 +0100
@@ -48,7 +48,7 @@
 
 
 BX_OBJS = \
-  dbg_main.o \
+  @BX_DEBUGGER@.o \
   symbols.o \
   linux.o \
 
@@ -58,7 +58,7 @@
 
 BX_INCLUDES = debug.h
 
-BX_INCDIRS = -I.. -I$(srcdir)/.. -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@ -I. -I$(srcdir)/.
+BX_INCDIRS = -I.. -I$(srcdir)/.. -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@ -I. -I$(srcdir)/. -I@PYTHON_INCLUDES@
 
 all: libdebug.a
 
@@ -91,7 +91,7 @@
 	@RMCOMMAND@ -f  parser.c
 	@RMCOMMAND@ -f  parser.h
 
-dbg_main.o: debug.h
+@BX_DEBUGGER@.o: debug.h
 sim2.o: debug.h
 
 parser.c: parser.y
@@ -112,7 +112,7 @@
 ###########################################
 lexer.o: lexer.c debug.h ../config.h ../osdep.h
 parser.o: parser.c debug.h ../config.h ../osdep.h
-dbg_main.o: dbg_main.@CPP_SUFFIX@ ../bochs.h ../config.h ../osdep.h \
+@BX_DEBUGGER@.o: @BX_DEBUGGER@.@CPP_SUFFIX@ ../bochs.h ../config.h ../osdep.h \
   ../bx_debug/debug.h ../config.h ../osdep.h ../bxversion.h \
   ../gui/siminterface.h ../memory/memory.h ../pc_system.h ../plugin.h \
   ../extplugin.h ../ltdl.h ../gui/gui.h ../instrument/stubs/instrument.h \
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/bx_debug/dbg_python.cc bochs_py/bx_debug/dbg_python.cc
--- bochs/bx_debug/dbg_python.cc	1970-01-01 01:00:00.000000000 +0100
+++ bochs_py/bx_debug/dbg_python.cc	2010-03-01 11:46:33.000000000 +0100
@@ -0,0 +1,5983 @@
+//
+//  Copyright (C) 2001  MandrakeSoft S.A.
+//
+//    MandrakeSoft S.A.
+//    43, rue d'Aboukir
+//    75002 Paris - France
+//    http://www.linux-mandrake.com/
+//    http://www.mandrakesoft.com/
+//
+//  This library is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU Lesser General Public
+//  License as published by the Free Software Foundation; either
+//  version 2 of the License, or (at your option) any later version.
+//
+//  This library is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//  Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public
+//  License along with this library; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+/////////////////////////////////////////////////////////////////////////
+
+extern "C" {
+#include <signal.h>
+}
+
+#include "bochs.h"
+#include "cpu/cpu.h"
+#include "iodev/iodev.h"
+
+#if BX_DEBUGGER
+
+#include "disasm/disasm.h"
+
+#define LOG_THIS genlog->
+
+#if HAVE_LIBREADLINE
+extern "C" {
+#include <stdio.h>
+#include <readline/readline.h>
+#if HAVE_READLINE_HISTORY_H
+#include <readline/history.h>
+#endif
+}
+#endif
+
+#if BX_INSTRUMENTATION_PYTHON_HOOKS
+#include "interpreter.h"
+#endif
+
+
+// default CPU in the debugger.  For commands like "dump_cpu" it will
+// use the default instead of always dumping all cpus.
+unsigned dbg_cpu = 0;
+bx_list_c *dbg_cpu_list = 0;
+
+extern const char* cpu_mode_string(unsigned cpu_mode);
+extern void bx_sr_after_restore_state(void);
+
+void bx_dbg_print_descriptor(Bit32u lo, Bit32u hi);
+void bx_dbg_print_descriptor64(Bit32u lo1, Bit32u hi1, Bit32u lo2, Bit32u hi2);
+
+static bx_param_bool_c *sim_running = NULL;
+
+static char tmp_buf[512];
+static char tmp_buf_prev[512];
+static char *tmp_buf_ptr;
+static char *argv0 = NULL;
+
+static FILE *debugger_log = NULL;
+
+static struct {
+  // some fields used for single CPU debugger
+  bx_bool  auto_disassemble;
+  unsigned disassemble_size;
+  char     default_display_format;
+  char     default_unit_size;
+  bx_address default_addr;
+  unsigned next_bpoint_id;
+  unsigned next_wpoint_id;
+} bx_debugger;
+
+typedef struct {
+  FILE    *fp;
+  char     fname[BX_MAX_PATH];
+  unsigned lineno;
+} bx_infile_stack_entry_t;
+
+bx_infile_stack_entry_t bx_infile_stack[BX_INFILE_DEPTH];
+int                     bx_infile_stack_index = 0;
+
+static int  bx_nest_infile(char *path);
+
+void CDECL bx_debug_ctrlc_handler(int signum);
+
+static void bx_unnest_infile(void);
+static void bx_get_command(void);
+static void bx_dbg_print_guard_results();
+static void bx_dbg_breakpoint_changed(void);
+
+bx_guard_t        bx_guard;
+
+// DMA stuff
+void bx_dbg_post_dma_reports(void);
+#define BX_BATCH_DMA_BUFSIZE 512
+
+static struct {
+  unsigned this_many; // batch this many max before posting events
+  unsigned Qsize;     // this many have been batched
+  struct {
+    bx_phy_address addr; // address of DMA op
+    unsigned len;        // number of bytes in op
+    unsigned what;       // BX_READ or BX_WRITE
+    Bit32u   val;        // value of DMA op
+    Bit64u   time;       // system time at this dma op
+  } Q[BX_BATCH_DMA_BUFSIZE];
+} bx_dbg_batch_dma;
+
+// some buffers for disassembly
+static disassembler bx_disassemble;
+static Bit8u bx_disasm_ibuf[32];
+static char  bx_disasm_tbuf[512];
+
+static bx_bool watchpoint_continue = 0;
+unsigned num_write_watchpoints = 0;
+unsigned num_read_watchpoints = 0;
+bx_watchpoint write_watchpoint[BX_DBG_MAX_WATCHPONTS];
+bx_watchpoint read_watchpoint[BX_DBG_MAX_WATCHPONTS];
+
+#define DBG_PRINTF_BUFFER_LEN 1024
+
+void dbg_printf(const char *fmt, ...)
+{
+  va_list ap;
+  va_start(ap, fmt);
+  char buf[DBG_PRINTF_BUFFER_LEN+1];
+  vsnprintf(buf, DBG_PRINTF_BUFFER_LEN, fmt, ap);
+  va_end(ap);
+  if (debugger_log != NULL) {
+    fprintf(debugger_log,"%s", buf);
+    fflush(debugger_log);
+  }
+  SIM->debug_puts(buf); // send to debugger, which will free buf when done.
+}
+
+void bx_dbg_init_infile(void)
+{
+  bx_infile_stack_index = 0;
+  bx_infile_stack[0].fp = stdin;
+  bx_infile_stack[0].lineno = 0;
+}
+
+int bx_dbg_set_rcfile(const char *rcfile)
+{
+  strncpy(bx_infile_stack[0].fname, rcfile, BX_MAX_PATH);
+  bx_infile_stack[0].fname[BX_MAX_PATH-1] = 0;
+  BX_INFO(("debugger using rc file '%s'.", rcfile));
+  return bx_nest_infile((char*)rcfile);
+}
+
+
+
+#if BX_INSTRUMENTATION_PYTHON_HOOKS
+
+// ********* Start Python Interface Code *********
+
+
+//#define Py_RETURN_NONE {Py_INCREF(Py_None); return Py_None;}
+//#define Py_RETURN_FALSE {Py_INCREF(Py_False); return Py_False;}
+//#define Py_RETURN_TRUE {Py_INCREF(Py_True); return Py_True;}
+
+char *INIT_SCRIPT_ENV_NAME = "BOCHS_PYTHON_INIT";
+
+enum {
+  CPU_cpu_version, CPU_cpuid_std, CPU_cpuid_ext, CPU_cpu_mode, CPU_inhibit_mask, CPU_debug_trap,
+
+  CPU_CS_selector, CPU_CS_base, CPU_CS_limit, CPU_CS_limit_scaled, CPU_CS_ar_byte,
+  CPU_CS_granularity, CPU_CS_d_b, CPU_CS_avl,
+
+  CPU_DS_selector, CPU_DS_base, CPU_DS_limit, CPU_DS_limit_scaled, CPU_DS_ar_byte,
+  CPU_DS_granularity, CPU_DS_d_b, CPU_DS_avl,
+
+  CPU_ES_selector, CPU_ES_base, CPU_ES_limit, CPU_ES_limit_scaled, CPU_ES_ar_byte,
+  CPU_ES_granularity, CPU_ES_d_b, CPU_ES_avl,
+
+  CPU_FS_selector, CPU_FS_base, CPU_FS_limit, CPU_FS_limit_scaled, CPU_FS_ar_byte,
+  CPU_FS_granularity, CPU_FS_d_b, CPU_FS_avl,
+
+  CPU_GS_selector, CPU_GS_base, CPU_GS_limit, CPU_GS_limit_scaled, CPU_GS_ar_byte,
+  CPU_GS_granularity, CPU_GS_d_b, CPU_GS_avl,
+
+  CPU_SS_selector, CPU_SS_base, CPU_SS_limit, CPU_SS_limit_scaled, CPU_SS_ar_byte,
+  CPU_SS_granularity, CPU_SS_d_b, CPU_SS_avl,
+
+#if BX_SUPPORT_X86_64
+  CPU_CS_l, 
+  CPU_DS_l, 
+  CPU_ES_l, 
+  CPU_FS_l, 
+  CPU_GS_l, 
+  CPU_SS_l, 
+#endif
+
+  CPU_LDTR_selector, CPU_LDTR_base, CPU_LDTR_limit, CPU_LDTR_limit_scaled,
+  CPU_LDTR_ar_byte, CPU_LDTR_granularity, CPU_LDTR_avl,
+
+  CPU_TR_selector, CPU_TR_base, CPU_TR_limit, CPU_TR_limit_scaled,
+  CPU_TR_ar_byte, CPU_TR_granularity, CPU_TR_avl,
+
+  CPU_GDTR_base, CPU_GDTR_limit,
+  CPU_IDTR_base, CPU_IDTR_limit,
+
+#if BX_SUPPORT_X86_64
+  CPU_RAX, CPU_RBX, CPU_RCX, CPU_RDX, CPU_RSP, CPU_RBP, CPU_RSI, CPU_RDI,
+  CPU_R8, CPU_R9, CPU_R10, CPU_R11, CPU_R12, CPU_R13, CPU_R14, CPU_R15, CPU_RIP,
+#else
+  CPU_EAX, CPU_EBX, CPU_ECX, CPU_EDX, CPU_EBP, CPU_ESI, CPU_EDI, CPU_ESP, CPU_EIP,
+#endif
+
+#if BX_CPU_LEVEL >= 4
+  CPU_EFLAGS_ID, CPU_EFLAGS_VIP, CPU_EFLAGS_VIF, CPU_EFLAGS_AC,
+#endif
+
+#if BX_CPU_LEVEL >= 3
+  CPU_EFLAGS_VM, CPU_EFLAGS_RF,
+#endif
+
+#if BX_CPU_LEVEL >= 2
+  CPU_EFLAGS_NT, CPU_EFLAGS_IOPL,
+#endif
+
+  CPU_EFLAGS,
+  CPU_EFLAGS_OF, CPU_EFLAGS_DF, CPU_EFLAGS_IF, CPU_EFLAGS_TF,
+  CPU_EFLAGS_SF, CPU_EFLAGS_ZF, CPU_EFLAGS_AF, CPU_EFLAGS_PF,
+  CPU_EFLAGS_CF,
+
+
+  CPU_DR0, CPU_DR1, CPU_DR2, CPU_DR3, CPU_DR6, CPU_DR7,
+  CPU_CR0, CPU_CR1, CPU_CR2, CPU_CR3,
+#if BX_CPU_LEVEL >= 4
+  CPU_CR4,
+#endif
+#if BX_SUPPORT_XSAVE
+  CPU_XCR0,
+#endif
+
+
+#if BX_CPU_LEVEL >= 5
+#if BX_SUPPORT_APIC
+  MSR_apicbase,
+#endif
+#if BX_SUPPORT_X86_64
+  MSR_EFER, MSR_star, MSR_lstar, MSR_cstar, MSR_fmask, MSR_kernelgsbase, MSR_tsc_aux,
+#endif
+  MSR_tsc_last_reset,
+#if BX_SUPPORT_SEP
+  MSR_sysenter_cs_msr, MSR_sysenter_esp_msr, MSR_sysenter_eip_msr,
+#endif
+#if BX_SUPPORT_MTRR
+  MSR_mtrrphysbase0, MSR_mtrrphysmask0, MSR_mtrrphysbase1, MSR_mtrrphysmask1,
+  MSR_mtrrphysbase2, MSR_mtrrphysmask2, MSR_mtrrphysbase3, MSR_mtrrphysmask3,
+  MSR_mtrrphysbase4, MSR_mtrrphysmask4, MSR_mtrrphysbase5, MSR_mtrrphysmask5,
+  MSR_mtrrphysbase6, MSR_mtrrphysmask6, MSR_mtrrphysbase7, MSR_mtrrphysmask7,
+
+  MSR_mtrrfix64k_00000, MSR_mtrrfix16k_80000, MSR_mtrrfix16k_a0000,
+
+  MSR_mtrrfix4k_c0000, MSR_mtrrfix4k_c8000,
+  MSR_mtrrfix4k_d0000, MSR_mtrrfix4k_d8000,
+  MSR_mtrrfix4k_e0000, MSR_mtrrfix4k_e8000,
+  MSR_mtrrfix4k_f0000, MSR_mtrrfix4k_f8000,
+
+  MSR_pat, MSR_mtrr_deftype,
+#endif
+#endif
+
+#if BX_SUPPORT_FPU || BX_SUPPORT_MMX
+  CPU_FPU_cwd, CPU_FPU_swd, CPU_FPU_twd, CPU_FPU_foo,
+  CPU_FPU_fcs, CPU_FPU_fip, CPU_FPU_fds, CPU_FPU_fdp,
+
+  CPU_FPU_st0, CPU_FPU_st0_exp, CPU_FPU_st0_fraction,
+  CPU_FPU_st1, CPU_FPU_st1_exp, CPU_FPU_st1_fraction,
+  CPU_FPU_st2, CPU_FPU_st2_exp, CPU_FPU_st2_fraction,
+  CPU_FPU_st3, CPU_FPU_st3_exp, CPU_FPU_st3_fraction,
+  CPU_FPU_st4, CPU_FPU_st4_exp, CPU_FPU_st4_fraction,
+  CPU_FPU_st5, CPU_FPU_st5_exp, CPU_FPU_st5_fraction,
+  CPU_FPU_st6, CPU_FPU_st6_exp, CPU_FPU_st6_fraction,
+  CPU_FPU_st7, CPU_FPU_st7_exp, CPU_FPU_st7_fraction,
+
+  CPU_FPU_tos,
+
+#endif
+
+
+#if BX_SUPPORT_SSE
+  CPU_SSE_mxcsr,
+
+  CPU_SSE_xmm00_hi, CPU_SSE_xmm00_lo, CPU_SSE_xmm01_hi, CPU_SSE_xmm01_lo,
+  CPU_SSE_xmm02_hi, CPU_SSE_xmm02_lo, CPU_SSE_xmm03_hi, CPU_SSE_xmm03_lo,
+  CPU_SSE_xmm04_hi, CPU_SSE_xmm04_lo, CPU_SSE_xmm05_hi, CPU_SSE_xmm05_lo,
+  CPU_SSE_xmm06_hi, CPU_SSE_xmm06_lo, CPU_SSE_xmm07_hi, CPU_SSE_xmm07_lo,
+
+#if BX_SUPPORT_X86_64
+  CPU_SSE_xmm08_hi, CPU_SSE_xmm08_lo, CPU_SSE_xmm09_hi, CPU_SSE_xmm09_lo,
+  CPU_SSE_xmm10_hi, CPU_SSE_xmm10_lo, CPU_SSE_xmm11_hi, CPU_SSE_xmm11_lo,
+  CPU_SSE_xmm12_hi, CPU_SSE_xmm12_lo, CPU_SSE_xmm13_hi, CPU_SSE_xmm13_lo,
+  CPU_SSE_xmm14_hi, CPU_SSE_xmm14_lo, CPU_SSE_xmm15_hi, CPU_SSE_xmm15_lo,
+#endif
+#endif
+
+#if BX_SUPPORT_MONITOR_MWAIT
+  CPU_MONITOR, CPU_MONITOR_begin_addr, CPU_MONITOR_end_addr,
+#endif
+
+  CPU_async_event,
+  CPU_EXT, CPU_INTR, CPU_smi_pending, CPU_nmi_pending,
+  CPU_in_smm, CPU_nmi_disable, CPU_trace,
+  
+  CPU_LAST_ENUM
+};
+
+
+
+const char *cpu_strings[] = {
+  "cpu_version", "cpuid_std", "cpuid_ext", "cpu_mode", "inhibit_mask", "debug_trap",
+
+  "CS.selector", "CS.base", "CS.limit", "CS.limit_scaled", "CS.ar_byte",
+  "CS.granularity", "CS.d_b", "CS.avl",
+
+  "DS.selector", "DS.base", "DS.limit", "DS.limit_scaled", "DS.ar_byte",
+  "DS.granularity", "DS.d_b", "DS.avl",
+
+  "ES.selector", "ES.base", "ES.limit", "ES.limit_scaled", "ES.ar_byte",
+  "ES.granularity", "ES.d_b", "ES.avl",
+
+  "FS.selector", "FS.base", "FS.limit", "FS.limit_scaled", "FS.ar_byte",
+  "FS.granularity", "FS.d_b", "FS.avl",
+
+  "GS.selector", "GS.base", "GS.limit", "GS.limit_scaled", "GS.ar_byte",
+  "GS.granularity", "GS.d_b", "GS.avl",
+
+  "SS.selector", "SS.base", "SS.limit", "SS.limit_scaled", "SS.ar_byte",
+  "SS.granularity", "SS.d_b", "SS.avl",
+
+#if BX_SUPPORT_X86_64
+  "CS.l", 
+  "DS.l", 
+  "ES.l", 
+  "FS.l", 
+  "GS.l", 
+  "SS.l", 
+#endif
+
+  "LDTR.selector", "LDTR.base", "LDTR.limit", "LDTR.limit_scaled",
+  "LDTR.ar_byte", "LDTR.granularity", "LDTR.avl",
+
+  "TR.selector", "TR.base", "TR.limit", "TR.limit_scaled",
+  "TR.ar_byte", "TR.granularity", "TR.avl",
+
+  "GDTR.base", "GDTR.limit",
+  "IDTR.base", "IDTR.limit",
+
+#if BX_SUPPORT_X86_64
+  "RAX", "RBX", "RCX", "RDX", "RSP", "RBP", "RSI", "RDI",
+  "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15", "RIP",
+#else
+  "EAX", "EBX", "ECX", "EDX", "EBP", "ESI", "EDI", "ESP", "EIP",
+#endif
+
+#if BX_CPU_LEVEL >= 4
+  "EFLAGS.ID", "EFLAGS.VIP", "EFLAGS.VIF", "EFLAGS.AC",
+#endif
+
+#if BX_CPU_LEVEL >= 3
+  "EFLAGS.VM", "EFLAGS.RF",
+#endif
+
+#if BX_CPU_LEVEL >= 2
+  "EFLAGS.NT", "EFLAGS.IOPL",
+#endif
+
+  "EFLAGS",
+  "EFLAGS.OF", "EFLAGS.DF", "EFLAGS.IF", "EFLAGS.TF",
+  "EFLAGS.SF", "EFLAGS.ZF", "EFLAGS.AF", "EFLAGS.PF",
+  "EFLAGS.CF",
+
+
+  "DR0", "DR1", "DR2", "DR3", "DR6", "DR7",
+  "CR0", "CR1", "CR2", "CR3",
+#if BX_CPU_LEVEL >= 4
+  "CR4",
+#endif
+#if BX_SUPPORT_XSAVE
+  "XCR0",
+#endif
+
+
+#if BX_CPU_LEVEL >= 5
+#if BX_SUPPORT_APIC
+  "MSR.apicbase",
+#endif
+#if BX_SUPPORT_X86_64
+  "MSR.EFER", "MSR.star", "MSR.lstar", "MSR.cstar", "MSR.fmask", "MSR.kernelgsbase", "MSR.tsc_aux",
+#endif
+  "MSR.tsc_last_reset",
+#if BX_SUPPORT_SEP
+  "MSR.sysenter_cs_msr", "MSR.sysenter_esp_msr", "MSR.sysenter_eip_msr",
+#endif
+#if BX_SUPPORT_MTRR
+  "MSR.mtrrphysbase0", "MSR.mtrrphysmask0", "MSR.mtrrphysbase1", "MSR.mtrrphysmask1",
+  "MSR.mtrrphysbase2", "MSR.mtrrphysmask2", "MSR.mtrrphysbase3", "MSR.mtrrphysmask3",
+  "MSR.mtrrphysbase4", "MSR.mtrrphysmask4", "MSR.mtrrphysbase5", "MSR.mtrrphysmask5",
+  "MSR.mtrrphysbase6", "MSR.mtrrphysmask6", "MSR.mtrrphysbase7", "MSR.mtrrphysmask7",
+
+  "MSR.mtrrfix64k_00000", "MSR.mtrrfix16k_80000", "MSR.mtrrfix16k_a0000",
+
+  "MSR.mtrrfix4k_c0000", "MSR.mtrrfix4k_c8000",
+  "MSR.mtrrfix4k_d0000", "MSR.mtrrfix4k_d8000",
+  "MSR.mtrrfix4k_e0000", "MSR.mtrrfix4k_e8000",
+  "MSR.mtrrfix4k_f0000", "MSR.mtrrfix4k_f8000",
+
+  "MSR.pat", "MSR.mtrr_deftype",
+#endif
+#endif
+
+#if BX_SUPPORT_FPU || BX_SUPPORT_MMX
+  "FPU.cwd", "FPU.swd", "FPU.twd", "FPU.foo",
+  "FPU.fcs", "FPU.fip", "FPU.fds", "FPU.fdp",
+
+  "FPU.st0", "FPU.st0.exp", "FPU.st0.fraction",
+  "FPU.st1", "FPU.st1.exp", "FPU.st1.fraction",
+  "FPU.st2", "FPU.st2.exp", "FPU.st3.fraction",
+  "FPU.st3", "FPU.st3.exp", "FPU.st3.fraction",
+  "FPU.st4", "FPU.st4.exp", "FPU.st4.fraction",
+  "FPU.st5", "FPU.st5.exp", "FPU.st5.fraction",
+  "FPU.st6", "FPU.st6.exp", "FPU.st6.fraction",
+  "FPU.st7", "FPU.st7.exp", "FPU.st7.fraction",
+
+  "FPU.tos",
+
+#endif
+
+
+#if BX_SUPPORT_SSE
+  "SSE.mxcsr",
+
+  "SSE.xmm00_hi", "SSE.xmm00_lo", "SSE.xmm01_hi", "SSE.xmm01_lo",
+  "SSE.xmm02_hi", "SSE.xmm02_lo", "SSE.xmm03_hi", "SSE.xmm03_lo",
+  "SSE.xmm04_hi", "SSE.xmm04_lo", "SSE.xmm05_hi", "SSE.xmm05_lo",
+  "SSE.xmm06_hi", "SSE.xmm06_lo", "SSE.xmm07_hi", "SSE.xmm07_lo",
+
+#if BX_SUPPORT_X86_64
+  "SSE.xmm08_hi", "SSE.xmm08_lo", "SSE.xmm09_hi", "SSE.xmm09_lo",
+  "SSE.xmm10_hi", "SSE.xmm10_lo", "SSE.xmm11_hi", "SSE.xmm11_lo",
+  "SSE.xmm12_hi", "SSE.xmm12_lo", "SSE.xmm13_hi", "SSE.xmm13_lo",
+  "SSE.xmm14_hi", "SSE.xmm14_lo", "SSE.xmm15_hi", "SSE.xmm15_lo",
+#endif
+#endif
+
+#if BX_SUPPORT_MONITOR_MWAIT
+  "MONITOR", "MONITOR.begin_addr", "MONITOR.end_addr",
+#endif
+
+  "async_event",
+  "EXT", "INTR", "smi.pending", "nmi_pending",
+  "in_smm", "nmi_disable", "trace"
+};
+
+
+
+
+/*
+	CPU information that will be exposed to Python
+*/
+const char *cpu_python_strings[] = {
+  "cpu_version", "cpuid_std", "cpuid_ext", "cpu_mode", "inhibit_mask", "debug_trap",
+
+  "CS_selector", "CS_base", "CS_limit", "CS_limit_scaled", "CS_ar_byte",
+  "CS_granularity", "CS_d_b", "CS_avl",
+
+  "DS_selector", "DS_base", "DS_limit", "DS_limit_scaled", "DS_ar_byte",
+  "DS_granularity", "DS_d_b", "DS_avl",
+
+  "ES_selector", "ES_base", "ES_limit", "ES_limit_scaled", "ES_ar_byte",
+  "ES_granularity", "ES_d_b", "ES_avl",
+
+  "FS_selector", "FS_base", "FS_limit", "FS_limit_scaled", "FS_ar_byte",
+  "FS_granularity", "FS_d_b", "FS_avl",
+
+  "GS_selector", "GS_base", "GS_limit", "GS_limit_scaled", "GS_ar_byte",
+  "GS_granularity", "GS_d_b", "GS_avl",
+
+  "SS_selector", "SS_base", "SS_limit", "SS_limit_scaled", "SS_ar_byte",
+  "SS_granularity", "SS_d_b", "SS_avl",
+
+#if BX_SUPPORT_X86_64
+  "CS_l", 
+  "DS_l", 
+  "ES_l", 
+  "FS_l", 
+  "GS_l", 
+  "SS_l", 
+#endif
+
+  "LDTR_selector", "LDTR_base", "LDTR_limit", "LDTR_limit_scaled",
+  "LDTR_ar_byte", "LDTR_granularity", "LDTR_avl",
+
+  "TR_selector", "TR_base", "TR_limit", "TR_limit_scaled",
+  "TR_ar_byte", "TR_granularity", "TR_avl",
+
+  "GDTR_base", "GDTR_limit",
+  "IDTR_base", "IDTR_limit",
+
+#if BX_SUPPORT_X86_64
+  "RAX", "RBX", "RCX", "RDX", "RSP", "RBP", "RSI", "RDI",
+  "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15", "RIP",
+#else
+  "EAX", "EBX", "ECX", "EDX", "EBP", "ESI", "EDI", "ESP", "EIP",
+#endif
+
+#if BX_CPU_LEVEL >= 4
+  "EFLAGS_ID", "EFLAGS_VIP", "EFLAGS_VIF", "EFLAGS_AC",
+#endif
+
+#if BX_CPU_LEVEL >= 3
+  "EFLAGS_VM", "EFLAGS_RF",
+#endif
+
+#if BX_CPU_LEVEL >= 2
+  "EFLAGS_NT", "EFLAGS_IOPL",
+#endif
+
+  "EFLAGS",
+  "EFLAGS_OF", "EFLAGS_DF", "EFLAGS_IF", "EFLAGS_TF",
+  "EFLAGS_SF", "EFLAGS_ZF", "EFLAGS_AF", "EFLAGS_PF",
+  "EFLAGS_CF",
+
+
+  "DR0", "DR1", "DR2", "DR3", "DR6", "DR7",
+  "CR0", "CR1", "CR2", "CR3",
+#if BX_CPU_LEVEL >= 4
+  "CR4",
+#endif
+#if BX_SUPPORT_XSAVE
+  "XCR0",
+#endif
+
+
+#if BX_CPU_LEVEL >= 5
+#if BX_SUPPORT_APIC
+  "MSR_apicbase",
+#endif
+#if BX_SUPPORT_X86_64
+  "MSR_EFER", "MSR_star", "MSR_lstar", "MSR_cstar", "MSR_fmask", "MSR_kernelgsbase", "MSR_tsc_aux",
+#endif
+  "MSR_tsc_last_reset",
+#if BX_SUPPORT_SEP
+  "MSR_sysenter_cs_msr", "MSR_sysenter_esp_msr", "MSR_sysenter_eip_msr",
+#endif
+#if BX_SUPPORT_MTRR
+  "MSR_mtrrphysbase0", "MSR_mtrrphysmask0", "MSR_mtrrphysbase1", "MSR_mtrrphysmask1",
+  "MSR_mtrrphysbase2", "MSR_mtrrphysmask2", "MSR_mtrrphysbase3", "MSR_mtrrphysmask3",
+  "MSR_mtrrphysbase4", "MSR_mtrrphysmask4", "MSR_mtrrphysbase5", "MSR_mtrrphysmask5",
+  "MSR_mtrrphysbase6", "MSR_mtrrphysmask6", "MSR_mtrrphysbase7", "MSR_mtrrphysmask7",
+
+  "MSR_mtrrfix64k_00000", "MSR_mtrrfix16k_80000", "MSR_mtrrfix16k_a0000",
+
+  "MSR_mtrrfix4k_c0000", "MSR_mtrrfix4k_c8000",
+  "MSR_mtrrfix4k_d0000", "MSR_mtrrfix4k_d8000",
+  "MSR_mtrrfix4k_e0000", "MSR_mtrrfix4k_e8000",
+  "MSR_mtrrfix4k_f0000", "MSR_mtrrfix4k_f8000",
+
+  "MSR_pat", "MSR_mtrr_deftype",
+#endif
+#endif
+
+#if BX_SUPPORT_FPU || BX_SUPPORT_MMX
+  "FPU_cwd", "FPU_swd", "FPU_twd", "FPU_foo",
+  "FPU_fcs", "FPU_fip", "FPU_fds", "FPU_fdp",
+
+  "FPU_st0", "FPU_st0_exp", "FPU_st0_fraction",
+  "FPU_st1", "FPU_st1_exp", "FPU_st1_fraction",
+  "FPU_st2", "FPU_st2_exp", "FPU_st2_fraction",
+  "FPU_st3", "FPU_st3_exp", "FPU_st3_fraction",
+  "FPU_st4", "FPU_st4_exp", "FPU_st4_fraction",
+  "FPU_st5", "FPU_st5_exp", "FPU_st5_fraction",
+  "FPU_st6", "FPU_st6_exp", "FPU_st6_fraction",
+  "FPU_st7", "FPU_st7_exp", "FPU_st7_fraction",
+
+  "FPU_tos",
+
+#endif
+
+
+#if BX_SUPPORT_SSE
+  "SSE_mxcsr",
+
+  "SSE_xmm00_hi", "SSE_xmm00_lo", "SSE_xmm01_hi", "SSE_xmm01_lo",
+  "SSE_xmm02_hi", "SSE_xmm02_lo", "SSE_xmm03_hi", "SSE_xmm03_lo",
+  "SSE_xmm04_hi", "SSE_xmm04_lo", "SSE_xmm05_hi", "SSE_xmm05_lo",
+  "SSE_xmm06_hi", "SSE_xmm06_lo", "SSE_xmm07_hi", "SSE_xmm07_lo",
+
+#if BX_SUPPORT_X86_64
+  "SSE_xmm08_hi", "SSE_xmm08_lo", "SSE_xmm09_hi", "SSE_xmm09_lo",
+  "SSE_xmm10_hi", "SSE_xmm10_lo", "SSE_xmm11_hi", "SSE_xmm11_lo",
+  "SSE_xmm12_hi", "SSE_xmm12_lo", "SSE_xmm13_hi", "SSE_xmm13_lo",
+  "SSE_xmm14_hi", "SSE_xmm14_lo", "SSE_xmm15_hi", "SSE_xmm15_lo",
+#endif
+#endif
+
+#if BX_SUPPORT_MONITOR_MWAIT
+  "MONITOR", "MONITOR_begin_addr", "MONITOR_end_addr",
+#endif
+
+  "async_event",
+  "EXT", "INTR", "smi_pending", "nmi_pending",
+  "in_smm", "nmi_disable", "trace" };
+
+
+
+/*
+    Save machine state
+*/
+PyObject *save_state(PyObject *self, PyObject *args)
+{
+    const char *path;
+    	
+    if(!PyArg_ParseTuple(args, "s", &path)) {
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+
+    SIM->save_state(path);
+
+    Py_RETURN_NONE;
+}
+
+
+/*
+    Output an info string using Bochs' own logging facility 
+*/
+PyObject *bx_info(PyObject *self, PyObject *args)
+{
+    const char *output_string;
+    	
+    if(!PyArg_ParseTuple(args, "s", &output_string)) {
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+    BX_INFO((output_string));
+
+    Py_RETURN_NONE;
+}
+
+
+/*
+    Output a panic string using Bochs' own logging facility
+    CAREFUL as this one can potentially interrupt execution
+    Waiting for user input.
+*/
+PyObject *bx_panic(PyObject *self, PyObject *args)
+{
+    const char *output_string;
+    	
+    if(!PyArg_ParseTuple(args, "s", &output_string)) {
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+    BX_PANIC((output_string));
+
+    Py_RETURN_NONE;
+}
+
+
+/*
+        Verify we got an object back, bail out if we didn't.
+*/
+PyObject *assert_object(PyObject *pObj)
+{
+        PyObject *pExcept;
+
+        if(!pObj) {
+                pExcept = PyErr_Occurred();
+                if(pExcept)                     
+                        PyErr_Print();
+                return NULL;
+        }
+        return pObj;
+} 
+
+
+bx_phy_address get_physical_address(bx_address linear, bx_bool *valid)
+{
+    bx_phy_address phys_addr = 0;
+    
+	*valid = BX_CPU(dbg_cpu)->dbg_xlate_linear2phy(linear, &phys_addr);
+
+    return phys_addr;
+}
+
+
+/*
+	Convert a linear address to physical. Returns none if
+	the translation is not possible.
+*/
+PyObject *linear_to_physical(PyObject *self, PyObject *args)
+{
+    bx_phy_address phys_addr = 0;
+	bx_address address = 0;
+	bx_bool phys_addr_valid;
+
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "L", &address)) {
+#else
+    if(!PyArg_ParseTuple(args, "I", &address)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+    phys_addr = get_physical_address(address, &phys_addr_valid);
+    if(phys_addr_valid)
+#if BX_PHY_ADDRESS_LONG
+        return PyLong_FromUnsignedLongLong(phys_addr);
+#else
+        return PyLong_FromUnsignedLong(phys_addr);
+#endif
+
+    Py_RETURN_NONE;
+}
+
+
+
+/*
+	Write data to memory
+	The arguments tuple must be:
+		[linear address, data string]
+    Returns a boolean according to whether the operation is successful.
+*/
+#define PAGE_SIZE   4096
+#define MIN(x,y)    ((x<y)?x:y)
+
+PyObject *write_memory_block_linear(PyObject *self, PyObject *args)
+{
+    bx_phy_address phys_addr = 0;
+    bx_address address = 0;
+    unsigned int length, i, page_offset;
+    const char *data;
+    bx_bool phys_addr_valid;
+	
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "Ls#", &address, &data, &length)) {
+#else
+    if(!PyArg_ParseTuple(args, "Is#", &address, &data, &length)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_FALSE;
+    }
+    
+	for(i=0; i<length; i++) {
+
+        phys_addr = get_physical_address(address+i, &phys_addr_valid);
+        if(phys_addr_valid)
+            BX_MEM(0)->writePhysicalPage(
+                BX_CPU_THIS, phys_addr, 1, (Bit8u *)(data+i));
+        else
+            Py_RETURN_FALSE;
+
+    }
+    
+    Py_RETURN_TRUE;
+}
+
+
+
+/*
+	Write data to memory
+	The arguments tuple must be:
+		[physical address, data string]
+*/
+
+PyObject *write_memory_block_physical(PyObject *self, PyObject *args)
+{
+    bx_phy_address phys_addr = 0;
+    bx_address address = 0;
+    unsigned int length, i;
+    const char *data;
+    bx_bool phys_addr_valid;
+
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "Ls#", &address, &data, &length)) {
+#else
+    if(!PyArg_ParseTuple(args, "Is#", &address, &data, &length)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+    
+    BX_MEM(0)->writePhysicalPage(
+        BX_CPU_THIS, address, length, (void *)data);
+
+    Py_RETURN_NONE;
+}
+
+
+
+
+
+/*
+	Fetch data from memory
+	The arguments tuple must be:
+		[linear address, length in bytes of block to be retrieved]
+ 	The data is returned in a Python string.
+*/
+PyObject *read_memory_block_linear(PyObject *self, PyObject *args)
+{
+	u_char *ptr;
+	PyObject *data;
+    bx_phy_address phys_addr = 0;
+    bx_address address = 0;
+    unsigned int length, i;
+    bx_bool phys_addr_valid;
+
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "LI", &address, &length)) {
+#else
+    if(!PyArg_ParseTuple(args, "II", &address, &length)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+	ptr = (u_char *)malloc( (size_t)length );
+	if(!ptr) {
+	    dbg_printf("read_memory_block_linear(): failed attempting to allocate %ld(0x%lx) bytes.\n", length, length);
+		PyErr_SetString(PyExc_MemoryError, "Can't allocate memory");
+		return NULL;
+	}
+	
+	for(i=0; i<length; i++) {
+        phys_addr = get_physical_address(address+i, &phys_addr_valid);
+		if(phys_addr_valid)
+			BX_MEM(dbg_cpu)->dbg_fetch_mem(BX_CPU(dbg_cpu), phys_addr, 1, ptr+i);
+        else
+            break;
+	}
+	
+	if(!i) {
+	   free(ptr);
+	   Py_RETURN_NONE;
+    }
+    
+    ptr = (u_char *)realloc( (void *)ptr, i );
+	
+	data = PyString_FromStringAndSize((const char *)ptr, i);
+	free(ptr);
+	if(!assert_object(data)) {
+		PyErr_SetString(PyExc_ValueError, "Can't create string out of data");
+		return NULL;
+	}
+	
+	return data;
+}
+
+
+/*
+	Fetch data from memory
+	The arguments tuple must be:
+		[physical address, length in bytes of block to be retrieved]
+ 	The data is returned in a Python string.
+*/
+PyObject *read_memory_block_physical(PyObject *self, PyObject *args)
+{
+	u_char *ptr;
+	PyObject *data;
+    bx_phy_address phys_addr = 0;
+    unsigned int length, i;
+	bx_bool phys_addr_valid;
+	
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "LI", &phys_addr, &length)) {
+#else
+    if(!PyArg_ParseTuple(args, "II", &phys_addr, &length)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+	ptr = (u_char *)malloc( (size_t)length );
+	if(!ptr) {
+		PyErr_SetString(PyExc_MemoryError, "Can't allocate memory");
+		return NULL;
+	}
+	
+	for(i=0; i<length; i++)
+        if(!BX_MEM(dbg_cpu)->dbg_fetch_mem(BX_CPU(dbg_cpu), phys_addr+i, 1, ptr+i))
+            break;
+	
+	if(!i) {
+       free(ptr);
+       Py_RETURN_NONE;
+    }
+    
+    ptr = (u_char *)realloc( (void *)ptr, i );
+    
+    data = PyString_FromStringAndSize((const char *)ptr, i);
+	free(ptr);
+	if(!assert_object(data)) {
+		PyErr_SetString(PyExc_ValueError, "Can't create string out of data");
+		return NULL;
+	}
+	
+	return data;
+}
+
+
+
+/*
+	Fetch dword from memory at linear address
+*/
+PyObject *fetch_dword_linear(PyObject *self, PyObject *args)
+{
+	u_char *ptr;
+	PyObject *data;
+    bx_phy_address phys_addr = 0;
+    bx_address address = 0;
+    unsigned long int val;
+	bx_bool phys_addr_valid;
+
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "L", &address)) {
+#else
+    if(!PyArg_ParseTuple(args, "I", &address)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+    phys_addr = get_physical_address(address, &phys_addr_valid);
+    if(phys_addr_valid)
+        BX_MEM(dbg_cpu)->dbg_fetch_mem(BX_CPU(dbg_cpu), phys_addr, 4, (u_char *)&val);
+    else
+        Py_RETURN_NONE;
+
+	return PyLong_FromUnsignedLongLong(val);
+}
+
+
+
+/*
+	Fetch dword from memory at physical address
+*/
+PyObject *fetch_dword_physical(PyObject *self, PyObject *args)
+{
+	u_char *ptr;
+	PyObject *data;
+    bx_phy_address phys_addr = 0;
+	unsigned long int val;
+	
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "L", &phys_addr)) {
+#elif BX_PHY_ADDRESS_LONG
+    if(!PyArg_ParseTuple(args, "L", &phys_addr)) {
+#else
+    if(!PyArg_ParseTuple(args, "I", &phys_addr)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+    if(!BX_MEM(dbg_cpu)->dbg_fetch_mem(BX_CPU(dbg_cpu), phys_addr, 4, (u_char *)&val))
+        Py_RETURN_NONE;
+        
+	return PyLong_FromUnsignedLongLong(val);
+}
+
+
+
+/*
+	Fetch word from memory at linear address
+*/
+PyObject *fetch_word_linear(PyObject *self, PyObject *args)
+{
+	u_char *ptr;
+	PyObject *data;
+    bx_phy_address phys_addr = 0;
+    bx_address address = 0;
+    unsigned long int val=0;
+	bx_bool phys_addr_valid;
+	
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "L", &address)) {
+#else
+    if(!PyArg_ParseTuple(args, "I", &address)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+    phys_addr = get_physical_address(address, &phys_addr_valid);
+    if(phys_addr_valid)
+        BX_MEM(dbg_cpu)->dbg_fetch_mem(BX_CPU(dbg_cpu), phys_addr, 2, (u_char *)&val);
+    else
+        Py_RETURN_NONE;
+        
+	return PyLong_FromUnsignedLongLong(val);
+}
+
+
+
+
+/*
+	Fetch word from memory at physical address 
+*/
+PyObject *fetch_word_physical(PyObject *self, PyObject *args)
+{
+	u_char *ptr;
+	PyObject *data;
+    bx_phy_address phys_addr = 0;
+	unsigned long int val=0;
+	
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "L", &phys_addr)) {
+#elif BX_PHY_ADDRESS_LONG
+    if(!PyArg_ParseTuple(args, "L", &phys_addr)) {
+#else
+    if(!PyArg_ParseTuple(args, "I", &phys_addr)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+    if(!BX_MEM(dbg_cpu)->dbg_fetch_mem(BX_CPU(dbg_cpu), phys_addr, 2, (u_char *)&val))
+        Py_RETURN_NONE;
+        
+	return PyLong_FromUnsignedLongLong(val);
+}
+
+
+
+/*
+	Fetch byte from memory at linear address
+*/
+PyObject *fetch_byte_linear(PyObject *self, PyObject *args)
+{
+	u_char *ptr;
+	PyObject *data;
+    bx_phy_address phys_addr = 0;
+    bx_address address = 0;
+    unsigned long int val=0;
+	bx_bool phys_addr_valid;
+	
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "L", &address)) {
+#else
+    if(!PyArg_ParseTuple(args, "I", &address)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+    phys_addr = get_physical_address(address, &phys_addr_valid);
+    if(phys_addr_valid)
+        BX_MEM(dbg_cpu)->dbg_fetch_mem(BX_CPU(dbg_cpu), phys_addr, 1, (u_char *)&val);
+    else
+        Py_RETURN_NONE;
+        
+	return PyLong_FromUnsignedLongLong(val);
+}
+
+
+
+/*
+	Fetch byte from memory at physical address
+*/
+PyObject *fetch_byte_physical(PyObject *self, PyObject *args)
+{
+	u_char *ptr;
+	PyObject *data;
+    bx_phy_address phys_addr = 0;
+    unsigned long int val=0;
+	
+#if BX_SUPPORT_X86_64
+    if(!PyArg_ParseTuple(args, "L", &phys_addr)) {
+#elif BX_PHY_ADDRESS_LONG
+    if(!PyArg_ParseTuple(args, "L", &phys_addr)) {
+#else
+    if(!PyArg_ParseTuple(args, "I", &phys_addr)) {
+#endif
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+
+    if(!BX_MEM(dbg_cpu)->dbg_fetch_mem(BX_CPU(dbg_cpu), phys_addr, 1, (u_char *)&val))
+        Py_RETURN_NONE;
+        
+	return PyLong_FromUnsignedLongLong(val);
+}
+
+
+
+/*
+    Retrieve the value of a register from the CPU
+*/
+PyObject *cpu_get(PyObject *self, PyObject *args)
+{
+    Bit32u register_chooser;
+    Bit64u return_value;
+    //bx_dbg_cpu_t cpu;
+
+    if(!PyArg_ParseTuple(args, "I", &register_chooser)) {
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+    
+    //memset(&cpu, 0, sizeof(cpu));
+    //BX_CPU(cpu)->dbg_get_cpu(&cpu);
+
+    switch(register_chooser) {
+        case CPU_cpu_version:
+        case CPU_cpuid_std:
+        case CPU_cpuid_ext:
+        case CPU_cpu_mode:
+        case CPU_inhibit_mask:
+        case CPU_debug_trap:
+        case CPU_DR0:
+        case CPU_DR1:
+        case CPU_DR2:
+        case CPU_DR3:
+        case CPU_DR6:
+        case CPU_DR7:
+        case CPU_CR0:
+        case CPU_CR1:
+        case CPU_CS_selector:
+        case CPU_CS_base:
+        case CPU_CS_limit:
+        case CPU_CS_limit_scaled:
+        case CPU_CS_ar_byte:
+        case CPU_CS_granularity:
+        case CPU_CS_d_b:
+        case CPU_CS_avl:
+        case CPU_DS_selector:
+        case CPU_DS_base:
+        case CPU_DS_limit:
+        case CPU_DS_limit_scaled:
+        case CPU_DS_ar_byte:
+        case CPU_DS_granularity:
+        case CPU_DS_d_b:
+        case CPU_DS_avl:
+        case CPU_ES_selector:
+        case CPU_ES_base:
+        case CPU_ES_limit:
+        case CPU_ES_limit_scaled:
+        case CPU_ES_ar_byte:
+        case CPU_ES_granularity:
+        case CPU_ES_d_b:
+        case CPU_ES_avl:
+        case CPU_FS_selector:
+        case CPU_FS_base:
+        case CPU_FS_limit:
+        case CPU_FS_limit_scaled:
+        case CPU_FS_ar_byte:
+        case CPU_FS_granularity:
+        case CPU_FS_d_b:
+        case CPU_FS_avl:
+        case CPU_GS_selector:
+        case CPU_GS_base:
+        case CPU_GS_limit:
+        case CPU_GS_limit_scaled:
+        case CPU_GS_ar_byte:
+        case CPU_GS_granularity:
+        case CPU_GS_d_b:
+        case CPU_GS_avl:
+        case CPU_SS_selector:
+        case CPU_SS_base:
+        case CPU_SS_limit:
+        case CPU_SS_limit_scaled:
+        case CPU_SS_ar_byte:
+        case CPU_SS_granularity:
+        case CPU_SS_d_b:
+        case CPU_SS_avl:
+        case CPU_LDTR_selector:
+        case CPU_LDTR_limit:
+        case CPU_LDTR_limit_scaled:
+        case CPU_LDTR_ar_byte:
+        case CPU_LDTR_granularity:
+        case CPU_LDTR_avl:
+        case CPU_TR_selector:
+        case CPU_TR_base:
+        case CPU_TR_limit:
+        case CPU_TR_limit_scaled:
+        case CPU_TR_ar_byte:
+        case CPU_TR_granularity:
+        case CPU_TR_avl:
+        case CPU_GDTR_base:
+        case CPU_GDTR_limit:
+        case CPU_IDTR_base:
+        case CPU_IDTR_limit:
+
+        case CPU_EFLAGS:
+
+#if BX_CPU_LEVEL >= 4
+        case CPU_CR4:
+#endif
+#if BX_SUPPORT_XSAVE
+        case CPU_XCR0:
+#endif
+            
+
+#if BX_CPU_LEVEL >= 5
+#if BX_SUPPORT_APIC
+        case MSR_apicbase:
+#endif
+#if BX_SUPPORT_X86_64
+        case MSR_EFER:
+        case MSR_star:
+        case MSR_lstar:
+        case MSR_cstar:
+        case MSR_fmask:
+        case MSR_kernelgsbase:
+        case MSR_tsc_aux:
+#endif
+        case MSR_tsc_last_reset:
+#if BX_SUPPORT_SEP
+        case MSR_sysenter_cs_msr:
+        case MSR_sysenter_esp_msr:
+        case MSR_sysenter_eip_msr:
+#endif
+#if BX_SUPPORT_MTRR
+        case MSR_mtrrphysbase0:
+        case MSR_mtrrphysmask0:
+        case MSR_mtrrphysbase1:
+        case MSR_mtrrphysmask1:
+        case MSR_mtrrphysbase2:
+        case MSR_mtrrphysmask2:
+        case MSR_mtrrphysbase3:
+        case MSR_mtrrphysmask3:
+        case MSR_mtrrphysbase4:
+        case MSR_mtrrphysmask4:
+        case MSR_mtrrphysbase5:
+        case MSR_mtrrphysmask5:
+        case MSR_mtrrphysbase6:
+        case MSR_mtrrphysmask6:
+        case MSR_mtrrphysbase7:
+        case MSR_mtrrphysmask7:
+        case MSR_mtrrfix64k_00000:
+        case MSR_mtrrfix16k_80000:
+        case MSR_mtrrfix16k_a0000:
+        case MSR_mtrrfix4k_c0000:
+        case MSR_mtrrfix4k_c8000:
+        case MSR_mtrrfix4k_d0000:
+        case MSR_mtrrfix4k_d8000:
+        case MSR_mtrrfix4k_e0000:
+        case MSR_mtrrfix4k_e8000:
+        case MSR_mtrrfix4k_f0000:
+        case MSR_mtrrfix4k_f8000:
+        case MSR_pat:
+        case MSR_mtrr_deftype:
+#endif
+#endif
+
+#if BX_SUPPORT_FPU || BX_SUPPORT_MMX
+        case CPU_FPU_cwd:
+        case CPU_FPU_swd:
+        case CPU_FPU_twd:
+        case CPU_FPU_foo:
+        case CPU_FPU_fcs:
+        case CPU_FPU_fip:
+        case CPU_FPU_fds:
+        case CPU_FPU_fdp:
+        case CPU_FPU_st0:
+        case CPU_FPU_st0_exp:
+        case CPU_FPU_st0_fraction:
+        case CPU_FPU_st1:
+        case CPU_FPU_st1_exp:
+        case CPU_FPU_st1_fraction:
+        case CPU_FPU_st2:
+        case CPU_FPU_st2_exp:
+        case CPU_FPU_st2_fraction:
+        case CPU_FPU_st3:
+        case CPU_FPU_st3_exp:
+        case CPU_FPU_st3_fraction:
+        case CPU_FPU_st4:
+        case CPU_FPU_st4_exp:
+        case CPU_FPU_st4_fraction:
+        case CPU_FPU_st5:
+        case CPU_FPU_st5_exp:
+        case CPU_FPU_st5_fraction:
+        case CPU_FPU_st6:
+        case CPU_FPU_st6_exp:
+        case CPU_FPU_st6_fraction:
+        case CPU_FPU_st7:
+        case CPU_FPU_st7_exp:
+        case CPU_FPU_st7_fraction:
+        case CPU_FPU_tos:
+#endif
+
+#if BX_SUPPORT_SSE
+        case CPU_SSE_mxcsr:
+#endif
+
+#if BX_SUPPORT_MONITOR_MWAIT
+        case CPU_MONITOR:
+        case CPU_MONITOR_begin_addr:
+        case CPU_MONITOR_end_addr:
+#endif
+        case CPU_async_event:
+        case CPU_EXT:
+        case CPU_INTR:
+        case CPU_smi_pending:
+        case CPU_nmi_pending:
+        case CPU_in_smm:
+        case CPU_nmi_disable:
+        case CPU_trace:
+        
+          return_value = (Bit32u) SIM->get_param_num(cpu_strings[ register_chooser ], dbg_cpu_list)->get();
+          break;
+        
+#if BX_SUPPORT_SSE
+        case CPU_SSE_xmm00_hi:
+        case CPU_SSE_xmm00_lo:
+        case CPU_SSE_xmm01_hi:
+        case CPU_SSE_xmm01_lo:
+        case CPU_SSE_xmm02_hi:
+        case CPU_SSE_xmm02_lo:
+        case CPU_SSE_xmm03_hi:
+        case CPU_SSE_xmm03_lo:
+        case CPU_SSE_xmm04_hi:
+        case CPU_SSE_xmm04_lo:
+        case CPU_SSE_xmm05_hi:
+        case CPU_SSE_xmm05_lo:
+        case CPU_SSE_xmm06_hi:
+        case CPU_SSE_xmm06_lo:
+        case CPU_SSE_xmm07_hi:
+        case CPU_SSE_xmm07_lo:
+#if BX_SUPPORT_X86_64
+        case CPU_SSE_xmm08_hi:
+        case CPU_SSE_xmm08_lo:
+        case CPU_SSE_xmm09_hi:
+        case CPU_SSE_xmm09_lo:
+        case CPU_SSE_xmm10_hi:
+        case CPU_SSE_xmm10_lo:
+        case CPU_SSE_xmm11_hi:
+        case CPU_SSE_xmm11_lo:
+        case CPU_SSE_xmm12_hi:
+        case CPU_SSE_xmm12_lo:
+        case CPU_SSE_xmm13_hi:
+        case CPU_SSE_xmm13_lo:
+        case CPU_SSE_xmm14_hi:
+        case CPU_SSE_xmm14_lo:
+        case CPU_SSE_xmm15_hi:
+        case CPU_SSE_xmm15_lo:
+#endif
+#endif
+
+        case CPU_CR2:
+        case CPU_CR3:
+
+        case CPU_LDTR_base:
+
+#if BX_SUPPORT_X86_64
+        case CPU_RAX:
+        case CPU_RBX:
+        case CPU_RCX:
+        case CPU_RDX:
+        case CPU_RSP:
+        case CPU_RBP:
+        case CPU_RSI:
+        case CPU_RDI:
+        case CPU_R8:
+        case CPU_R9:
+        case CPU_R10:
+        case CPU_R11:
+        case CPU_R12:
+        case CPU_R13:
+        case CPU_R14:
+        case CPU_R15:
+        case CPU_RIP:
+          
+          return_value = (Bit64u) SIM->get_param_num(cpu_strings[ register_chooser ], dbg_cpu_list)->get64();
+          break;
+#else
+        case CPU_EAX:
+        case CPU_EBX:
+        case CPU_ECX:
+        case CPU_EDX:
+        case CPU_EBP:
+        case CPU_ESI:
+        case CPU_EDI:
+        case CPU_ESP:
+        case CPU_EIP:
+
+          return_value = (Bit32u) SIM->get_param_num(cpu_strings[ register_chooser ], dbg_cpu_list)->get();
+          break;
+#endif
+        
+#if BX_CPU_LEVEL >= 4
+        case CPU_EFLAGS_ID:
+            return_value = BX_CPU(cpu)->get_ID() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_VIP:
+            return_value = BX_CPU(cpu)->get_VIP() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_VIF:
+            return_value = BX_CPU(cpu)->get_VIF() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_AC:
+            return_value = BX_CPU(cpu)->get_AC() ? 1 : 0;
+            break;
+#endif
+
+#if BX_CPU_LEVEL >= 3
+        case CPU_EFLAGS_VM:
+            return_value = BX_CPU(cpu)->get_VM() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_RF:
+            return_value = BX_CPU(cpu)->get_RF() ? 1 : 0;
+            break;
+#endif
+
+#if BX_CPU_LEVEL >= 2
+        case CPU_EFLAGS_NT:
+            return_value = BX_CPU(cpu)->get_NT() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_IOPL:
+            return_value = BX_CPU(cpu)->get_IOPL() ? 1 : 0;
+            break;
+#endif
+        case CPU_EFLAGS_OF:
+            return_value = BX_CPU(cpu)->get_OF() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_DF:
+            return_value = BX_CPU(cpu)->get_DF() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_IF:
+            return_value = BX_CPU(cpu)->get_IF() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_TF:
+            return_value = BX_CPU(cpu)->get_TF() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_SF:
+            return_value = BX_CPU(cpu)->get_SF() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_ZF:
+            return_value = BX_CPU(cpu)->get_ZF() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_AF:
+            return_value = BX_CPU(cpu)->get_AF() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_PF:
+            return_value = BX_CPU(cpu)->get_PF() ? 1 : 0;
+            break;
+        case CPU_EFLAGS_CF:
+            return_value = BX_CPU(cpu)->get_CF() ? 1 : 0;
+            break;
+
+        default:
+            Py_RETURN_NONE;        
+    }
+
+    return PyLong_FromUnsignedLongLong(return_value);
+}
+
+
+/*
+    Set the value of a register in the CPU
+*/
+PyObject *cpu_set(PyObject *self, PyObject *args)
+{
+    Bit32u register_chooser;
+    Bit64u value;
+    //bx_dbg_cpu_t cpu;
+
+    if(!PyArg_ParseTuple(args, "IL", &register_chooser, &value)) {
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+    
+    //memset(&cpu, 0, sizeof(cpu));
+    //BX_CPU(cpu)->dbg_get_cpu(&cpu);
+
+    switch(register_chooser) {
+                case CPU_cpu_version:
+                case CPU_cpuid_std:
+                case CPU_cpuid_ext:
+                case CPU_cpu_mode:
+                case CPU_inhibit_mask:
+                case CPU_debug_trap:
+                case CPU_DR0:
+                case CPU_DR1:
+                case CPU_DR2:
+                case CPU_DR3:
+                case CPU_DR6:
+                case CPU_DR7:
+                case CPU_CR0:
+                case CPU_CR1:
+                case CPU_CS_selector:
+                case CPU_CS_base:
+                case CPU_CS_limit:
+                case CPU_CS_limit_scaled:
+                case CPU_CS_ar_byte:
+                case CPU_CS_granularity:
+                case CPU_CS_d_b:
+                case CPU_CS_avl:
+                case CPU_DS_selector:
+                case CPU_DS_base:
+                case CPU_DS_limit:
+                case CPU_DS_limit_scaled:
+                case CPU_DS_ar_byte:
+                case CPU_DS_granularity:
+                case CPU_DS_d_b:
+                case CPU_DS_avl:
+                case CPU_ES_selector:
+                case CPU_ES_base:
+                case CPU_ES_limit:
+                case CPU_ES_limit_scaled:
+                case CPU_ES_ar_byte:
+                case CPU_ES_granularity:
+                case CPU_ES_d_b:
+                case CPU_ES_avl:
+                case CPU_FS_selector:
+                case CPU_FS_base:
+                case CPU_FS_limit:
+                case CPU_FS_limit_scaled:
+                case CPU_FS_ar_byte:
+                case CPU_FS_granularity:
+                case CPU_FS_d_b:
+                case CPU_FS_avl:
+                case CPU_GS_selector:
+                case CPU_GS_base:
+                case CPU_GS_limit:
+                case CPU_GS_limit_scaled:
+                case CPU_GS_ar_byte:
+                case CPU_GS_granularity:
+                case CPU_GS_d_b:
+                case CPU_GS_avl:
+                case CPU_SS_selector:
+                case CPU_SS_base:
+                case CPU_SS_limit:
+                case CPU_SS_limit_scaled:
+                case CPU_SS_ar_byte:
+                case CPU_SS_granularity:
+                case CPU_SS_d_b:
+                case CPU_SS_avl:
+                case CPU_LDTR_selector:
+                case CPU_LDTR_limit:
+                case CPU_LDTR_limit_scaled:
+                case CPU_LDTR_ar_byte:
+                case CPU_LDTR_granularity:
+                case CPU_LDTR_avl:
+                case CPU_TR_selector:
+                case CPU_TR_base:
+                case CPU_TR_limit:
+                case CPU_TR_limit_scaled:
+                case CPU_TR_ar_byte:
+                case CPU_TR_granularity:
+                case CPU_TR_avl:
+                case CPU_GDTR_base:
+                case CPU_GDTR_limit:
+                case CPU_IDTR_base:
+                case CPU_IDTR_limit:
+
+                case CPU_EFLAGS:
+
+        #if BX_CPU_LEVEL >= 4
+                case CPU_CR4:
+        #endif
+        #if BX_SUPPORT_XSAVE
+                case CPU_XCR0:
+        #endif
+
+
+        #if BX_CPU_LEVEL >= 5
+        #if BX_SUPPORT_APIC
+                case MSR_apicbase:
+        #endif
+        #if BX_SUPPORT_X86_64
+                case MSR_EFER:
+                case MSR_star:
+                case MSR_lstar:
+                case MSR_cstar:
+                case MSR_fmask:
+                case MSR_kernelgsbase:
+                case MSR_tsc_aux:
+        #endif
+                case MSR_tsc_last_reset:
+        #if BX_SUPPORT_SEP
+                case MSR_sysenter_cs_msr:
+                case MSR_sysenter_esp_msr:
+                case MSR_sysenter_eip_msr:
+        #endif
+        #if BX_SUPPORT_MTRR
+                case MSR_mtrrphysbase0:
+                case MSR_mtrrphysmask0:
+                case MSR_mtrrphysbase1:
+                case MSR_mtrrphysmask1:
+                case MSR_mtrrphysbase2:
+                case MSR_mtrrphysmask2:
+                case MSR_mtrrphysbase3:
+                case MSR_mtrrphysmask3:
+                case MSR_mtrrphysbase4:
+                case MSR_mtrrphysmask4:
+                case MSR_mtrrphysbase5:
+                case MSR_mtrrphysmask5:
+                case MSR_mtrrphysbase6:
+                case MSR_mtrrphysmask6:
+                case MSR_mtrrphysbase7:
+                case MSR_mtrrphysmask7:
+                case MSR_mtrrfix64k_00000:
+                case MSR_mtrrfix16k_80000:
+                case MSR_mtrrfix16k_a0000:
+                case MSR_mtrrfix4k_c0000:
+                case MSR_mtrrfix4k_c8000:
+                case MSR_mtrrfix4k_d0000:
+                case MSR_mtrrfix4k_d8000:
+                case MSR_mtrrfix4k_e0000:
+                case MSR_mtrrfix4k_e8000:
+                case MSR_mtrrfix4k_f0000:
+                case MSR_mtrrfix4k_f8000:
+                case MSR_pat:
+                case MSR_mtrr_deftype:
+        #endif
+        #endif
+
+        #if BX_SUPPORT_FPU || BX_SUPPORT_MMX
+                case CPU_FPU_cwd:
+                case CPU_FPU_swd:
+                case CPU_FPU_twd:
+                case CPU_FPU_foo:
+                case CPU_FPU_fcs:
+                case CPU_FPU_fip:
+                case CPU_FPU_fds:
+                case CPU_FPU_fdp:
+                case CPU_FPU_st0:
+                case CPU_FPU_st0_exp:
+                case CPU_FPU_st0_fraction:
+                case CPU_FPU_st1:
+                case CPU_FPU_st1_exp:
+                case CPU_FPU_st1_fraction:
+                case CPU_FPU_st2:
+                case CPU_FPU_st2_exp:
+                case CPU_FPU_st2_fraction:
+                case CPU_FPU_st3:
+                case CPU_FPU_st3_exp:
+                case CPU_FPU_st3_fraction:
+                case CPU_FPU_st4:
+                case CPU_FPU_st4_exp:
+                case CPU_FPU_st4_fraction:
+                case CPU_FPU_st5:
+                case CPU_FPU_st5_exp:
+                case CPU_FPU_st5_fraction:
+                case CPU_FPU_st6:
+                case CPU_FPU_st6_exp:
+                case CPU_FPU_st6_fraction:
+                case CPU_FPU_st7:
+                case CPU_FPU_st7_exp:
+                case CPU_FPU_st7_fraction:
+                case CPU_FPU_tos:
+        #endif
+
+        #if BX_SUPPORT_SSE
+                case CPU_SSE_mxcsr:
+        #endif
+
+        #if BX_SUPPORT_MONITOR_MWAIT
+                case CPU_MONITOR:
+                case CPU_MONITOR_begin_addr:
+                case CPU_MONITOR_end_addr:
+        #endif
+                case CPU_async_event:
+                case CPU_EXT:
+                case CPU_INTR:
+                case CPU_smi_pending:
+                case CPU_nmi_pending:
+                case CPU_in_smm:
+                case CPU_nmi_disable:
+                case CPU_trace:
+                
+                  dbg_printf( "Setting: %s\n", cpu_strings[ register_chooser ] );
+                  SIM->get_param_num(cpu_strings[ register_chooser ], dbg_cpu_list)->set( value );
+                  break;
+
+        #if BX_SUPPORT_SSE
+                case CPU_SSE_xmm00_hi:
+                case CPU_SSE_xmm00_lo:
+                case CPU_SSE_xmm01_hi:
+                case CPU_SSE_xmm01_lo:
+                case CPU_SSE_xmm02_hi:
+                case CPU_SSE_xmm02_lo:
+                case CPU_SSE_xmm03_hi:
+                case CPU_SSE_xmm03_lo:
+                case CPU_SSE_xmm04_hi:
+                case CPU_SSE_xmm04_lo:
+                case CPU_SSE_xmm05_hi:
+                case CPU_SSE_xmm05_lo:
+                case CPU_SSE_xmm06_hi:
+                case CPU_SSE_xmm06_lo:
+                case CPU_SSE_xmm07_hi:
+                case CPU_SSE_xmm07_lo:
+        #if BX_SUPPORT_X86_64
+                case CPU_SSE_xmm08_hi:
+                case CPU_SSE_xmm08_lo:
+                case CPU_SSE_xmm09_hi:
+                case CPU_SSE_xmm09_lo:
+                case CPU_SSE_xmm10_hi:
+                case CPU_SSE_xmm10_lo:
+                case CPU_SSE_xmm11_hi:
+                case CPU_SSE_xmm11_lo:
+                case CPU_SSE_xmm12_hi:
+                case CPU_SSE_xmm12_lo:
+                case CPU_SSE_xmm13_hi:
+                case CPU_SSE_xmm13_lo:
+                case CPU_SSE_xmm14_hi:
+                case CPU_SSE_xmm14_lo:
+                case CPU_SSE_xmm15_hi:
+                case CPU_SSE_xmm15_lo:
+        #endif
+        #endif
+
+                case CPU_CR2:
+                case CPU_CR3:
+
+                case CPU_LDTR_base:
+
+        #if BX_SUPPORT_X86_64
+                case CPU_RAX:
+                case CPU_RBX:
+                case CPU_RCX:
+                case CPU_RDX:
+                case CPU_RSP:
+                case CPU_RBP:
+                case CPU_RSI:
+                case CPU_RDI:
+                case CPU_R8:
+                case CPU_R9:
+                case CPU_R10:
+                case CPU_R11:
+                case CPU_R12:
+                case CPU_R13:
+                case CPU_R14:
+                case CPU_R15:
+                case CPU_RIP:
+
+                  SIM->get_param_num(cpu_strings[ register_chooser ], dbg_cpu_list)->set( value );
+                  break;
+        #else
+                case CPU_EAX:
+                case CPU_EBX:
+                case CPU_ECX:
+                case CPU_EDX:
+                case CPU_EBP:
+                case CPU_ESI:
+                case CPU_EDI:
+                case CPU_ESP:
+                case CPU_EIP:
+
+                  SIM->get_param_num(cpu_strings[ register_chooser ], dbg_cpu_list)->set( value );
+                  break;
+        #endif
+
+        #if BX_CPU_LEVEL >= 4
+                case CPU_EFLAGS_ID:
+                    BX_CPU(cpu)->set_ID( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_VIP:
+                    BX_CPU(cpu)->set_VIP( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_VIF:
+                    BX_CPU(cpu)->set_VIF( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_AC:
+                    BX_CPU(cpu)->set_AC( value ? 1 : 0 );
+                    break;
+        #endif
+
+        #if BX_CPU_LEVEL >= 3
+                case CPU_EFLAGS_VM:
+                    BX_CPU(cpu)->set_VM( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_RF:
+                    BX_CPU(cpu)->set_RF( value ? 1 : 0 );
+                    break;
+        #endif
+
+        #if BX_CPU_LEVEL >= 2
+                case CPU_EFLAGS_NT:
+                    BX_CPU(cpu)->set_NT( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_IOPL:
+                    BX_CPU(cpu)->set_IOPL( value ? 1 : 0 );
+                    break;
+        #endif
+                case CPU_EFLAGS_OF:
+                    BX_CPU(cpu)->set_OF( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_DF:
+                    BX_CPU(cpu)->set_DF( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_IF:
+                    BX_CPU(cpu)->set_IF( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_TF:
+                    BX_CPU(cpu)->set_TF( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_SF:
+                    BX_CPU(cpu)->set_SF( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_ZF:
+                    BX_CPU(cpu)->set_ZF( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_AF:
+                    BX_CPU(cpu)->set_AF( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_PF:
+                    BX_CPU(cpu)->set_PF( value ? 1 : 0 );
+                    break;
+                case CPU_EFLAGS_CF:
+                    BX_CPU(cpu)->set_CF( value ? 1 : 0 );
+                    break;
+
+                default:
+                    Py_RETURN_NONE;        
+            }
+
+    Py_RETURN_NONE;
+}
+
+
+// Perform actions needed before reenterting the Python interpreter
+// such as refilling certain data structures.
+/*
+void prepare_to_reenter_interpreter(void)
+{
+
+}
+*/
+
+static PyMethodDef dbg_methods[] = {
+    {"save_state",  save_state, METH_VARARGS,
+     "Save machine state."},
+    {"bx_info",  bx_info, METH_VARARGS,
+     "Output an info string using Bochs' own logging facility."},
+    {"bx_panic",  bx_panic, METH_VARARGS,
+     "Output a panic string using Bochs' own logging facility. CAREFUL as this one can potentially interrupt execution Waiting for user input."},
+    {"linear_to_physical",  linear_to_physical, METH_VARARGS,
+     "Translate linear address to physical."},
+    {"read_memory_block_linear", read_memory_block_linear, METH_VARARGS,
+     "(linear_address, length) Fetch 'length' bytes memory starting at linear address 'address'."},
+    {"read_memory_block_physical", read_memory_block_physical, METH_VARARGS,
+     "(physical_address, length) Fetch 'length' bytes memory starting at physical address 'address'."},
+    {"write_memory_block_linear", write_memory_block_linear, METH_VARARGS,
+     "(linear_address, data) Write the 'data' bytes to memory starting at linear address 'linear_address'."},
+    {"write_memory_block_physical",  write_memory_block_physical, METH_VARARGS,
+     "(physical_address, length) Write 'length' bytes memory starting at physical address 'address'."},
+    {"dword_physical",  fetch_dword_physical, METH_VARARGS,
+     "Fetch dword from memory at the specified physical address."},
+    {"dword_linear",  fetch_dword_linear, METH_VARARGS,
+     "Fetch dword from memory at the specified linear address."},
+    {"word_physical",  fetch_word_physical, METH_VARARGS,
+     "Fetch word from memory at the specified physical address."},
+    {"word_linear",  fetch_word_linear, METH_VARARGS,
+     "Fetch word from memory at the specified linear address."},
+    {"byte_physical",  fetch_byte_physical, METH_VARARGS,
+     "Fetch byte from memory at the specified physical address."},
+    {"byte_linear",  fetch_byte_linear, METH_VARARGS,
+     "Fetch byte from memory at the specified linear address."},
+     // Filtering of "processes"
+    {"set_filter_cr3",  set_filter_cr3, METH_VARARGS,
+     "Filter to only run python callbacks when the CR3 register matches the filter."},
+     // Callbacks in the instrumentation interface
+    {"set_callback",  set_callback, METH_VARARGS,
+     "Set a callback for the given instrumentation function."},
+    {NULL, NULL, 0, NULL}
+};
+
+
+static PyMethodDef cpu_methods[] = {
+    {"get",  cpu_get, METH_VARARGS,
+     "Retrieve the contents of a CPU register."},
+    {"set",  cpu_set, METH_VARARGS,
+     "Set the contents of a CPU register."},
+    {NULL, NULL, 0, NULL}
+};
+
+
+// ********* End Python Interface Code *********
+
+
+
+#define SIMPLE_WRAPPER(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{ \
+    if(!PyArg_ParseTuple(args, "")) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_INT(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   int n;    \
+    if(!PyArg_ParseTuple(args, "i", &n)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(n); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_UINT(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   unsigned int n;    \
+    if(!PyArg_ParseTuple(args, "I", &n)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(n); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_UINT_UINT(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   unsigned int n, n2;    \
+    if(!PyArg_ParseTuple(args, "II", &n, &n2)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(n, n2); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_UINT_UINT_UINT(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   unsigned int n, n2, n3;    \
+    if(!PyArg_ParseTuple(args, "III", &n, &n2, &n3)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(n, n2, n3); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_BREAKPOINTKIND_UINT(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   unsigned int n;    \
+    BreakpointKind bk;  \
+    if(!PyArg_ParseTuple(args, "II", &bk, &n)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    return PyInt_FromLong( x(bk, n) ); }
+//    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_BREAKPOINTKIND_UINT_UINT(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   unsigned int n, n2;    \
+    BreakpointKind bk;  \
+    if(!PyArg_ParseTuple(args, "III", &bk, &n, &n2)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(bk, n, n2); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_SLONG64(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   signed long long n;    \
+    if(!PyArg_ParseTuple(args, "L", &n)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(n); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_ULONG64(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   unsigned long long n;    \
+    if(!PyArg_ParseTuple(args, "K", &n)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(n); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_STRING(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   char *s;    \
+    if(!PyArg_ParseTuple(args, "s", &s)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(s); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_STRING_STRING(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   char *s, *s2;    \
+    if(!PyArg_ParseTuple(args, "ss", &s, &s2)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(s, s2); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_STRING_UINT(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   char *s;    \
+    unsigned int n;   \
+    if(!PyArg_ParseTuple(args, "sI", &s, &n)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(s, n); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_STRING_UINT_UINT(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   char *s;    \
+    unsigned int n, n2;   \
+    if(!PyArg_ParseTuple(args, "sII", &s, &n, &n2)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(s, n, n2); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_STRING_STRING_UINT_UINT_UINT(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   char *s, *s2;    \
+    unsigned int n, n2, n3;   \
+    if(!PyArg_ParseTuple(args, "ssIII", &s, &s2, &n, &n2, &n3)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(s, s2, n, n2, n3); \
+    Py_RETURN_NONE; }
+
+#define SIMPLE_WRAPPER_STRING_STRING_UINT_UINT_UINT_UINT(x)   \
+PyObject * (py_##x) (PyObject *self, PyObject *args) \
+{   char *s, *s2;    \
+    unsigned int n, n2, n3, n4;   \
+    if(!PyArg_ParseTuple(args, "ssIIII", &s, &s2, &n, &n2, &n3, &n4)) { \
+        bochs_handle_error(); Py_RETURN_NONE;} \
+    x(s, s2, n, n2, n3, n4); \
+    Py_RETURN_NONE; }
+
+
+SIMPLE_WRAPPER(bx_dbg_continue_command)
+SIMPLE_WRAPPER(bx_dbg_quit_command)
+SIMPLE_WRAPPER(bx_dbg_info_control_regs_command)
+//SIMPLE_WRAPPER(bx_dbg_dump_cpu_command)
+SIMPLE_WRAPPER(bx_dbg_where_command)
+SIMPLE_WRAPPER(bx_dbg_step_over_command)
+//SIMPLE_WRAPPER(bx_dbg_trace_on_command)
+//SIMPLE_WRAPPER(bx_dbg_trace_off_command)
+//SIMPLE_WRAPPER(bx_dbg_trace_reg_on_command)
+//SIMPLE_WRAPPER(bx_dbg_trace_reg_off_command)
+
+SIMPLE_WRAPPER_UINT(bx_dbg_trace_command)
+SIMPLE_WRAPPER_UINT(bx_dbg_trace_reg_command)
+SIMPLE_WRAPPER_UINT(bx_dbg_trace_mem_command)
+
+SIMPLE_WRAPPER(bx_dbg_ptime_command)
+SIMPLE_WRAPPER(bx_dbg_info_bpoints_command)
+SIMPLE_WRAPPER_INT(bx_dbg_print_stack_command)
+SIMPLE_WRAPPER_INT(bx_dbg_info_registers_command)
+SIMPLE_WRAPPER_UINT_UINT(bx_dbg_stepN_command)
+SIMPLE_WRAPPER_UINT(bx_dbg_del_breakpoint_command)
+SIMPLE_WRAPPER_UINT(bx_dbg_print_string_command)
+SIMPLE_WRAPPER_UINT_UINT(bx_dbg_timebp_command)
+SIMPLE_WRAPPER_UINT_UINT(bx_dbg_en_dis_breakpoint_command)
+SIMPLE_WRAPPER_BREAKPOINTKIND_UINT(bx_dbg_lbreakpoint_command)
+SIMPLE_WRAPPER_BREAKPOINTKIND_UINT(bx_dbg_pbreakpoint_command)
+SIMPLE_WRAPPER_UINT_UINT(bx_dbg_crc_command)
+SIMPLE_WRAPPER_ULONG64(bx_dbg_calc_command)
+SIMPLE_WRAPPER_STRING(bx_dbg_show_command)
+SIMPLE_WRAPPER_STRING(bx_dbg_record_command)
+SIMPLE_WRAPPER_STRING(bx_dbg_playback_command)
+SIMPLE_WRAPPER(bx_dbg_modebp_command)
+SIMPLE_WRAPPER_STRING(bx_dbg_query_command)
+SIMPLE_WRAPPER_STRING(bx_dbg_instrument_command)
+
+SIMPLE_WRAPPER_STRING_STRING(bx_dbg_restore_command)
+
+SIMPLE_WRAPPER_UINT_UINT(bx_dbg_info_idt_command)
+SIMPLE_WRAPPER_UINT_UINT(bx_dbg_info_gdt_command)
+SIMPLE_WRAPPER_UINT_UINT(bx_dbg_info_ldt_command)
+SIMPLE_WRAPPER(bx_dbg_info_tss_command)
+SIMPLE_WRAPPER_UINT_UINT(bx_dbg_info_ivt_command)
+
+SIMPLE_WRAPPER_STRING_UINT(bx_dbg_take_command)
+SIMPLE_WRAPPER_STRING_UINT(bx_dbg_set_symbol_command)
+SIMPLE_WRAPPER_BREAKPOINTKIND_UINT_UINT(bx_dbg_vbreakpoint_command)
+SIMPLE_WRAPPER_UINT_UINT_UINT(bx_dbg_setpmem_command)
+SIMPLE_WRAPPER_STRING_STRING_UINT_UINT_UINT(bx_dbg_examine_command)
+SIMPLE_WRAPPER_STRING_UINT_UINT(bx_dbg_disassemble_command)
+
+// Default docstring for commands for which no documentation
+// is available and their usage is fuzzy.
+#define NOT_DOCUMENTED  "No useful information available."
+
+static PyMethodDef bx_dbg_methods[] = {
+    {"cont",  py_bx_dbg_continue_command, METH_VARARGS,
+     "Continue the emulation."},
+    {"quit",  py_bx_dbg_quit_command, METH_VARARGS,
+     "Quit Bochs."},
+    {"stepN",  py_bx_dbg_stepN_command, METH_VARARGS,
+     "Step N instructions."},
+    {"step_over",  py_bx_dbg_step_over_command, METH_VARARGS,
+     "Step over."},
+    {"info_control_regs",  py_bx_dbg_info_control_regs_command, METH_VARARGS,
+     "Print information about the control registers."},
+    {"restore",  py_bx_dbg_restore_command, METH_VARARGS,
+     "Restore from a previous state."},
+    {"print_stack",  py_bx_dbg_print_stack_command, METH_VARARGS,
+     "Print stack information."},
+    {"where",  py_bx_dbg_where_command, METH_VARARGS,
+     "Print where the call was made from."},
+    {"show",  py_bx_dbg_show_command, METH_VARARGS,
+     "Toggles show symbolic info."},
+/*    {"trace_on",  py_bx_dbg_trace_on_command, METH_VARARGS,
+     "Enable tracing."},
+    {"trace_off",  py_bx_dbg_trace_off_command, METH_VARARGS,
+     "Disable tracing."},
+    {"trace_reg_on",  py_bx_dbg_trace_reg_on_command, METH_VARARGS,
+     "Enable register tracing."},
+    {"trace_reg_off",  py_bx_dbg_trace_reg_off_command, METH_VARARGS,
+     "Disable register tracing."},
+*/
+    {"trace",  py_bx_dbg_trace_command, METH_VARARGS,
+    "Enable/disable tracing."},
+    {"trace_reg",  py_bx_dbg_trace_reg_command, METH_VARARGS,
+    "Enable/disable register tracing."},
+    {"trace_mem",  py_bx_dbg_trace_mem_command, METH_VARARGS,
+    "Enable/disable memory tracing."},
+      
+    {"ptime",  py_bx_dbg_ptime_command, METH_VARARGS,
+     "Print processor time."},
+    {"info_bpoints",  py_bx_dbg_info_bpoints_command, METH_VARARGS,
+     "Show breakpoints info."},
+    {"record",  py_bx_dbg_record_command, METH_VARARGS,
+     "Record commands to file."},
+    {"playback",  py_bx_dbg_playback_command, METH_VARARGS,
+     "Playback commands from file."},
+    {"modebp",  py_bx_dbg_modebp_command, METH_VARARGS,
+     "Toggles vm86 mode switch breakpoint."},
+    {"query",  py_bx_dbg_query_command, METH_VARARGS,
+     NOT_DOCUMENTED},
+    {"instrument",  py_bx_dbg_instrument_command, METH_VARARGS,
+     "Start/Stop/Query the intrumentation interface if present."},
+    {"del_breakpoint",  py_bx_dbg_del_breakpoint_command, METH_VARARGS,
+     "Delete breakpoint."},
+    {"calc",  py_bx_dbg_calc_command, METH_VARARGS,
+     NOT_DOCUMENTED},
+    {"print_string",  py_bx_dbg_print_string_command, METH_VARARGS,
+     "Print string starting at the provided address."},
+    {"info_registers",  py_bx_dbg_info_registers_command, METH_VARARGS,
+     "Print information about registers"},
+    {"info_idt",  py_bx_dbg_info_idt_command, METH_VARARGS,
+     "Print information about IDT."},
+    {"info_gdt",  py_bx_dbg_info_gdt_command, METH_VARARGS,
+     "Print information about GDT."},
+    {"info_ldt",  py_bx_dbg_info_ldt_command, METH_VARARGS,
+     "Print information about LDT."},
+    {"info_tss",  py_bx_dbg_info_tss_command, METH_VARARGS,
+     "Print information about TSS."},
+    {"info_ivt",  py_bx_dbg_info_ivt_command, METH_VARARGS,
+     "Print information about IVT."},
+    {"timebp",  py_bx_dbg_timebp_command, METH_VARARGS,
+     "Set a breakpoint in time."},
+    {"en_dis_breakpoint",  py_bx_dbg_en_dis_breakpoint_command, METH_VARARGS,
+     "Enable/Disable breakpoint. (handle, enable)"},
+    {"lbreakpoint",  py_bx_dbg_lbreakpoint_command, METH_VARARGS,
+     "Set linear breakpoint at address. (kind, address) kind (regular, atip, stepover)"},
+    {"pbreakpoint",  py_bx_dbg_pbreakpoint_command, METH_VARARGS,
+     "Set physical breakpoint at address. (kind, address) kind (regular, atip, stepover)"},
+    {"crc",  py_bx_dbg_crc_command, METH_VARARGS,
+     "Perform CRC in range (start, end)."},
+    {"take",  py_bx_dbg_take_command, METH_VARARGS,
+     "Take IRQ/DMA? (unclear)"},
+    {"set_symbol",  py_bx_dbg_set_symbol_command, METH_VARARGS,
+     "Set CPU symbol e.g. $eax, $ebx, $ecx ... (symbol, value)"},
+    {"vbreakpoint",  py_bx_dbg_vbreakpoint_command, METH_VARARGS,
+     "Set virtual breakpoint (kind, cs, eip) kind (regular, atip, stepover)"},
+    {"setpmem",  py_bx_dbg_setpmem_command, METH_VARARGS,
+     "Write value (byte, word, dword) into the given physical address (address, length, value)."},
+    {"examine",  py_bx_dbg_examine_command, METH_VARARGS,
+     "Examine memory (command, format, format_passed, address, addr_passed)"},
+    {"disassemble",  py_bx_dbg_disassemble_command, METH_VARARGS,
+     "Disassemble memory (start, end)"},
+    {NULL, NULL, 0, NULL}
+};
+
+
+int execute_initialization_script()
+{
+    char *script_path;
+    char *buffer;
+    size_t bufer_length;
+    struct stat script_stat;
+    FILE *script_file;
+    PyObject *bytecode;
+    PyObject *init_module;
+    
+    script_path = getenv(INIT_SCRIPT_ENV_NAME);
+    
+    // If the environment variable is not set just return
+    if(!script_path) {
+        dbg_printf("bochs-python: environment variable \"%s\" not set\n",
+            INIT_SCRIPT_ENV_NAME);
+        return 1;
+    }
+        
+    if( stat(script_path, &script_stat) != 0 ) {
+        dbg_printf("bochs-python: environment variable set but file can't be accessed\n");
+        return 0;
+    }
+        
+    script_file = fopen(script_path, "rt");
+    
+    // If can't open file just return
+    if(!script_file) {
+        dbg_printf("bochs-python: environment variable set but file can't be opened\n");
+        return 0;
+    }
+
+    bufer_length = script_stat.st_size;
+    buffer = (char *)malloc( bufer_length + 1 );
+    if(!buffer)
+        return 0;
+            
+    fread(buffer, bufer_length, 1, script_file);
+    buffer[bufer_length] = '\0';
+    
+    // Remove whitespaces at the end of the file
+    //
+    while( buffer[--bufer_length] == ' ' )
+        buffer[bufer_length] = '\0';
+    
+    
+    //execute_input(buffer);
+    
+    bytecode = Py_CompileString(buffer, "initmodule", Py_file_input);
+    if(bytecode==NULL) {
+        bochs_handle_error();
+        dbg_printf("bochs-python: can't compile Python initialization module\n");
+        dbg_printf("bochs-python: the data is %d bytes long\n", strlen(buffer));
+        return 0;
+    }
+
+    init_module = PyImport_ExecCodeModule(INIT_SCRIPT_ENV_NAME, bytecode);
+    if(init_module==NULL) {
+        bochs_handle_error();
+        dbg_printf("bochs-python: can't import Python initialization module\n");
+        return 0;
+    }
+    
+    free(buffer);
+
+    dbg_printf("bochs-python: initialization file [%s] loaded and executed\n", script_path);
+    
+    return 1;
+}
+
+#endif
+
+int bx_dbg_main(void)
+{
+#if BX_INSTRUMENTATION_PYTHON_HOOKS
+  PyObject *bx, *dbg, *cpu;
+#endif
+  int i;
+  
+  setbuf(stdout, NULL);
+  setbuf(stderr, NULL);
+
+  bx_dbg_batch_dma.this_many = 1;
+  bx_dbg_batch_dma.Qsize     = 0;
+
+  memset(&bx_guard, 0, sizeof(bx_guard));
+  bx_guard.async.irq = 1;
+  bx_guard.async.dma = 1;
+
+  memset(&bx_debugger, 0, sizeof(bx_debugger));
+  bx_debugger.auto_disassemble = 1;
+  bx_debugger.disassemble_size = 0;
+  bx_debugger.default_display_format = 'x';
+  bx_debugger.default_unit_size      = 'w';
+  bx_debugger.default_addr = 0;
+  bx_debugger.next_bpoint_id = 1;
+  bx_debugger.next_wpoint_id = 1;
+
+  dbg_cpu_list = (bx_list_c*) SIM->get_param("cpu0", SIM->get_bochs_root());
+  const char *debugger_log_filename = SIM->get_param_string(BXPN_DEBUGGER_LOG_FILENAME)->getptr();
+
+  // Open debugger log file if needed
+  if (strlen(debugger_log_filename) > 0 && (strcmp(debugger_log_filename, "-") != 0))
+  {
+    debugger_log = fopen(debugger_log_filename, "w");
+    if (!debugger_log) {
+      BX_PANIC(("Can not open debugger log file '%s'", debugger_log_filename));
+    }
+    else {
+      BX_INFO(("Using debugger log file %s", debugger_log_filename));
+    }
+  }
+
+  memset(bx_disasm_ibuf, 0, sizeof(bx_disasm_ibuf));
+
+  // create a boolean parameter that will tell if the simulation is
+  // running (continue command) or waiting for user response.  This affects
+  // some parts of the GUI.
+  if (sim_running == NULL) {
+    bx_list_c *base = (bx_list_c*) SIM->get_param("general");
+    sim_running = new bx_param_bool_c(base,
+        "debug_running",
+        "Simulation is running", "", 0);
+  } else {
+    sim_running->set(0);
+  }
+  // setup Ctrl-C handler
+  if (!SIM->has_debug_gui()) {
+    signal(SIGINT, bx_debug_ctrlc_handler);
+    BX_INFO(("set SIGINT handler to bx_debug_ctrlc_handler"));
+  }
+
+  // Print disassembly of the first instruction...  you wouldn't think it
+  // would have to be so hard.  First initialize guard_found, since it is used
+  // in the disassembly code to decide what instruction to print.
+  for (int i=0; i<BX_SMP_PROCESSORS; i++) {
+    BX_CPU(i)->guard_found.cs = BX_CPU(i)->sregs[BX_SEG_REG_CS].selector.value;
+    BX_CPU(i)->guard_found.eip = BX_CPU(i)->prev_rip;
+    BX_CPU(i)->guard_found.laddr =
+      BX_CPU(i)->get_laddr(BX_SEG_REG_CS, BX_CPU(i)->prev_rip);
+    // 00 - 16 bit, 01 - 32 bit, 10 - 64-bit, 11 - illegal
+    if (BX_CPU(i)->sregs[BX_SEG_REG_CS].cache.u.segment.d_b)
+      BX_CPU(i)->guard_found.code_32_64 |= 0x1;
+    if (BX_CPU(i)->get_cpu_mode() == BX_MODE_LONG_64)
+      BX_CPU(i)->guard_found.code_32_64 |= 0x2;
+  }
+  // finally, call the usual function to print the disassembly
+  dbg_printf("Next at t=" FMT_LL "d\n", bx_pc_system.time_ticks());
+  bx_dbg_disassemble_current(-1, 0);  // all cpus, don't print time
+
+#if BX_INSTRUMENTATION_PYTHON_HOOKS
+  init_interpreter();
+  
+  bx = Py_InitModule("bx", bx_dbg_methods);
+  dbg = Py_InitModule("dbg", dbg_methods);
+  cpu = Py_InitModule("cpu", cpu_methods);
+
+  execute_input("import bx");
+  execute_input("import dbg");
+  execute_input("import cpu");
+
+// This come from instrument.h, we want this constants in Python too
+//
+
+  execute_input("INSTR_MOV_CR3   = 10");
+  execute_input("INSTR_INVLPG    = 11");
+  execute_input("INSTR_TASKSWITCH= 12");
+  execute_input("INSTR_INVD      = 20");
+  execute_input("INSTR_WBINVD    = 21");
+  execute_input("INSTR_IS_CALL   = 10");
+  execute_input("INSTR_IS_RET    = 11");
+  execute_input("INSTR_IS_IRET   = 12");
+  execute_input("INSTR_IS_JMP    = 13");
+  execute_input("INSTR_IS_INT    = 14");
+  execute_input("INSTR_PREFETCH_NTA= 00");
+  execute_input("INSTR_PREFETCH_T0 = 01");
+  execute_input("INSTR_PREFETCH_T1 = 02");
+  execute_input("INSTR_PREFETCH_T2 = 03");
+  
+  
+  for(i=0; i<INSTR_CALLBACK_COUNT; i++) {
+      if(0>PyObject_SetAttrString(
+            dbg, callback_strings[i], PyLong_FromUnsignedLongLong(i))) {
+        dbg_printf("Can't add \"%s=%d\" constant to dbg!!\n", callback_strings[i], i);
+      }
+  }
+
+  for(i=0; i<CPU_LAST_ENUM; i++) {
+      if(0>PyObject_SetAttrString(
+            cpu, cpu_python_strings[i], PyLong_FromUnsignedLongLong(i))) {
+        dbg_printf("Can't add \"%s=%d\" constant to cpu!!\n", cpu_python_strings[i], i);
+      }
+  }
+
+
+  if(execute_initialization_script()) {
+      main_loop();
+  }
+  
+  shutdown_interpreter();
+#else
+  bx_dbg_user_input_loop();
+#endif
+
+  if(debugger_log != NULL)
+    fclose(debugger_log);
+
+  bx_dbg_exit(0);
+  return(0); // keep compiler happy
+}
+
+void bx_dbg_interpret_line(char *cmd)
+{
+  bx_add_lex_input(cmd);
+  bxparse();
+}
+
+void bx_dbg_user_input_loop(void)
+{
+  int reti;
+  unsigned include_cmd_len = strlen(BX_INCLUDE_CMD);
+
+  while(1) {
+    SIM->refresh_ci();
+    SIM->set_display_mode(DISP_MODE_CONFIG);
+    bx_get_command();
+reparse:
+    if ((*tmp_buf_ptr == '\n') || (*tmp_buf_ptr == 0))
+    {
+        if ((*tmp_buf_prev != '\n') && (*tmp_buf_prev != 0)) {
+          strncpy(tmp_buf, tmp_buf_prev, sizeof(tmp_buf_prev));
+          goto reparse;
+        }
+    }
+    else if ((strncmp(tmp_buf_ptr, BX_INCLUDE_CMD, include_cmd_len) == 0) &&
+              (tmp_buf_ptr[include_cmd_len] == ' ' ||
+               tmp_buf_ptr[include_cmd_len] == '\t'))
+    {
+      char *ptr = tmp_buf_ptr + include_cmd_len + 1;
+      while(*ptr==' ' || *ptr=='\t')
+        ptr++;
+
+      int len = strlen(ptr);
+      if (len == 0) {
+        dbg_printf("%s: no filename given to 'source' command.\n", argv0);
+        if (bx_infile_stack_index > 0) {
+          dbg_printf("%s: ERROR in source file causes exit.\n", argv0);
+          bx_dbg_exit(1);
+        }
+        continue;
+      }
+      ptr[len-1] = 0; // get rid of newline
+      reti = bx_nest_infile(ptr);
+      if (reti==0 && bx_infile_stack_index > 0) {
+        dbg_printf("%s: ERROR in source file causes exit.\n", argv0);
+        bx_dbg_exit(1);
+      }
+    }
+    else {
+      // Give a chance to the command line extensions, to
+      // consume the command.  If they return 0, then
+      // we need to process the command.  A return of 1
+      // means, the extensions have handled the command
+      if (bx_dbg_extensions(tmp_buf_ptr)==0) {
+        // process command here
+        bx_add_lex_input(tmp_buf_ptr);
+        bxparse();
+      }
+    }
+  }
+}
+
+void bx_get_command(void)
+{
+  char *charptr_ret;
+
+  bx_infile_stack[bx_infile_stack_index].lineno++;
+
+  char prompt[256];
+  if (bx_infile_stack_index == 0) {
+    sprintf(prompt, "<bochs:%d> ", bx_infile_stack[bx_infile_stack_index].lineno);
+  }
+  if (SIM->has_debug_gui() && bx_infile_stack_index == 0) {
+    // wait for wxWidgets to send another debugger command
+    charptr_ret = SIM->debug_get_next_command();
+    if (charptr_ret) {
+      strncpy(tmp_buf, charptr_ret, sizeof(tmp_buf));
+      strcat(tmp_buf, "\n");
+      // The returned string was allocated in wxmain.cc by "new char[]".
+      // Free it with delete[].
+      delete [] charptr_ret;
+      charptr_ret = &tmp_buf[0];
+    } else {
+      // if debug_get_next_command returned NULL, probably the GUI is
+      // shutting down
+    }
+  }
+#if HAVE_LIBREADLINE
+  else if (bx_infile_stack_index == 0) {
+    charptr_ret = readline(prompt);
+    // beware, returns NULL on end of file
+    if (charptr_ret && strlen(charptr_ret) > 0) {
+      add_history(charptr_ret);
+      strcpy(tmp_buf, charptr_ret);
+      strcat(tmp_buf, "\n");
+      free(charptr_ret);
+      charptr_ret = &tmp_buf[0];
+    }
+  } else {
+    charptr_ret = fgets(tmp_buf, sizeof(tmp_buf), bx_infile_stack[bx_infile_stack_index].fp);
+  }
+#else /* !HAVE_LIBREADLINE */
+  else {
+    if (bx_infile_stack_index == 0)
+      dbg_printf("%s", prompt);
+    strncpy(tmp_buf_prev, tmp_buf, sizeof(tmp_buf));
+    charptr_ret = fgets(tmp_buf, sizeof(tmp_buf), bx_infile_stack[bx_infile_stack_index].fp);
+  }
+#endif
+  if (charptr_ret == NULL) {
+    // see if error was due to EOF condition
+    if (feof(bx_infile_stack[bx_infile_stack_index].fp)) {
+      if (bx_infile_stack_index > 0) {
+        // nested level of include files, pop back to previous one
+        bx_unnest_infile();
+      }
+      else {
+        // not nested, sitting at stdin prompt, user wants out
+        bx_dbg_quit_command();
+        BX_PANIC(("bx_dbg_quit_command should not return, but it did"));
+      }
+
+      // call recursively
+      bx_get_command();
+      return;
+    }
+
+    // error was not EOF, see if it was from a Ctrl-C
+    if (bx_guard.interrupt_requested) {
+      tmp_buf[0] = '\n';
+      tmp_buf[1] = 0;
+      tmp_buf_ptr = &tmp_buf[0];
+      bx_guard.interrupt_requested = 0;
+      return;
+    }
+
+    dbg_printf("fgets() returned ERROR.\n");
+    dbg_printf("intr request was %u\n", bx_guard.interrupt_requested);
+    bx_dbg_exit(1);
+  }
+  tmp_buf_ptr = &tmp_buf[0];
+
+  if (debugger_log != NULL) {
+    fprintf(debugger_log, "%s", tmp_buf);
+    fflush(debugger_log);
+  }
+
+  // look for first non-whitespace character
+  while (((*tmp_buf_ptr == ' ')  || (*tmp_buf_ptr == '\t')) &&
+          (*tmp_buf_ptr != '\n') && (*tmp_buf_ptr != 0))
+  {
+    tmp_buf_ptr++;
+  }
+}
+
+int bx_nest_infile(char *path)
+{
+  FILE *tmp_fp;
+
+  tmp_fp = fopen(path, "r");
+  if (!tmp_fp) {
+    dbg_printf("%s: can not open file '%s' for reading.\n", argv0, path);
+    return(0);
+  }
+
+  if ((bx_infile_stack_index+1) >= BX_INFILE_DEPTH) {
+    dbg_printf("%s: source files nested too deeply\n", argv0);
+    return(0);
+  }
+
+  bx_infile_stack_index++;
+  bx_infile_stack[bx_infile_stack_index].fp = tmp_fp;
+  strncpy(bx_infile_stack[bx_infile_stack_index].fname, path, BX_MAX_PATH);
+  bx_infile_stack[bx_infile_stack_index].fname[BX_MAX_PATH-1] = 0;
+  bx_infile_stack[bx_infile_stack_index].lineno = 0;
+  return(1);
+}
+
+void bx_unnest_infile(void)
+{
+  if (bx_infile_stack_index <= 0) {
+    dbg_printf("%s: ERROR: unnest_infile(): nesting level = 0\n", argv0);
+    bx_dbg_exit(1);
+  }
+
+  fclose(bx_infile_stack[bx_infile_stack_index].fp);
+  bx_infile_stack_index--;
+}
+
+int bxwrap(void)
+{
+  dbg_printf("%s: ERROR: bxwrap() called\n", argv0);
+  bx_dbg_exit(1);
+  return(0); // keep compiler quiet
+}
+
+#ifdef WIN32
+char* bxtext;
+#endif
+
+void bxerror(char *s)
+{
+  dbg_printf("%s:%d: %s at '%s'\n", bx_infile_stack[bx_infile_stack_index].fname,
+    bx_infile_stack[bx_infile_stack_index].lineno, s, bxtext);
+
+  if (bx_infile_stack_index > 0) {
+    dbg_printf("%s: ERROR in source file causes exit\n", argv0);
+    bx_dbg_exit(1);
+  }
+}
+
+void CDECL bx_debug_ctrlc_handler(int signum)
+{
+  UNUSED(signum);
+  if (SIM->has_debug_gui()) {
+    // in a multithreaded environment, a signal such as SIGINT can be sent to all
+    // threads.  This function is only intended to handle signals in the
+    // simulator thread.  It will simply return if called from any other thread.
+    // Otherwise the BX_PANIC() below can be called in multiple threads at
+    // once, leading to multiple threads trying to display a dialog box,
+    // leading to GUI deadlock.
+    if (!SIM->is_sim_thread()) {
+      BX_INFO(("bx_signal_handler: ignored sig %d because it wasn't called from the simulator thread", signum));
+      return;
+    }
+  }
+  BX_INFO(("Ctrl-C detected in signal handler."));
+
+  signal(SIGINT, bx_debug_ctrlc_handler);
+  bx_debug_break();
+}
+
+void bx_debug_break()
+{
+  bx_guard.interrupt_requested = 1;
+}
+
+void bx_dbg_exception(unsigned cpu, Bit8u vector, Bit16u error_code)
+{
+  static const char *exception[] = {
+     "(#DE) divide by zero",
+     "(#DB) debug break",
+     "(#NMI)",
+     "(#BP) breakpoint match",
+     "(#OF) overflow",
+     "(#BR) boundary check",
+     "(#UD) undefined opcode",
+     "(#NM) device not available",
+     "(#DF) double fault",
+     "(#CO) coprocessor overrun",
+     "(#TS) invalid TSS",
+     "(#NP) segment not present",
+     "(#SS) stack fault",
+     "(#GP) general protection fault",
+     "(#PF) page fault",
+     "(#RESERVED)",
+     "(#MF) floating point error",
+     "(#AC) alignment check",
+     "(#MC) machine check",
+     "(#XF) SIMD floating point exception",
+  };
+
+  if (BX_CPU(dbg_cpu)->trace || bx_dbg.exceptions)
+  {
+    if (vector <= BX_XM_EXCEPTION) {
+      dbg_printf("CPU %d: Exception 0x%02x - %s occured (error_code=0x%04x)\n",
+        cpu, vector, exception[vector], error_code);
+    }
+    else {
+      dbg_printf("CPU %d: Exception 0x%02x occured (error_code=0x%04x)\n",
+        cpu, vector, error_code);
+    }
+  }
+}
+
+void bx_dbg_interrupt(unsigned cpu, Bit8u vector, Bit16u error_code)
+{
+  if (BX_CPU(dbg_cpu)->trace || bx_dbg.interrupts)
+  {
+    dbg_printf("CPU %d: Interrupt 0x%02x occured (error_code=0x%04x)\n",
+      cpu, vector, error_code);
+  }
+}
+
+void bx_dbg_halt(unsigned cpu)
+{
+  if (BX_CPU(dbg_cpu)->trace)
+  {
+    dbg_printf("CPU %d: HALTED\n", cpu);
+  }
+}
+
+void bx_dbg_watchpoint_continue(bx_bool watch_continue)
+{
+  watchpoint_continue = watch_continue;
+  if (watchpoint_continue) {
+     dbg_printf("Will stop on watch points\n");
+  }
+  else {
+     dbg_printf("Will not stop on watch points (they will still be logged)\n");
+  }
+}
+
+void bx_dbg_check_memory_watchpoints(unsigned cpu, bx_phy_address phy, unsigned len, unsigned rw)
+{
+  bx_phy_address phy_end = phy + len - 1;
+
+  if (rw & 1) {
+    // Check for physical write watch points
+    for (unsigned i = 0; i < num_write_watchpoints; i++) {
+      bx_phy_address watch_end = write_watchpoint[i].addr + write_watchpoint[i].len - 1;
+      if (watch_end < phy || phy_end < write_watchpoint[i].addr) continue;
+      BX_CPU(cpu)->watchpoint  = phy;
+      BX_CPU(cpu)->break_point = BREAK_POINT_WRITE;
+      break;
+    }
+  }
+  else {
+    // Check for physical read watch points
+    for (unsigned i = 0; i < num_read_watchpoints; i++) {
+      bx_phy_address watch_end = read_watchpoint[i].addr + read_watchpoint[i].len - 1;
+      if (watch_end < phy || phy_end < read_watchpoint[i].addr) continue;
+      BX_CPU(cpu)->watchpoint  = phy;
+      BX_CPU(cpu)->break_point = BREAK_POINT_READ;
+      break;
+    }
+  }
+}
+
+void bx_dbg_lin_memory_access(unsigned cpu, bx_address lin, bx_phy_address phy, unsigned len, unsigned pl, unsigned rw, Bit8u *data)
+{
+  bx_dbg_check_memory_watchpoints(cpu, phy, len, rw);
+
+  if (! BX_CPU(cpu)->trace_mem)
+    return;
+
+  bx_bool write = rw & 1;
+
+  dbg_printf("[CPU%d %s]: LIN 0x" FMT_ADDRX " PHY 0x" FMT_PHY_ADDRX " (len=%d, pl=%d)",
+     cpu, 
+     (write) ? "WR" : "RD",
+     lin, phy,
+     len, pl);
+
+  if (len == 1) {
+     Bit8u val8 = *data;
+     dbg_printf(": 0x%02X", (unsigned) val8);
+  }
+  else if (len == 2) {
+     Bit16u val16 = *((Bit16u*) data);
+     dbg_printf(": 0x%04X", (unsigned) val16);
+  }
+  else if (len == 4) {
+     Bit32u val32 = *((Bit32u*) data);
+     dbg_printf(": 0x%08X", (unsigned) val32);
+  }
+  else if (len == 8) {
+     Bit64u data64 = * (Bit64u*)(data);
+     dbg_printf(": 0x%08X 0x%08X", GET32H(data64), GET32L(data64));
+  }
+#if BX_CPU_LEVEL >= 6
+  else if (len == 16) {
+     const BxPackedXmmRegister *xmmdata = (const BxPackedXmmRegister*)(data);
+     dbg_printf(": 0x%08X 0x%08X 0x%08X 0x%08X",
+         xmmdata->xmm32u(3), xmmdata->xmm32u(2), xmmdata->xmm32u(1), xmmdata->xmm32u(0));
+  }
+#endif
+
+  dbg_printf("\n");
+}
+
+void bx_dbg_phy_memory_access(unsigned cpu, bx_phy_address phy, unsigned len, unsigned rw, Bit8u *data)
+{
+  bx_dbg_check_memory_watchpoints(cpu, phy, len, rw);
+
+  if (! BX_CPU(cpu)->trace_mem)
+    return;
+
+  bx_bool write = rw & 1;
+
+  dbg_printf("[CPU%d %s]: PHY 0x" FMT_PHY_ADDRX " (len=%d)",
+     cpu, 
+     (write) ? "WR" : "RD",
+     phy,
+     len);
+
+  if (len == 1) {
+     Bit8u val8 = *data;
+     dbg_printf(": 0x%02X", (unsigned) val8);
+  }
+  else if (len == 2) {
+     Bit16u val16 = *((Bit16u*) data);
+     dbg_printf(": 0x%04X", (unsigned) val16);
+  }
+  else if (len == 4) {
+     Bit32u val32 = *((Bit32u*) data);
+     dbg_printf(": 0x%08X", (unsigned) val32);
+  }
+  else if (len == 8) {
+     Bit64u data64 = * (Bit64u*)(data);
+     dbg_printf(": 0x%08X 0x%08X", GET32H(data64), GET32L(data64));
+  }
+#if BX_CPU_LEVEL >= 6
+  else if (len == 16) {
+     const BxPackedXmmRegister *xmmdata = (const BxPackedXmmRegister*)(data);
+     dbg_printf(": 0x%08X 0x%08X 0x%08X 0x%08X",
+         xmmdata->xmm32u(3), xmmdata->xmm32u(2), xmmdata->xmm32u(1), xmmdata->xmm32u(0));
+  }
+#endif
+
+  dbg_printf("\n");
+}
+
+void bx_dbg_exit(int code)
+{
+  BX_DEBUG(("dbg: before exit"));
+  for (int cpu=0; cpu < BX_SMP_PROCESSORS; cpu++) {
+    if (BX_CPU(cpu)) BX_CPU(cpu)->atexit();
+  }
+
+  bx_atexit();
+  BX_EXIT(code);
+}
+
+//
+// functions for browsing of cpu state
+//
+
+void bx_dbg_print_sse_state(void)
+{
+#if BX_SUPPORT_SSE
+  Bit32u mxcsr = SIM->get_param_num("SSE.mxcsr", dbg_cpu_list)->get();
+  dbg_printf("MXCSR: 0x%08x: %s %s RC:%d %s %s %s %s %s %s %s %s %s %s %s %s %s\n", mxcsr,
+     (mxcsr & (1<<17)) ? "ULE" : "ule",
+     (mxcsr & (1<<15)) ? "FUZ" : "fuz",
+     (mxcsr >> 13) & 3,
+     (mxcsr & (1<<12)) ? "PM" : "pm",
+     (mxcsr & (1<<11)) ? "UM" : "um",
+     (mxcsr & (1<<10)) ? "OM" : "om",
+     (mxcsr & (1<<9)) ? "ZM" : "zm",
+     (mxcsr & (1<<8)) ? "DM" : "dm",
+     (mxcsr & (1<<7)) ? "IM" : "im",
+     (mxcsr & (1<<6)) ? "DAZ" : "daz",
+     (mxcsr & (1<<5)) ? "PE" : "pe",
+     (mxcsr & (1<<4)) ? "UE" : "ue",
+     (mxcsr & (1<<3)) ? "OE" : "oe",
+     (mxcsr & (1<<2)) ? "ZE" : "ze",
+     (mxcsr & (1<<1)) ? "DE" : "de",
+     (mxcsr & (1<<0)) ? "IE" : "ie");
+
+  char param_name[20];
+  for(unsigned i=0;i<BX_XMM_REGISTERS;i++) {
+    sprintf(param_name, "SSE.xmm%02d_hi", i);
+    Bit64u hi = SIM->get_param_num(param_name, dbg_cpu_list)->get64();
+    sprintf(param_name, "SSE.xmm%02d_lo", i);
+    Bit64u lo = SIM->get_param_num(param_name, dbg_cpu_list)->get64();
+    dbg_printf("XMM[%02u]: %08x:%08x:%08x:%08x\n", i,
+       GET32H(hi), GET32L(hi), GET32H(lo), GET32L(lo));
+  }
+#else
+  dbg_printf("The CPU doesn't support SSE state !\n");
+#endif
+}
+
+void bx_dbg_print_mmx_state(void)
+{
+#if BX_SUPPORT_MMX
+  char param_name[20];
+  for(unsigned i=0;i<8;i++) {
+    sprintf(param_name, "FPU.st%d.fraction", i);
+    Bit64u mmreg = SIM->get_param_num(param_name, dbg_cpu_list)->get64();
+    dbg_printf("MM[%d]: %08x:%08x\n", i, GET32H(mmreg), GET32L(mmreg));
+  }
+#else
+  dbg_printf("The CPU doesn't support MMX state !\n");
+#endif
+}
+
+void bx_dbg_print_fpu_state(void)
+{
+#if BX_SUPPORT_FPU
+  BX_CPU(dbg_cpu)->print_state_FPU();
+#else
+  dbg_printf("The CPU doesn't support FPU state !\n");
+#endif
+}
+
+void bx_dbg_info_flags(void)
+{
+  dbg_printf("%s %s %s %s %s %s %s IOPL=%1u %s %s %s %s %s %s %s %s %s\n",
+    BX_CPU(dbg_cpu)->get_ID() ? "ID" : "id",
+    BX_CPU(dbg_cpu)->get_VIP() ? "VIP" : "vip",
+    BX_CPU(dbg_cpu)->get_VIF() ? "VIF" : "vif",
+    BX_CPU(dbg_cpu)->get_AC() ? "AC" : "ac",
+    BX_CPU(dbg_cpu)->get_VM() ? "VM" : "vm",
+    BX_CPU(dbg_cpu)->get_RF() ? "RF" : "rf",
+    BX_CPU(dbg_cpu)->get_NT() ? "NT" : "nt",
+    BX_CPU(dbg_cpu)->get_IOPL(),
+    BX_CPU(dbg_cpu)->get_OF() ? "OF" : "of",
+    BX_CPU(dbg_cpu)->get_DF() ? "DF" : "df",
+    BX_CPU(dbg_cpu)->get_IF() ? "IF" : "if",
+    BX_CPU(dbg_cpu)->get_TF() ? "TF" : "tf",
+    BX_CPU(dbg_cpu)->get_SF() ? "SF" : "sf",
+    BX_CPU(dbg_cpu)->get_ZF() ? "ZF" : "zf",
+    BX_CPU(dbg_cpu)->get_AF() ? "AF" : "af",
+    BX_CPU(dbg_cpu)->get_PF() ? "PF" : "pf",
+    BX_CPU(dbg_cpu)->get_CF() ? "CF" : "cf");
+}
+
+void bx_dbg_info_debug_regs_command(void)
+{
+  bx_address dr0 = SIM->get_param_num("DR0", dbg_cpu_list)->get();
+  bx_address dr1 = SIM->get_param_num("DR1", dbg_cpu_list)->get();
+  bx_address dr2 = SIM->get_param_num("DR2", dbg_cpu_list)->get();
+  bx_address dr3 = SIM->get_param_num("DR3", dbg_cpu_list)->get();
+  Bit32u dr6 = SIM->get_param_num("DR6", dbg_cpu_list)->get();
+  Bit32u dr7 = SIM->get_param_num("DR7", dbg_cpu_list)->get();
+
+  dbg_printf("DR0=0x" FMT_ADDRX "\n", dr0);
+  dbg_printf("DR1=0x" FMT_ADDRX "\n", dr1);
+  dbg_printf("DR2=0x" FMT_ADDRX "\n", dr2);
+  dbg_printf("DR3=0x" FMT_ADDRX "\n", dr3);
+
+  static const char *dr_ln[4] = { "Byte", "Word", "QWord", "Dword" };
+  static const char *dr_rw[4] = { "Code", "DataW", "I/O", "DataRW" };
+
+  dbg_printf("DR6=0x%08x: %s %s %s %s %s %s %s\n", dr6,
+      (dr6 & (1<<15)) ? "BT" : "bt",
+      (dr6 & (1<<14)) ? "BS" : "bs",
+      (dr6 & (1<<13)) ? "BD" : "bd",
+      (dr6 & (1<<3)) ? "B3" : "b3",
+      (dr6 & (1<<2)) ? "B2" : "b2",
+      (dr6 & (1<<1)) ? "B1" : "b1",
+      (dr6 & (1<<0)) ? "B0" : "b0");
+
+  dbg_printf("DR7=0x%08x: DR3=%s-%s DR2=%s-%s DR1=%s-%s DR0=%s-%s %s | %s %s | %s %s %s %s %s %s %s %s\n", dr7,
+      dr_rw[(dr7 >> 28) & 3], dr_ln[(dr7 >> 30) & 3],
+      dr_rw[(dr7 >> 24) & 3], dr_ln[(dr7 >> 26) & 3],
+      dr_rw[(dr7 >> 20) & 3], dr_ln[(dr7 >> 22) & 3],
+      dr_rw[(dr7 >> 16) & 3], dr_ln[(dr7 >> 18) & 3],
+      (dr7 & (1<<13)) ? "GD" : "gd",
+      (dr7 & (1<<9)) ? "GE" : "ge",
+      (dr7 & (1<<8)) ? "LE" : "le",
+      (dr7 & (1<<7)) ? "G3" : "g3",
+      (dr7 & (1<<6)) ? "L3" : "l3",
+      (dr7 & (1<<5)) ? "G2" : "g2",
+      (dr7 & (1<<4)) ? "L2" : "l2",
+      (dr7 & (1<<3)) ? "G1" : "g1",
+      (dr7 & (1<<2)) ? "L1" : "l1",
+      (dr7 & (1<<1)) ? "G0" : "g0",
+      (dr7 & (1<<0)) ? "L0" : "l0");
+}
+
+void bx_dbg_info_control_regs_command(void)
+{
+  Bit32u cr0 = SIM->get_param_num("CR0", dbg_cpu_list)->get();
+  bx_address cr2 = (bx_address) SIM->get_param_num("CR2", dbg_cpu_list)->get64();
+  bx_phy_address cr3 = (bx_phy_address) SIM->get_param_num("CR3", dbg_cpu_list)->get64();
+  dbg_printf("CR0=0x%08x: %s %s %s %s %s %s %s %s %s %s %s\n", cr0,
+    (cr0 & (1<<31)) ? "PG" : "pg",
+    (cr0 & (1<<30)) ? "CD" : "cd",
+    (cr0 & (1<<29)) ? "NW" : "nw",
+    (cr0 & (1<<18)) ? "AC" : "ac",
+    (cr0 & (1<<16)) ? "WP" : "wp",
+    (cr0 & (1<<5))  ? "NE" : "ne",
+    (cr0 & (1<<4))  ? "ET" : "et",
+    (cr0 & (1<<3))  ? "TS" : "ts",
+    (cr0 & (1<<2))  ? "EM" : "em",
+    (cr0 & (1<<1))  ? "MP" : "mp",
+    (cr0 & (1<<0))  ? "PE" : "pe");
+  dbg_printf("CR2=page fault laddr=0x" FMT_ADDRX "\n", cr2);
+  dbg_printf("CR3=0x" FMT_PHY_ADDRX "\n", cr3);
+  dbg_printf("    PCD=page-level cache disable=%d\n", (cr3>>4) & 1);
+  dbg_printf("    PWT=page-level write-through=%d\n", (cr3>>3) & 1);
+#if BX_CPU_LEVEL >= 4
+  Bit32u cr4 = SIM->get_param_num("CR4", dbg_cpu_list)->get();
+  dbg_printf("CR4=0x%08x: %s %s %s %s %s %s %s %s %s %s %s %s %s %s\n", cr4,
+    (cr4 & (1<<18)) ? "OSXSAVE" : "osxsave",
+    (cr4 & (1<<14)) ? "SMX" : "smx",
+    (cr4 & (1<<13)) ? "VMX" : "vmx",
+    (cr4 & (1<<10)) ? "OSXMMEXCPT" : "osxmmexcpt",
+    (cr4 & (1<<9))  ? "OSFXSR" : "osfxsr",
+    (cr4 & (1<<8))  ? "PCE" : "pce",
+    (cr4 & (1<<7))  ? "PGE" : "pge",
+    (cr4 & (1<<6))  ? "MCE" : "mce",
+    (cr4 & (1<<5))  ? "PAE" : "pae",
+    (cr4 & (1<<4))  ? "PSE" : "pse",
+    (cr4 & (1<<3))  ? "DE" : "de",
+    (cr4 & (1<<2))  ? "TSD" : "tsd",
+    (cr4 & (1<<1))  ? "PVI" : "pvi",
+    (cr4 & (1<<0))  ? "VME" : "vme");
+#endif
+#if BX_SUPPORT_X86_64
+  Bit32u efer = SIM->get_param_num("MSR.EFER", dbg_cpu_list)->get();
+  dbg_printf("EFER=0x%08x: %s %s %s %s %s\n", efer,
+    (efer & (1<<14)) ? "FFXSR" : "ffxsr",
+    (efer & (1<<11)) ? "NXE" : "nxe",
+    (efer & (1<<10)) ? "LMA" : "lma",
+    (efer & (1<<8))  ? "LME" : "lme",
+    (efer & (1<<0))  ? "SCE" : "sce");
+#endif
+}
+
+void bx_dbg_info_segment_regs_command(void)
+{
+  static const char *segname[] = { "es", "cs", "ss", "ds", "fs", "gs" };
+
+  bx_dbg_sreg_t sreg;
+  bx_dbg_global_sreg_t global_sreg;
+
+  for(int s=0;s<6;s++) {
+    BX_CPU(dbg_cpu)->dbg_get_sreg(&sreg, s);
+    dbg_printf("%s:0x%04x, dh=0x%08x, dl=0x%08x, valid=%u\n", segname[s],
+       (unsigned) sreg.sel, (unsigned) sreg.des_h,
+       (unsigned) sreg.des_l, (unsigned) sreg.valid);
+    if (sreg.valid) {
+       dbg_printf("\t");
+       bx_dbg_print_descriptor(sreg.des_l, sreg.des_h);
+    }
+  }
+
+  BX_CPU(dbg_cpu)->dbg_get_ldtr(&sreg);
+  dbg_printf("ldtr:0x%04x, dh=0x%08x, dl=0x%08x, valid=%u\n",
+      (unsigned) sreg.sel, (unsigned) sreg.des_h,
+      (unsigned) sreg.des_l, (unsigned) sreg.valid);
+
+  BX_CPU(dbg_cpu)->dbg_get_tr(&sreg);
+  dbg_printf("tr:0x%04x, dh=0x%08x, dl=0x%08x, valid=%u\n",
+      (unsigned) sreg.sel, (unsigned) sreg.des_h,
+      (unsigned) sreg.des_l, (unsigned) sreg.valid);
+
+  BX_CPU(dbg_cpu)->dbg_get_gdtr(&global_sreg);
+  dbg_printf("gdtr:base=0x"FMT_ADDRX", limit=0x%x\n",
+      global_sreg.base, (unsigned) global_sreg.limit);
+
+  BX_CPU(dbg_cpu)->dbg_get_idtr(&global_sreg);
+  dbg_printf("idtr:base=0x"FMT_ADDRX", limit=0x%x\n",
+      global_sreg.base, (unsigned) global_sreg.limit);
+}
+
+void bx_dbg_info_registers_command(int which_regs_mask)
+{
+  bx_address reg;
+
+  if (which_regs_mask & BX_INFO_GENERAL_PURPOSE_REGS) {
+#if BX_SUPPORT_SMP
+    dbg_printf("CPU%d:\n", BX_CPU(dbg_cpu)->bx_cpuid);
+#endif
+#if BX_SUPPORT_X86_64 == 0
+    reg = BX_CPU(dbg_cpu)->get_reg32(BX_32BIT_REG_EAX);
+    dbg_printf("eax: 0x%08x %d\n", (unsigned) reg, (int) reg);
+    reg = BX_CPU(dbg_cpu)->get_reg32(BX_32BIT_REG_ECX);
+    dbg_printf("ecx: 0x%08x %d\n", (unsigned) reg, (int) reg);
+    reg = BX_CPU(dbg_cpu)->get_reg32(BX_32BIT_REG_EDX);
+    dbg_printf("edx: 0x%08x %d\n", (unsigned) reg, (int) reg);
+    reg = BX_CPU(dbg_cpu)->get_reg32(BX_32BIT_REG_EBX);
+    dbg_printf("ebx: 0x%08x %d\n", (unsigned) reg, (int) reg);
+    reg = BX_CPU(dbg_cpu)->get_reg32(BX_32BIT_REG_ESP);
+    dbg_printf("esp: 0x%08x %d\n", (unsigned) reg, (int) reg);
+    reg = BX_CPU(dbg_cpu)->get_reg32(BX_32BIT_REG_EBP);
+    dbg_printf("ebp: 0x%08x %d\n", (unsigned) reg, (int) reg);
+    reg = BX_CPU(dbg_cpu)->get_reg32(BX_32BIT_REG_ESI);
+    dbg_printf("esi: 0x%08x %d\n", (unsigned) reg, (int) reg);
+    reg = BX_CPU(dbg_cpu)->get_reg32(BX_32BIT_REG_EDI);
+    dbg_printf("edi: 0x%08x %d\n", (unsigned) reg, (int) reg);
+    reg = bx_dbg_get_eip();
+    dbg_printf("eip: 0x%08x\n", (unsigned) reg);
+#else
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_RAX);
+    dbg_printf("rax: 0x%08x:%08x ", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_RCX);
+    dbg_printf("rcx: 0x%08x:%08x\n", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_RDX);
+    dbg_printf("rdx: 0x%08x:%08x ", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_RBX);
+    dbg_printf("rbx: 0x%08x:%08x\n", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_RSP);
+    dbg_printf("rsp: 0x%08x:%08x ", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_RBP);
+    dbg_printf("rbp: 0x%08x:%08x\n", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_RSI);
+    dbg_printf("rsi: 0x%08x:%08x ", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_RDI);
+    dbg_printf("rdi: 0x%08x:%08x\n", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_R8);
+    dbg_printf("r8 : 0x%08x:%08x ", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_R9);
+    dbg_printf("r9 : 0x%08x:%08x\n", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_R10);
+    dbg_printf("r10: 0x%08x:%08x ", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_R11);
+    dbg_printf("r11: 0x%08x:%08x\n", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_R12);
+    dbg_printf("r12: 0x%08x:%08x ", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_R13);
+    dbg_printf("r13: 0x%08x:%08x\n", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_R14);
+    dbg_printf("r14: 0x%08x:%08x ", GET32H(reg), GET32L(reg));
+    reg = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_R15);
+    dbg_printf("r15: 0x%08x:%08x\n", GET32H(reg), GET32L(reg));
+    reg = bx_dbg_get_instruction_pointer();
+    dbg_printf("rip: 0x%08x:%08x\n", GET32H(reg), GET32L(reg));
+#endif
+    reg = BX_CPU(dbg_cpu)->read_eflags();
+    dbg_printf("eflags 0x%08x: ", (unsigned) reg);
+    bx_dbg_info_flags();
+  }
+
+#if BX_SUPPORT_FPU
+  if (which_regs_mask & BX_INFO_FPU_REGS) {
+    bx_dbg_print_fpu_state();
+  }
+#endif
+
+  if (which_regs_mask & BX_INFO_MMX_REGS) {
+    bx_dbg_print_mmx_state();
+  }
+
+  if (which_regs_mask & BX_INFO_SSE_REGS) {
+    bx_dbg_print_sse_state();
+  }
+}
+
+//
+// commands invoked from parser
+//
+
+void bx_dbg_quit_command(void)
+{
+  BX_INFO(("dbg: Quit"));
+  bx_dbg_exit(0);
+}
+
+void bx_dbg_trace_command(bx_bool enable)
+{
+  BX_CPU(dbg_cpu)->trace = enable;
+  dbg_printf("Tracing %s for CPU%d\n", enable ? "enabled" : "disabled",
+     BX_CPU(dbg_cpu)->which_cpu());
+}
+
+void bx_dbg_trace_reg_command(bx_bool enable)
+{
+  BX_CPU(dbg_cpu)->trace_reg = enable;
+  dbg_printf("Register-Tracing %s for CPU%d\n", enable ? "enabled" : "disabled",
+     BX_CPU(dbg_cpu)->which_cpu());
+}
+
+void bx_dbg_trace_mem_command(bx_bool enable)
+{
+  BX_CPU(dbg_cpu)->trace_mem = enable;
+  dbg_printf("Memory-Tracing %s for CPU%d\n", enable ? "enabled" : "disabled",
+     BX_CPU(dbg_cpu)->which_cpu());
+}
+
+void bx_dbg_ptime_command(void)
+{
+  dbg_printf("ptime: " FMT_LL "d\n", bx_pc_system.time_ticks());
+}
+
+int timebp_timer = -1;
+Bit64u timebp_queue[MAX_CONCURRENT_BPS];
+int timebp_queue_size = 0;
+
+void bx_dbg_timebp_command(bx_bool absolute, Bit64u time)
+{
+  Bit64u abs_time = (absolute) ? time : time + bx_pc_system.time_ticks();
+
+  if (abs_time < bx_pc_system.time_ticks()) {
+    dbg_printf("Request for time break point in the past. I can't let you do that.\n");
+    return;
+  }
+
+  if (timebp_queue_size == MAX_CONCURRENT_BPS) {
+    dbg_printf("Too many time break points\n");
+    return;
+  }
+
+  Bit64u diff = (absolute) ? time - bx_pc_system.time_ticks() : time;
+
+  if (timebp_timer >= 0) {
+    if (timebp_queue_size == 0 || abs_time < timebp_queue[0]) {
+      /* first in queue */
+      for (int i = timebp_queue_size; i >= 0; i--)
+        timebp_queue[i+1] = timebp_queue[i];
+      timebp_queue[0] = abs_time;
+      timebp_queue_size++;
+      bx_pc_system.activate_timer_ticks(timebp_timer, diff, 1);
+    } else {
+      /* not first, insert at suitable place */
+      for (int i = 1; i < timebp_queue_size; i++) {
+        if (timebp_queue[i] == abs_time) {
+          dbg_printf("Time breakpoint not inserted (duplicate)\n");
+          return;
+        } else if (abs_time < timebp_queue[i]) {
+          for (int j = timebp_queue_size; j >= i; j--)
+            timebp_queue[j+1] = timebp_queue[j];
+          timebp_queue[i] = abs_time;
+          goto inserted;
+        }
+      }
+      /* last */
+      timebp_queue[timebp_queue_size] = abs_time;
+inserted:
+      timebp_queue_size++;
+    }
+  } else {
+    timebp_queue_size = 1;
+    timebp_queue[0] = abs_time;
+    timebp_timer = bx_pc_system.register_timer_ticks(&bx_pc_system, bx_pc_system_c::timebp_handler, diff, 0, 1, "debug.timebp");
+  }
+
+  dbg_printf("Time breakpoint inserted. Delta = " FMT_LL "u\n", diff);
+}
+
+Bit32u conv_4xBit8u_to_Bit32u(const Bit8u* buf)
+{
+  Bit32u ret = 0;
+  for (int i = 0; i < 4; i++) {
+    ret |= (buf[i] << (8 * i));
+  }
+  return ret;
+}
+
+Bit16u conv_2xBit8u_to_Bit16u(const Bit8u* buf)
+{
+  Bit16u ret = 0;
+  for (int i = 0; i < 2; i++) {
+    ret |= (buf[i] << (8 * i));
+  }
+  return ret;
+}
+
+void bx_dbg_record_command(char* path_quoted)
+{
+  // skip beginning double quote
+  if (path_quoted[0] == '"')
+    path_quoted++;
+
+  // null out ending quote
+  int len = strlen(path_quoted);
+  if (path_quoted[len - 1] == '"')
+    path_quoted[len - 1] = '\0';
+
+  bx_dbg.record_io = fopen(path_quoted, "w");
+  if (bx_dbg.record_io)
+    dbg_printf("IO record file '%s' opened\n", path_quoted);
+  else
+    dbg_printf("Error opening '%s' for writing\n", path_quoted);
+}
+
+static FILE* playback_file = 0;
+
+struct playback_entry_t
+{
+  char command[100];
+  Bit32u argument;
+
+  void trigger();
+};
+
+static playback_entry_t playback_entry;
+static Bit64u last_playback_time = 0;
+static int playback_timer_index = -1;
+
+void playback_function(void* this_ptr)
+{
+  ((playback_entry_t*)this_ptr)->trigger();
+}
+
+static void enter_playback_entry()
+{
+  static const int playback_buf_size = 100;
+  char playback_buf[playback_buf_size];
+  if (!fgets(playback_buf, playback_buf_size, playback_file))
+    return;
+
+  Bit64u time;
+  if (sscanf(playback_buf, "%s " FMT_LL "d %x", playback_entry.command, &time, &playback_entry.argument) != 3) {
+    dbg_printf("Parse error in playback string '%s'\n", playback_buf);
+    return;
+  }
+
+  Bit64u diff = time - last_playback_time;
+  last_playback_time = time;
+
+  if (time < last_playback_time) {
+    BX_PANIC(("Negative diff in playback"));
+  } else if (diff == 0) {
+    playback_entry.trigger();
+  } else {
+    if (playback_timer_index >= 0)
+      bx_pc_system.activate_timer_ticks(playback_timer_index, diff, 0);
+    else
+      playback_timer_index = bx_pc_system.register_timer_ticks(&playback_entry, playback_function, diff, 0, 1, "debug.playback");
+  }
+}
+
+void playback_entry_t::trigger()
+{
+  if (!strcmp("gen_scancode", command)) {
+    DEV_kbd_gen_scancode(argument);
+  } else {
+    dbg_printf("Unknown playback command '%s'\n", command);
+    return;
+  }
+  enter_playback_entry();
+}
+
+void bx_dbg_playback_command(char* path_quoted)
+{
+  // skip beginning double quote
+  if (path_quoted[0] == '"')
+    path_quoted++;
+
+  // null out ending quote
+  int len = strlen(path_quoted);
+  if (path_quoted[len - 1] == '"')
+    path_quoted[len - 1] = '\0';
+
+  playback_file = fopen(path_quoted, "r");
+  if (playback_file) {
+    dbg_printf("Playback from '%s'\n", path_quoted);
+    last_playback_time = 0;
+    dbg_printf("playback times relative from " FMT_LL "d\n",
+        bx_pc_system.time_ticks());
+    enter_playback_entry();
+  } else {
+    dbg_printf("Error opening '%s' for reading\n", path_quoted);
+  }
+}
+
+// toggles mode switch breakpoint
+void bx_dbg_modebp_command()
+{
+  BX_CPU(dbg_cpu)->mode_break = !BX_CPU(dbg_cpu)->mode_break;
+  dbg_printf("mode switch break %s\n",
+    BX_CPU(dbg_cpu)->mode_break ? "enabled" : "disabled");
+}
+
+bx_bool bx_dbg_read_linear(unsigned which_cpu, bx_address laddr, unsigned len, Bit8u *buf)
+{
+  unsigned remainsInPage;
+  bx_phy_address paddr;
+  unsigned read_len;
+  bx_bool paddr_valid;
+
+next_page:
+  remainsInPage = 0x1000 - PAGE_OFFSET(laddr);
+  read_len = (remainsInPage < len) ? remainsInPage : len;
+
+  paddr_valid = BX_CPU(which_cpu)->dbg_xlate_linear2phy(laddr, &paddr);
+  if (paddr_valid) {
+    if (! BX_MEM(0)->dbg_fetch_mem(BX_CPU(which_cpu), paddr, read_len, buf)) {
+      dbg_printf("bx_dbg_read_linear: physical memory read error (phy=0x" FMT_PHY_ADDRX ", lin=0x" FMT_ADDRX ")\n", paddr, laddr);
+      return 0;
+    }
+  }
+  else {
+    dbg_printf("bx_dbg_read_linear: physical address not available for linear 0x" FMT_ADDRX "\n", laddr);
+    return 0;
+  }
+
+  /* check for access across multiple pages */
+  if (remainsInPage < len)
+  {
+    laddr += read_len;
+    len -= read_len;
+    buf += read_len;
+    goto next_page;
+  }
+
+  return 1;
+}
+
+// where
+// stack trace: ebp -> old ebp
+// return eip at ebp + 4
+void bx_dbg_where_command()
+{
+  if (!BX_CPU(dbg_cpu)->protected_mode()) {
+    dbg_printf("'where' only supported in protected mode\n");
+    return;
+  }
+  if (BX_CPU(dbg_cpu)->get_segment_base(BX_SEG_REG_SS) != 0) {
+    dbg_printf("non-zero stack base\n");
+    return;
+  }
+  Bit32u bp = BX_CPU(dbg_cpu)->get_reg32(BX_32BIT_REG_EBP);
+  bx_address ip = BX_CPU(dbg_cpu)->get_instruction_pointer();
+  dbg_printf("(%d) 0x%08x\n", dbg_cpu, ip);
+  for (int i = 1; i < 50; i++) {
+    // Up
+    bx_phy_address paddr;
+    Bit8u buf[4];
+
+    // bp = [bp];
+    bx_bool paddr_valid = BX_CPU(dbg_cpu)->dbg_xlate_linear2phy(bp, &paddr);
+    if (paddr_valid) {
+      if (BX_MEM(0)->dbg_fetch_mem(BX_CPU(dbg_cpu), paddr, 4, buf)) {
+        bp = conv_4xBit8u_to_Bit32u(buf);
+      } else {
+        dbg_printf("(%d) Physical memory read error (BP)\n", i);
+        break;
+      }
+    } else {
+      dbg_printf("(%d) Could not translate linear address (BP)\n", i);
+      break;
+    }
+
+    // ip = [bp + 4];
+    paddr_valid = BX_CPU(dbg_cpu)->dbg_xlate_linear2phy(bp + 4, &paddr);
+    if (paddr_valid) {
+      if (BX_MEM(0)->dbg_fetch_mem(BX_CPU(dbg_cpu), paddr, 4, buf)) {
+        ip = conv_4xBit8u_to_Bit32u(buf);
+      } else {
+        dbg_printf("(%d) Physical memory read error (IP)\n", i);
+        break;
+      }
+    } else {
+      dbg_printf("(%d) Could not translate linear address (IP)\n", i);
+      break;
+    }
+
+    // Print
+    dbg_printf("(%d) 0x%08x\n", i, ip);
+  }
+}
+
+void bx_dbg_print_string_command(bx_address start_addr)
+{
+  dbg_printf("0x%08x: ", start_addr);
+  for (int i = 0; ; i++) {
+    Bit8u buf = 0;
+    if (! bx_dbg_read_linear(dbg_cpu, start_addr+i, 1, &buf)) break;
+    if (buf == 0) break;
+    if (isgraph(buf) || buf == 0x20)
+      dbg_printf("%c", buf);
+    else
+      dbg_printf("\\%d", buf);
+  }
+  dbg_printf("\n");
+}
+
+static void dbg_print_guard_found(unsigned cpu_mode, Bit32u cs, bx_address eip, bx_address laddr)
+{
+#if BX_SUPPORT_X86_64
+  if (cpu_mode == BX_MODE_LONG_64) {
+    dbg_printf("0x%04x:" FMT_ADDRX " (0x" FMT_ADDRX ")", cs, eip, laddr);
+    return;
+  }
+#endif
+
+  if (cpu_mode >= BX_MODE_IA32_PROTECTED)
+    dbg_printf("%04x:%08x (0x%08x)", cs, (unsigned) eip, (unsigned) laddr);
+  else // real or v8086 mode
+    dbg_printf("%04x:%04x (0x%08x)", cs, (unsigned) eip, (unsigned) laddr);
+}
+
+void bx_dbg_xlate_address(bx_lin_address laddr)
+{
+  bx_phy_address paddr;
+  laddr &= BX_CONST64(0xfffffffffffff000);
+
+  bx_bool paddr_valid = BX_CPU(dbg_cpu)->dbg_xlate_linear2phy(laddr, &paddr);
+  if (paddr_valid) {
+    dbg_printf("linear page 0x" FMT_ADDRX " maps to physical page 0x" FMT_PHY_ADDRX "\n", laddr, paddr);
+  }
+  else {
+    dbg_printf("physical address not available for linear 0x" FMT_ADDRX "\n", laddr);
+  }
+}
+
+unsigned dbg_show_mask = 0;
+
+#define BX_DBG_SHOW_CALLRET  (Flag_call|Flag_ret)
+#define BX_DBG_SHOW_SOFTINT  (Flag_softint)
+#define BX_DBG_SHOW_EXTINT   (Flag_intsig)
+#define BX_DBG_SHOW_IRET     (Flag_iret)
+#define BX_DBG_SHOW_INT      (Flag_softint|Flag_iret|Flag_intsig)
+#define BX_DBG_SHOW_MODE     (Flag_mode)
+
+void bx_dbg_show_command(const char* arg)
+{
+  if(arg) {
+    if (!strcmp(arg, "mode")) {
+      if (dbg_show_mask & BX_DBG_SHOW_MODE) {
+        dbg_show_mask &= ~BX_DBG_SHOW_MODE;
+        dbg_printf("show mode switch: OFF\n");
+      } else {
+        dbg_show_mask |= BX_DBG_SHOW_MODE;
+        dbg_printf("show mode switch: ON\n");
+      }
+    } else if (!strcmp(arg, "int")) {
+      if (dbg_show_mask & BX_DBG_SHOW_INT) {
+        dbg_show_mask &= ~BX_DBG_SHOW_INT;
+        dbg_printf("show interrupts tracing (extint/softint/iret): OFF\n");
+      } else {
+        dbg_show_mask |= BX_DBG_SHOW_INT;
+        dbg_printf("show interrupts tracing (extint/softint/iret): ON\n");
+      }
+    } else if (!strcmp(arg, "extint")) {
+      if (dbg_show_mask & BX_DBG_SHOW_EXTINT) {
+        dbg_show_mask &= ~BX_DBG_SHOW_EXTINT;
+        dbg_printf("show external interrupts: OFF\n");
+      } else {
+        dbg_show_mask |= BX_DBG_SHOW_EXTINT;
+        dbg_printf("show external interrupts: ON\n");
+      }
+    } else if (!strcmp(arg, "softint")) {
+      if (dbg_show_mask & BX_DBG_SHOW_SOFTINT) {
+        dbg_show_mask &= ~BX_DBG_SHOW_SOFTINT;
+        dbg_printf("show software interrupts: OFF\n");
+      } else {
+        dbg_show_mask |= BX_DBG_SHOW_SOFTINT;
+        dbg_printf("show software interrupts: ON\n");
+      }
+    } else if (!strcmp(arg, "iret")) {
+      if (dbg_show_mask & BX_DBG_SHOW_IRET) {
+        dbg_show_mask &= ~BX_DBG_SHOW_IRET;
+        dbg_printf("show iret: OFF\n");
+      } else {
+        dbg_show_mask |= BX_DBG_SHOW_IRET;
+        dbg_printf("show iret: ON\n");
+      }
+    } else if(!strcmp(arg,"call")) {
+      if (dbg_show_mask & BX_DBG_SHOW_CALLRET) {
+        dbg_show_mask &= ~BX_DBG_SHOW_CALLRET;
+        dbg_printf("show calls/returns: OFF\n");
+      } else {
+        dbg_show_mask |= BX_DBG_SHOW_CALLRET;
+        dbg_printf("show calls/returns: ON\n");
+      }
+    } else if(!strcmp(arg,"off")) {
+      dbg_show_mask = 0x0;
+      dbg_printf("Disable all show flags\n");
+    } else if(!strcmp(arg,"dbg-all")) {
+      bx_dbg.interrupts = 1;
+      bx_dbg.exceptions = 1;
+      bx_dbg.debugger = 1;
+      /* bx_dbg.record_io = 1; this is a pointer .. somewhere */
+      dbg_printf("Turned ON all bx_dbg flags\n");
+      return;
+    } else if(!strcmp(arg,"dbg-none")) {
+      bx_dbg.interrupts = 0;
+      bx_dbg.exceptions = 0;
+      bx_dbg.debugger = 0;
+      /* bx_dbg.record_io = 0; this is a pointer .. somewhere */
+      dbg_printf("Turned OFF all bx_dbg flags\n");
+      return;
+    } else if(!strcmp(arg,"vga")){
+      DEV_vga_refresh();
+      return;
+    } else {
+      dbg_printf("Unrecognized arg: %s (only 'mode', 'int', 'softint', 'extint', 'iret', 'call', 'off', 'dbg-all' and 'dbg-none' are valid)\n", arg);
+      return;
+    }
+  }
+
+  if (dbg_show_mask) {
+    dbg_printf("show mask is:");
+    if (dbg_show_mask & BX_DBG_SHOW_CALLRET)
+      dbg_printf(" call");
+    if (dbg_show_mask & BX_DBG_SHOW_SOFTINT)
+      dbg_printf(" softint");
+    if (dbg_show_mask & BX_DBG_SHOW_EXTINT)
+      dbg_printf(" extint");
+    if (dbg_show_mask & BX_DBG_SHOW_IRET)
+      dbg_printf(" iret");
+    if (dbg_show_mask & BX_DBG_SHOW_MODE)
+      dbg_printf(" mode");
+    dbg_printf("\n");
+  }
+  else {
+    dbg_printf("show mask is: 0\n");
+  }
+}
+
+void bx_dbg_show_param_command(const char *param)
+{
+  dbg_printf("show param name: <%s>\n", param);
+  bx_param_c *node = SIM->get_param(param, SIM->get_bochs_root());
+  if (node) {
+    print_tree(node, 0);
+  }
+  else {
+    node = SIM->get_param(param, dbg_cpu_list);
+    if (node)
+      print_tree(node, 0);
+    else
+      dbg_printf("can't find param <%s> in global or default CPU tree\n", param);
+  }
+}
+
+// return non zero to cause a stop
+int bx_dbg_show_symbolic(void)
+{
+  static unsigned last_cpu_mode = 0;
+  static bx_address last_cr3 = 0;
+
+  /* modes & address spaces */
+  if (dbg_show_mask & BX_DBG_SHOW_MODE) {
+    if(BX_CPU(dbg_cpu)->get_cpu_mode() != last_cpu_mode) {
+      dbg_printf (FMT_TICK ": switched from '%s' to '%s'\n",
+        bx_pc_system.time_ticks(),
+        cpu_mode_string(last_cpu_mode),
+        cpu_mode_string(BX_CPU(dbg_cpu)->get_cpu_mode()));
+    }
+
+    if(last_cr3 != BX_CPU(dbg_cpu)->cr3)
+      dbg_printf(FMT_TICK ": address space switched. CR3: 0x" FMT_PHY_ADDRX "\n",
+        bx_pc_system.time_ticks(), BX_CPU(dbg_cpu)->cr3);
+  }
+
+  /* interrupts */
+  if (dbg_show_mask & BX_DBG_SHOW_SOFTINT) {
+    if(BX_CPU(dbg_cpu)->show_flag & Flag_softint) {
+      dbg_printf(FMT_TICK ": softint ", bx_pc_system.time_ticks());
+      dbg_print_guard_found(BX_CPU(dbg_cpu)->get_cpu_mode(),
+        BX_CPU(dbg_cpu)->guard_found.cs, BX_CPU(dbg_cpu)->guard_found.eip,
+        BX_CPU(dbg_cpu)->guard_found.laddr);
+      dbg_printf("\n");
+    }
+  }
+
+  if (dbg_show_mask & BX_DBG_SHOW_EXTINT) {
+    if((BX_CPU(dbg_cpu)->show_flag & Flag_intsig) && !(BX_CPU(dbg_cpu)->show_flag & Flag_softint)) {
+      dbg_printf(FMT_TICK ": exception (not softint) ", bx_pc_system.time_ticks());
+      dbg_print_guard_found(BX_CPU(dbg_cpu)->get_cpu_mode(),
+        BX_CPU(dbg_cpu)->guard_found.cs, BX_CPU(dbg_cpu)->guard_found.eip,
+        BX_CPU(dbg_cpu)->guard_found.laddr);
+      dbg_printf("\n");
+    }
+  }
+
+  if (dbg_show_mask & BX_DBG_SHOW_IRET) {
+    if(BX_CPU(dbg_cpu)->show_flag & Flag_iret) {
+      dbg_printf(FMT_TICK ": iret ", bx_pc_system.time_ticks());
+      dbg_print_guard_found(BX_CPU(dbg_cpu)->get_cpu_mode(),
+        BX_CPU(dbg_cpu)->guard_found.cs, BX_CPU(dbg_cpu)->guard_found.eip,
+        BX_CPU(dbg_cpu)->guard_found.laddr);
+      dbg_printf("\n");
+    }
+  }
+
+  /* calls */
+  if (dbg_show_mask & BX_DBG_SHOW_CALLRET)
+  {
+    if(BX_CPU(dbg_cpu)->show_flag & Flag_call) {
+      bx_phy_address phy = 0;
+      bx_bool valid = BX_CPU(dbg_cpu)->dbg_xlate_linear2phy(BX_CPU(dbg_cpu)->guard_found.laddr, &phy);
+      dbg_printf(FMT_TICK ": call ", bx_pc_system.time_ticks());
+      dbg_print_guard_found(BX_CPU(dbg_cpu)->get_cpu_mode(),
+        BX_CPU(dbg_cpu)->guard_found.cs, BX_CPU(dbg_cpu)->guard_found.eip,
+        BX_CPU(dbg_cpu)->guard_found.laddr);
+      if (!valid) dbg_printf(" phys not valid");
+      else {
+        dbg_printf(" (phy: 0x" FMT_PHY_ADDRX ") %s", phy,
+          bx_dbg_symbolic_address(BX_CPU(dbg_cpu)->cr3 >> 12,
+              BX_CPU(dbg_cpu)->guard_found.eip,
+              BX_CPU(dbg_cpu)->guard_found.laddr - BX_CPU(dbg_cpu)->guard_found.eip));
+      }
+      dbg_printf("\n");
+    }
+  }
+
+  last_cr3 = BX_CPU(dbg_cpu)->cr3;
+  last_cpu_mode = BX_CPU(dbg_cpu)->get_cpu_mode();
+  BX_CPU(dbg_cpu)->show_flag = 0;
+
+  return 0;
+}
+
+void bx_dbg_print_stack_command(unsigned nwords)
+{
+  bx_address linear_sp;
+  unsigned len;
+
+#if BX_SUPPORT_X86_64
+  if (BX_CPU(dbg_cpu)->get_cpu_mode() == BX_MODE_LONG_64) {
+    linear_sp = BX_CPU(dbg_cpu)->get_reg64(BX_64BIT_REG_RSP);
+    len = 8;
+  }
+  else
+#endif
+  {
+    if (BX_CPU(dbg_cpu)->sregs[BX_SEG_REG_SS].cache.u.segment.d_b) {
+      linear_sp = BX_CPU(dbg_cpu)->get_reg32(BX_32BIT_REG_ESP);
+      len = 4;
+    }
+    else {
+      linear_sp = BX_CPU(dbg_cpu)->get_reg16(BX_16BIT_REG_SP);
+      len = 2;
+    }
+
+    linear_sp = BX_CPU(dbg_cpu)->get_laddr(BX_SEG_REG_SS, linear_sp);
+  }
+
+  Bit8u buf[8];
+
+  dbg_printf("Stack address size %d\n", len);
+
+  for (unsigned i = 0; i < nwords; i++) {
+    if (! bx_dbg_read_linear(dbg_cpu, linear_sp, len, buf)) break;
+#if BX_SUPPORT_X86_64
+    if (len == 8) {
+      dbg_printf(" | STACK 0x%08x%08x [0x%08x:0x%08x]\n",
+        GET32H(linear_sp), GET32L(linear_sp),
+        (unsigned) conv_4xBit8u_to_Bit32u(buf+4),
+        (unsigned) conv_4xBit8u_to_Bit32u(buf));
+    }
+    else
+#endif
+    {
+      if (len == 4) {
+        dbg_printf(" | STACK 0x%08x [0x%08x]\n",
+          (unsigned) linear_sp, (unsigned) conv_4xBit8u_to_Bit32u(buf));
+      }
+      else {
+        dbg_printf(" | STACK 0x%04x [0x%04x]\n",
+          (unsigned) linear_sp, (unsigned) conv_2xBit8u_to_Bit16u(buf));
+      }
+    }
+
+    linear_sp += len;
+  }
+}
+
+void bx_dbg_print_watchpoints(void)
+{ unsigned i;
+  Bit8u buf[2];
+
+  // print watch point info
+  for (i = 0; i < num_read_watchpoints; i++) {
+    if (BX_MEM(0)->dbg_fetch_mem(BX_CPU(dbg_cpu), read_watchpoint[i].addr, 2, buf))
+      dbg_printf("rd 0x"FMT_PHY_ADDRX" len=%d\t\t(%04x)\n",
+          read_watchpoint[i].addr, read_watchpoint[i].len, (int)buf[0] | ((int)buf[1] << 8));
+    else
+      dbg_printf("rd 0x"FMT_PHY_ADDRX" len=%d\t\t(read error)\n",
+          read_watchpoint[i].addr, read_watchpoint[i].len);
+  }
+  for (i = 0; i < num_write_watchpoints; i++) {
+    if (BX_MEM(0)->dbg_fetch_mem(BX_CPU(dbg_cpu), write_watchpoint[i].addr, 2, buf))
+      dbg_printf("wr 0x"FMT_PHY_ADDRX" len=%d\t\t(%04x)\n",
+          write_watchpoint[i].addr, write_watchpoint[i].len, (int)buf[0] | ((int)buf[1] << 8));
+    else
+      dbg_printf("rd 0x"FMT_PHY_ADDRX" len=%d\t\t(read error)\n",
+          write_watchpoint[i].addr, write_watchpoint[i].len);
+  }
+}
+
+void bx_dbg_watch(int type, bx_phy_address address, Bit32u len)
+{
+  if (type == BX_READ) {
+    if (num_read_watchpoints == BX_DBG_MAX_WATCHPONTS) {
+      dbg_printf("Too many read watchpoints (%d)\n", BX_DBG_MAX_WATCHPONTS);
+      return;
+    }
+    read_watchpoint[num_read_watchpoints].addr = address;
+    read_watchpoint[num_read_watchpoints].len = len;
+    num_read_watchpoints++;
+    dbg_printf("read watchpoint at 0x" FMT_PHY_ADDRX " len=%d inserted\n", address, len);
+  }
+  else if (type == BX_WRITE) {
+    if (num_write_watchpoints == BX_DBG_MAX_WATCHPONTS) {
+      dbg_printf("Too many write watchpoints (%d)\n", BX_DBG_MAX_WATCHPONTS);
+      return;
+    }
+    write_watchpoint[num_write_watchpoints].addr = address;
+    write_watchpoint[num_write_watchpoints].len = len;
+    num_write_watchpoints++;
+    dbg_printf("write watchpoint at 0x" FMT_PHY_ADDRX " len=%d inserted\n", address, len);
+  }
+  else {
+    dbg_printf("bx_dbg_watch: broken watchpoint type");
+  }
+}
+
+void bx_dbg_unwatch_all()
+{
+  num_read_watchpoints = num_write_watchpoints = 0;
+  dbg_printf("All watchpoints removed\n");
+}
+
+void bx_dbg_unwatch(bx_phy_address address)
+{ unsigned i;
+  for (i=0; i<num_read_watchpoints; i++) {
+    if (read_watchpoint[i].addr == address) {
+      dbg_printf("read watchpoint at 0x" FMT_PHY_ADDRX " removed\n", address);
+      // found watchpoint, delete it by shifting remaining entries left
+      for (unsigned j=i; j<(num_read_watchpoints-1); j++) {
+        read_watchpoint[j] = read_watchpoint[j+1];
+      }
+      num_read_watchpoints--;
+      break;
+    }
+  }
+
+  for (i=0; i<num_write_watchpoints; i++) {
+    if (write_watchpoint[i].addr == address) {
+      dbg_printf("write watchpoint at 0x" FMT_PHY_ADDRX " removed\n", address);
+      // found watchpoint, delete it by shifting remaining entries left
+      for (unsigned j=i; j<(num_write_watchpoints-1); j++) {
+        write_watchpoint[j] = write_watchpoint[j+1];
+      }
+      num_write_watchpoints--;
+      break;
+    }
+  }
+}
+
+void bx_dbg_continue_command(void)
+{
+  int cpu;
+
+  // continue executing, until a guard found
+
+one_more:
+
+  // I must guard for ICOUNT or one CPU could run forever without giving
+  // the others a chance.
+  for (cpu=0; cpu < BX_SMP_PROCESSORS; cpu++) {
+    BX_CPU(cpu)->guard_found.guard_found = 0;
+    BX_CPU(cpu)->guard_found.icount = 0;
+    BX_CPU(cpu)->guard_found.time_tick = bx_pc_system.time_ticks();
+  }
+
+  // update gui (disable continue command, enable stop command, etc.)
+  sim_running->set(1);
+  SIM->refresh_ci();
+
+  // use simulation mode while executing instructions.  When the prompt
+  // is printed, we will return to config mode.
+  SIM->set_display_mode(DISP_MODE_SIM);
+
+  bx_guard.interrupt_requested = 0;
+  int stop = 0;
+  int which = -1;
+  while (!stop && !bx_guard.interrupt_requested) {
+    // the quantum is an arbitrary number of cycles to run in each
+    // processor.  In SMP mode, when this limit is reached, the
+    // cpu_loop exits so that another processor can be simulated
+    // for a few cycles.  With a single processor, the quantum
+    // setting should have no effect, although a low setting does
+    // lead to poor performance because cpu_loop is returning and
+    // getting called again, over and over.
+
+#define BX_DBG_DEFAULT_ICOUNT_QUANTUM 5
+
+    Bit32u quantum = (BX_SMP_PROCESSORS>1) ? BX_DBG_DEFAULT_ICOUNT_QUANTUM : 0;
+    Bit32u max_executed = 0;
+    for (cpu=0; cpu < BX_SMP_PROCESSORS; cpu++) {
+      Bit64u cpu_icount = BX_CPU(cpu)->guard_found.icount;
+      BX_CPU(cpu)->cpu_loop(quantum);
+      Bit32u executed = BX_CPU(cpu)->guard_found.icount - cpu_icount;
+      if (executed > max_executed) max_executed = executed;
+      // set stop flag if a guard found other than icount or halted
+      unsigned found = BX_CPU(cpu)->guard_found.guard_found;
+      stop_reason_t reason = (stop_reason_t) BX_CPU(cpu)->stop_reason;
+      if (found || (reason != STOP_NO_REASON && reason != STOP_CPU_HALTED)) {
+        stop = 1;
+        which = cpu;
+      }
+      // even if stop==1, finish cycling through all processors.
+      // "which" remembers which cpu set the stop flag.  If multiple
+      // cpus set stop, too bad.
+    }
+
+#if BX_SUPPORT_SMP
+    // increment time tick only after all processors have had their chance.
+    if (BX_SMP_PROCESSORS > 1) {
+      // potential deadlock if all processors are halted.  Then
+      // max_executed will be 0, tick will be incremented by zero, and
+      // there will never be a timed event to wake them up.  To avoid this,
+      // always tick by a minimum of 1.
+      if (max_executed < 1) max_executed=1;
+
+      BX_TICKN(max_executed);
+    }
+#endif
+  }
+
+  sim_running->set(0);
+  SIM->refresh_ci();
+
+  // (mch) hack
+  DEV_vga_refresh();
+
+  BX_INSTR_DEBUG_PROMPT();
+  bx_dbg_print_guard_results();
+
+  if (watchpoint_continue && (BX_CPU(which)->stop_reason == STOP_READ_WATCH_POINT ||
+            BX_CPU(which)->stop_reason == STOP_WRITE_WATCH_POINT))
+  goto one_more;
+}
+
+void bx_dbg_stepN_command(int cpu, Bit32u count)
+{
+  if (cpu != -1 && cpu >= BX_SMP_PROCESSORS) {
+    dbg_printf("Error: stepN: unknown cpu=%d\n", cpu);
+    return;
+  }
+
+  if (count == 0) {
+    dbg_printf("Error: stepN: count=0\n");
+    return;
+  }
+
+  // use simulation mode while executing instructions.  When the prompt
+  // is printed, we will return to config mode.
+  SIM->set_display_mode(DISP_MODE_SIM);
+
+  // reset guard counters for all CPUs
+  for (unsigned n=0; n < BX_SMP_PROCESSORS; n++) {
+    BX_CPU(n)->guard_found.icount = 0;
+    BX_CPU(n)->guard_found.time_tick = bx_pc_system.time_ticks();
+  }
+
+  if (cpu >= 0 || BX_SUPPORT_SMP==0) {
+    bx_guard.interrupt_requested = 0;
+    BX_CPU(cpu)->guard_found.guard_found = 0;
+    BX_CPU(cpu)->cpu_loop(count);
+  }
+#if BX_SUPPORT_SMP
+  else {
+    int stop = 0;
+    // for now, step each CPU one instruction at a time
+    for (unsigned cycle=0; !stop && cycle < count; cycle++) {
+      for (unsigned ncpu=0; ncpu < BX_SMP_PROCESSORS; ncpu++) {
+        bx_guard.interrupt_requested = 0;
+        BX_CPU(ncpu)->guard_found.guard_found = 0;
+        BX_CPU(ncpu)->cpu_loop(1);
+        // set stop flag if a guard found other than icount or halted
+        unsigned found = BX_CPU(ncpu)->guard_found.guard_found;
+        stop_reason_t reason = (stop_reason_t) BX_CPU(ncpu)->stop_reason;
+        if (found || (reason != STOP_NO_REASON && reason != STOP_CPU_HALTED))
+          stop = 1;
+      }
+
+      // when (BX_SMP_PROCESSORS == 1) ticks are handled inside the cpu loop
+      if (BX_SMP_PROCESSORS > 1) BX_TICK1();
+    }
+  }
+#endif
+
+  BX_INSTR_DEBUG_PROMPT();
+  bx_dbg_print_guard_results();
+}
+
+void bx_dbg_disassemble_current(int which_cpu, int print_time)
+{
+  bx_phy_address phy;
+
+  if (which_cpu < 0) {
+    // iterate over all of them.
+    for (int i=0; i<BX_SMP_PROCESSORS; i++)
+      bx_dbg_disassemble_current(i, print_time);
+    return;
+  }
+
+  bx_bool phy_valid = BX_CPU(which_cpu)->dbg_xlate_linear2phy(BX_CPU(which_cpu)->guard_found.laddr, &phy);
+  if (! phy_valid) {
+    dbg_printf("(%u).[" FMT_LL "d] ??? (physical address not available)\n", which_cpu, bx_pc_system.time_ticks());
+    return;
+  }
+
+  if (bx_dbg_read_linear(which_cpu, BX_CPU(which_cpu)->guard_found.laddr, 16, bx_disasm_ibuf))
+  {
+    unsigned ilen = bx_disassemble.disasm(IS_CODE_32(BX_CPU(which_cpu)->guard_found.code_32_64),
+      IS_CODE_64(BX_CPU(which_cpu)->guard_found.code_32_64),
+      BX_CPU(which_cpu)->get_segment_base(BX_SEG_REG_CS),
+      BX_CPU(which_cpu)->guard_found.eip, bx_disasm_ibuf, bx_disasm_tbuf);
+
+    // Note: it would be nice to display only the modified registers here, the easy
+    // way out I have thought of would be to keep a prev_eax, prev_ebx, etc copies
+    // in each cpu description (see cpu/cpu.h) and update/compare those "prev" values
+    // from here. (eks)
+    if(BX_CPU(which_cpu)->trace_reg)
+      bx_dbg_info_registers_command(BX_INFO_GENERAL_PURPOSE_REGS);
+
+    if (print_time)
+      dbg_printf("(%u).[" FMT_LL "d] ", which_cpu, bx_pc_system.time_ticks());
+    else
+      dbg_printf("(%u) ", which_cpu);
+
+    if (BX_CPU(which_cpu)->protected_mode()) {
+      dbg_printf("[0x"FMT_PHY_ADDRX"] %04x:" FMT_ADDRX " (%s): ",
+        phy, BX_CPU(which_cpu)->guard_found.cs,
+        BX_CPU(which_cpu)->guard_found.eip,
+        bx_dbg_symbolic_address(BX_CPU(which_cpu)->cr3 >> 12,
+           BX_CPU(which_cpu)->guard_found.eip,
+           BX_CPU(which_cpu)->get_segment_base(BX_SEG_REG_CS)));
+    }
+    else { // Real & V86 mode
+      dbg_printf("[0x"FMT_PHY_ADDRX"] %04x:%04x (%s): ",
+        phy, BX_CPU(which_cpu)->guard_found.cs,
+        (unsigned) BX_CPU(which_cpu)->guard_found.eip,
+        bx_dbg_symbolic_address_16bit(BX_CPU(which_cpu)->guard_found.eip,
+          BX_CPU(which_cpu)->sregs[BX_SEG_REG_CS].selector.value));
+    }
+    dbg_printf("%-25s ; ", bx_disasm_tbuf);
+    for (unsigned j=0; j<ilen; j++) {
+      dbg_printf("%02x", (unsigned) bx_disasm_ibuf[j]);
+    }
+    dbg_printf("\n");
+  }
+}
+
+void bx_dbg_print_guard_results(void)
+{
+  unsigned cpu, i;
+
+  for (cpu=0; cpu<BX_SMP_PROCESSORS; cpu++) {
+    unsigned found = BX_CPU(cpu)->guard_found.guard_found;
+    if (! found) { /* ... */ }
+#if (BX_DBG_MAX_VIR_BPOINTS > 0)
+    else if (found & BX_DBG_GUARD_IADDR_VIR) {
+      i = BX_CPU(cpu)->guard_found.iaddr_index;
+      dbg_printf("(%u) Breakpoint %u, in ");
+      dbg_print_guard_found(BX_CPU(dbg_cpu)->get_cpu_mode(),
+            BX_CPU(cpu)->guard_found.cs, BX_CPU(cpu)->guard_found.eip,
+            BX_CPU(cpu)->guard_found.laddr);
+      dbg_printf("\n");
+    }
+#endif
+#if (BX_DBG_MAX_LIN_BPOINTS > 0)
+    else if (found & BX_DBG_GUARD_IADDR_LIN) {
+      i = BX_CPU(cpu)->guard_found.iaddr_index;
+      if (bx_guard.iaddr.lin[i].bpoint_id != 0)
+        dbg_printf("(%u) Breakpoint %u, 0x" FMT_ADDRX " in ?? ()\n",
+            cpu,
+            bx_guard.iaddr.lin[i].bpoint_id,
+            BX_CPU(cpu)->guard_found.laddr);
+    }
+#endif
+#if (BX_DBG_MAX_PHY_BPOINTS > 0)
+    else if (found & BX_DBG_GUARD_IADDR_PHY) {
+      i = BX_CPU(cpu)->guard_found.iaddr_index;
+      dbg_printf("(%u) Breakpoint %u, 0x" FMT_ADDRX " in ?? ()\n",
+            cpu,
+            bx_guard.iaddr.phy[i].bpoint_id,
+            BX_CPU(cpu)->guard_found.laddr);
+    }
+#endif
+    switch(BX_CPU(cpu)->stop_reason) {
+    case STOP_NO_REASON:
+    case STOP_CPU_HALTED:
+        break;
+    case STOP_TIME_BREAK_POINT:
+        dbg_printf("(%u) Caught time breakpoint\n", cpu);
+        break;
+    case STOP_READ_WATCH_POINT:
+        dbg_printf("(%u) Caught read watch point at 0x" FMT_PHY_ADDRX "\n", cpu, BX_CPU(cpu)->watchpoint);
+        break;
+    case STOP_WRITE_WATCH_POINT:
+        dbg_printf("(%u) Caught write watch point at 0x" FMT_PHY_ADDRX "\n", cpu, BX_CPU(cpu)->watchpoint);
+        break;
+    case STOP_MAGIC_BREAK_POINT:
+        dbg_printf("(%u) Magic breakpoint\n", cpu);
+        break;
+    case STOP_MODE_BREAK_POINT:
+        dbg_printf("(%u) Caught mode switch breakpoint switching to '%s'\n",
+          cpu, cpu_mode_string(BX_CPU(cpu)->get_cpu_mode()));
+        break;
+    default:
+        dbg_printf("Error: (%u) print_guard_results: guard_found ? (stop reason %u)\n",
+          cpu, BX_CPU(cpu)->stop_reason);
+    }
+
+    if (bx_debugger.auto_disassemble) {
+      if (cpu==0) {
+        // print this only once
+        dbg_printf("Next at t=" FMT_LL "d\n", bx_pc_system.time_ticks());
+      }
+      bx_dbg_disassemble_current(cpu, 0);  // one cpu, don't print time
+    }
+  }
+#if 0
+  // print the TSC value for every CPU
+  for (cpu=0; cpu<BX_SMP_PROCESSORS; cpu++) {
+    dbg_printf("TSC[%d] = " FMT_LL "d\n", cpu, BX_CPU(cpu)->tsc);
+  }
+#endif
+}
+
+void bx_dbg_breakpoint_changed(void)
+{
+#if (BX_DBG_MAX_VIR_BPOINTS > 0)
+  if (bx_guard.iaddr.num_virtual)
+    bx_guard.guard_for |= BX_DBG_GUARD_IADDR_VIR;
+  else
+    bx_guard.guard_for &= ~BX_DBG_GUARD_IADDR_VIR;
+#endif
+
+#if (BX_DBG_MAX_LIN_BPOINTS > 0)
+  if (bx_guard.iaddr.num_linear)
+    bx_guard.guard_for |= BX_DBG_GUARD_IADDR_LIN;
+  else
+    bx_guard.guard_for &= ~BX_DBG_GUARD_IADDR_LIN;
+#endif
+
+#if (BX_DBG_MAX_PHY_BPOINTS > 0)
+  if (bx_guard.iaddr.num_physical)
+    bx_guard.guard_for |= BX_DBG_GUARD_IADDR_PHY;
+  else
+    bx_guard.guard_for &= ~BX_DBG_GUARD_IADDR_PHY;
+#endif
+}
+
+void bx_dbg_en_dis_breakpoint_command(unsigned handle, bx_bool enable)
+{
+#if (BX_DBG_MAX_VIR_BPOINTS > 0)
+  if (bx_dbg_en_dis_vbreak(handle, enable))
+    goto done;
+#endif
+
+#if (BX_DBG_MAX_LIN_BPOINTS > 0)
+  if (bx_dbg_en_dis_lbreak(handle, enable))
+    goto done;
+#endif
+
+#if (BX_DBG_MAX_PHY_BPOINTS > 0)
+  if (bx_dbg_en_dis_pbreak(handle, enable))
+    goto done;
+#endif
+
+  dbg_printf("Error: breakpoint %u not found.\n", handle);
+  return;
+
+done:
+  bx_dbg_breakpoint_changed();
+}
+
+bx_bool bx_dbg_en_dis_pbreak(unsigned handle, bx_bool enable)
+{
+#if (BX_DBG_MAX_PHY_BPOINTS > 0)
+  // see if breakpoint is a physical breakpoint
+  for (unsigned i=0; i<bx_guard.iaddr.num_physical; i++) {
+    if (bx_guard.iaddr.phy[i].bpoint_id == handle) {
+      bx_guard.iaddr.phy[i].enabled=enable;
+      return 1;
+    }
+  }
+#endif
+  return 0;
+}
+
+bx_bool bx_dbg_en_dis_lbreak(unsigned handle, bx_bool enable)
+{
+#if (BX_DBG_MAX_LIN_BPOINTS > 0)
+  // see if breakpoint is a linear breakpoint
+  for (unsigned i=0; i<bx_guard.iaddr.num_linear; i++) {
+    if (bx_guard.iaddr.lin[i].bpoint_id == handle) {
+      bx_guard.iaddr.lin[i].enabled=enable;
+      return 1;
+    }
+  }
+#endif
+  return 0;
+}
+
+bx_bool bx_dbg_en_dis_vbreak(unsigned handle, bx_bool enable)
+{
+#if (BX_DBG_MAX_VIR_BPOINTS > 0)
+  // see if breakpoint is a virtual breakpoint
+  for (unsigned i=0; i<bx_guard.iaddr.num_virtual; i++) {
+    if (bx_guard.iaddr.vir[i].bpoint_id == handle) {
+      bx_guard.iaddr.vir[i].enabled=enable;
+      return 1;
+    }
+  }
+#endif
+  return 0;
+}
+
+void bx_dbg_del_breakpoint_command(unsigned handle)
+{
+#if (BX_DBG_MAX_VIR_BPOINTS > 0)
+  if (bx_dbg_del_vbreak(handle))
+   goto done;
+#endif
+
+#if (BX_DBG_MAX_LIN_BPOINTS > 0)
+  if (bx_dbg_del_lbreak(handle))
+   goto done;
+#endif
+
+#if (BX_DBG_MAX_PHY_BPOINTS > 0)
+  if (bx_dbg_del_pbreak(handle))
+   goto done;
+#endif
+
+  dbg_printf("Error: breakpoint %u not found.\n", handle);
+  return;
+
+done:
+  bx_dbg_breakpoint_changed();
+}
+
+bx_bool bx_dbg_del_pbreak(unsigned handle)
+{
+#if (BX_DBG_MAX_PHY_BPOINTS > 0)
+  // see if breakpoint is a physical breakpoint
+  for (unsigned i=0; i<bx_guard.iaddr.num_physical; i++) {
+    if (bx_guard.iaddr.phy[i].bpoint_id == handle) {
+      // found breakpoint, delete it by shifting remaining entries left
+      for (unsigned j=i; j<(bx_guard.iaddr.num_physical-1); j++) {
+        bx_guard.iaddr.phy[j] = bx_guard.iaddr.phy[j+1];
+      }
+      bx_guard.iaddr.num_physical--;
+      return 1;
+    }
+  }
+#endif
+  return 0;
+}
+
+bx_bool bx_dbg_del_lbreak(unsigned handle)
+{
+#if (BX_DBG_MAX_LIN_BPOINTS > 0)
+  // see if breakpoint is a linear breakpoint
+  for (unsigned i=0; i<bx_guard.iaddr.num_linear; i++) {
+    if (bx_guard.iaddr.lin[i].bpoint_id == handle) {
+      // found breakpoint, delete it by shifting remaining entries left
+      for (unsigned j=i; j<(bx_guard.iaddr.num_linear-1); j++) {
+        bx_guard.iaddr.lin[j] = bx_guard.iaddr.lin[j+1];
+      }
+      bx_guard.iaddr.num_linear--;
+      return 1;
+    }
+  }
+#endif
+  return 0;
+}
+
+bx_bool bx_dbg_del_vbreak(unsigned handle)
+{
+#if (BX_DBG_MAX_VIR_BPOINTS > 0)
+  // see if breakpoint is a virtual breakpoint
+  for (unsigned i=0; i<bx_guard.iaddr.num_virtual; i++) {
+    if (bx_guard.iaddr.vir[i].bpoint_id == handle) {
+      // found breakpoint, delete it by shifting remaining entries left
+      for (unsigned j=i; j<(bx_guard.iaddr.num_virtual-1); j++) {
+        bx_guard.iaddr.vir[j] = bx_guard.iaddr.vir[j+1];
+      }
+      bx_guard.iaddr.num_virtual--;
+      return 1;
+    }
+  }
+#endif
+  return 0;
+}
+
+int bx_dbg_vbreakpoint_command(BreakpointKind bk, Bit32u cs, bx_address eip)
+{
+#if (BX_DBG_MAX_VIR_BPOINTS > 0)
+  if (bk != bkRegular) {
+    dbg_printf("Error: vbreak of this kind not implemented yet.\n");
+    return -1;
+  }
+
+  if (bx_guard.iaddr.num_virtual >= BX_DBG_MAX_VIR_BPOINTS) {
+    dbg_printf("Error: no more virtual breakpoint slots left.\n");
+    dbg_printf("Error: see BX_DBG_MAX_VIR_BPOINTS.\n");
+    return -1;
+  }
+
+  bx_guard.iaddr.vir[bx_guard.iaddr.num_virtual].cs  = cs;
+  bx_guard.iaddr.vir[bx_guard.iaddr.num_virtual].eip = eip;
+  bx_guard.iaddr.vir[bx_guard.iaddr.num_virtual].bpoint_id = bx_debugger.next_bpoint_id++;
+  int BpId = (int)bx_guard.iaddr.vir[bx_guard.iaddr.num_virtual].bpoint_id;
+  bx_guard.iaddr.vir[bx_guard.iaddr.num_virtual].enabled=1;
+  bx_guard.iaddr.num_virtual++;
+  bx_guard.guard_for |= BX_DBG_GUARD_IADDR_VIR;
+  return BpId;
+
+#else
+  dbg_printf("Error: virtual breakpoint support not compiled in.\n");
+  dbg_printf("Error: make sure BX_DBG_MAX_VIR_BPOINTS > 0\n");
+  return -1;
+#endif
+}
+
+int bx_dbg_lbreakpoint_command(BreakpointKind bk, bx_address laddress)
+{
+#if (BX_DBG_MAX_LIN_BPOINTS > 0)
+  if (bk == bkAtIP) {
+    dbg_printf("Error: lbreak of this kind not implemented yet.\n");
+    return -1;
+  }
+
+  if (bx_guard.iaddr.num_linear >= BX_DBG_MAX_LIN_BPOINTS) {
+    dbg_printf("Error: no more linear breakpoint slots left.\n");
+    dbg_printf("Error: see BX_DBG_MAX_LIN_BPOINTS.\n");
+    return -1;
+  }
+
+  bx_guard.iaddr.lin[bx_guard.iaddr.num_linear].addr = laddress;
+  int BpId = (bk == bkStepOver) ? 0 : bx_debugger.next_bpoint_id++;
+  bx_guard.iaddr.lin[bx_guard.iaddr.num_linear].bpoint_id = BpId;
+  bx_guard.iaddr.lin[bx_guard.iaddr.num_linear].enabled=1;
+  bx_guard.iaddr.num_linear++;
+  bx_guard.guard_for |= BX_DBG_GUARD_IADDR_LIN;
+  return BpId;
+
+#else
+  dbg_printf("Error: linear breakpoint support not compiled in.\n");
+  dbg_printf("Error: make sure BX_DBG_MAX_LIN_BPOINTS > 0\n");
+  return -1;
+#endif
+}
+
+int bx_dbg_pbreakpoint_command(BreakpointKind bk, bx_phy_address paddress)
+{
+#if (BX_DBG_MAX_PHY_BPOINTS > 0)
+  if (bk != bkRegular) {
+    dbg_printf("Error: pbreak of this kind not implemented yet.\n");
+    return -1;
+  }
+
+  if (bx_guard.iaddr.num_physical >= BX_DBG_MAX_PHY_BPOINTS) {
+    dbg_printf("Error: no more physical breakpoint slots left.\n");
+    dbg_printf("Error: see BX_DBG_MAX_PHY_BPOINTS.\n");
+    return -1;
+  }
+
+  bx_guard.iaddr.phy[bx_guard.iaddr.num_physical].addr = paddress;
+  bx_guard.iaddr.phy[bx_guard.iaddr.num_physical].bpoint_id = bx_debugger.next_bpoint_id++;
+  int BpId = (int)bx_guard.iaddr.phy[bx_guard.iaddr.num_physical].bpoint_id;
+  bx_guard.iaddr.phy[bx_guard.iaddr.num_physical].enabled=1;
+  bx_guard.iaddr.num_physical++;
+  bx_guard.guard_for |= BX_DBG_GUARD_IADDR_PHY;
+  return BpId;
+#else
+  dbg_printf("Error: physical breakpoint support not compiled in.\n");
+  dbg_printf("Error: make sure BX_DBG_MAX_PHY_BPOINTS > 0\n");
+  return -1;
+#endif
+}
+
+void bx_dbg_info_bpoints_command(void)
+{
+  unsigned i;
+// Num Type           Disp Enb Address    What
+// 1   breakpoint     keep y   0x00010664 in main at temp.c:7
+
+  dbg_printf("Num Type           Disp Enb Address\n");
+#if (BX_DBG_MAX_VIR_BPOINTS > 0)
+  for (i=0; i<bx_guard.iaddr.num_virtual; i++) {
+    dbg_printf("%3u ", bx_guard.iaddr.vir[i].bpoint_id);
+    dbg_printf("vbreakpoint    ");
+    dbg_printf("keep ");
+    dbg_printf(bx_guard.iaddr.vir[i].enabled?"y   ":"n   ");
+    dbg_printf("0x%04x:" FMT_ADDRX "\n",
+                  bx_guard.iaddr.vir[i].cs,
+                  bx_guard.iaddr.vir[i].eip);
+  }
+#endif
+
+#if (BX_DBG_MAX_LIN_BPOINTS > 0)
+  for (i=0; i<bx_guard.iaddr.num_linear; i++) {
+    dbg_printf("%3u ", bx_guard.iaddr.lin[i].bpoint_id);
+    dbg_printf("lbreakpoint    ");
+    dbg_printf("keep ");
+    dbg_printf(bx_guard.iaddr.lin[i].enabled?"y   ":"n   ");
+    dbg_printf("0x" FMT_ADDRX "\n", bx_guard.iaddr.lin[i].addr);
+  }
+#endif
+
+#if (BX_DBG_MAX_PHY_BPOINTS > 0)
+  for (i=0; i<bx_guard.iaddr.num_physical; i++) {
+    dbg_printf("%3u ", bx_guard.iaddr.phy[i].bpoint_id);
+    dbg_printf("pbreakpoint    ");
+    dbg_printf("keep ");
+    dbg_printf(bx_guard.iaddr.phy[i].enabled?"y   ":"n   ");
+    dbg_printf("0x"FMT_PHY_ADDRX"\n", bx_guard.iaddr.phy[i].addr);
+  }
+#endif
+}
+
+void bx_dbg_set_auto_disassemble(bx_bool enable)
+{
+  bx_debugger.auto_disassemble = enable;
+}
+
+void bx_dbg_set_disassemble_size(unsigned size)
+{
+  if ((size!=16) && (size!=32) && (size!=64) && (size!=0))
+  {
+    dbg_printf("Error: disassemble size must be 16/32 or 64.\n");
+    return;
+  }
+  bx_debugger.disassemble_size = size;
+}
+
+void bx_dbg_disassemble_switch_mode()
+{
+  bx_disassemble.toggle_syntax_mode();
+}
+
+void bx_dbg_disassemble_hex_mode_switch(int mode)
+{
+  bx_disassemble.set_offset_mode_hex(mode);
+}
+
+void bx_dbg_take_command(const char *what, unsigned n)
+{
+  if (! strcmp(what, "dma")) {
+    if (n == 0) {
+      dbg_printf("Error: take what n=0.\n");
+      return;
+    }
+    bx_dbg_post_dma_reports(); // in case there's some pending reports
+    bx_dbg_batch_dma.this_many = n;
+
+    for (unsigned i=0; i<n; i++) {
+      BX_CPU(0)->dbg_take_dma();
+    }
+
+    bx_dbg_batch_dma.this_many = 1;  // reset to normal
+    bx_dbg_post_dma_reports(); // print reports and flush
+    if (bx_guard.report.dma)
+      dbg_printf("done\n");
+  }
+  else if (! strcmp(what, "irq")) {
+    BX_CPU(0)->dbg_take_irq();
+
+    if (bx_guard.report.irq)
+      dbg_printf("done\n");
+  }
+  else {
+    dbg_printf("Error: Take '%s' not understood.\n", what);
+  }
+}
+
+static void bx_print_char(Bit8u ch)
+{
+  if (ch < 10)
+    dbg_printf(" \\%d  ", ch);
+  else if (isprint(ch))
+    dbg_printf("  %c  ", ch);
+  else
+    dbg_printf(" \\x%02X", ch);
+}
+
+void dbg_printf_binary(const char *format, Bit32u data, int bits)
+{
+  int b,len = 0;
+  char num[33];
+
+  for (b = 1 << (bits - 1); b; b >>= 1)
+    num [len++] = (data & b) ? '1' : '0';
+  num [len] = 0;
+  dbg_printf (format, num);
+}
+
+void bx_dbg_examine_command(char *command, char *format, bx_bool format_passed,
+               bx_address addr, bx_bool addr_passed)
+{
+  unsigned repeat_count, i;
+  char ch, display_format, unit_size;
+  bx_bool iteration, memory_dump = false;
+  unsigned data_size;
+  Bit8u   data8;
+  Bit16u  data16;
+  Bit32u  data32;
+  unsigned columns, per_line, offset;
+  bx_bool is_linear;
+  Bit8u databuf[8];
+
+  dbg_printf("[bochs]:\n");
+
+  // If command was the extended "xp" command, meaning eXamine Physical memory,
+  // then flag memory address as physical, rather than linear.
+  if (strcmp(command, "xp") == 0) {
+    is_linear = 0;
+  }
+  else {
+    is_linear = 1;
+  }
+
+  if (addr_passed==0)
+    addr = bx_debugger.default_addr;
+
+  if (format_passed==0) {
+    display_format = bx_debugger.default_display_format;
+    unit_size      = bx_debugger.default_unit_size;
+    repeat_count   = 1;
+  }
+  else {
+    if (format==NULL) {
+      dbg_printf("dbg_examine: format NULL\n");
+      bx_dbg_exit(1);
+    }
+
+    if (strlen(format) < 2) {
+      dbg_printf("dbg_examine: invalid format passed.\n");
+      bx_dbg_exit(1);
+    }
+
+    if (format[0] != '/') {
+      dbg_printf("dbg_examine: '/' is not first char of format.\n");
+      bx_dbg_exit(1);
+    }
+
+    format++;
+    repeat_count = 0;
+    ch = *format;
+    iteration = 0;
+
+    while ((ch>='0') && (ch<='9')) {
+      iteration = 1;
+      repeat_count = 10*repeat_count + (ch-'0');
+      format++;
+      ch = *format;
+    }
+
+    if (iteration==0) {
+      // if no count given, use default
+      repeat_count = 1;
+    }
+    else if (repeat_count==0) {
+      // count give, but zero is an error
+      dbg_printf("dbg_examine: repeat count given but is zero.\n");
+      return;
+    }
+
+    // set up the default display format and unit size parameters
+    display_format = bx_debugger.default_display_format;
+    unit_size      = bx_debugger.default_unit_size;
+
+    for (i = 0; format [i]; i++) {
+      switch (ch = format [i]) {
+        case 'x': // hex
+        case 'd': // signed decimal
+        case 'u': // unsigned decimal
+        case 'o': // octal
+        case 't': // binary
+        case 'c': // chars
+        case 's': // null terminated string
+        case 'i': // machine instruction
+          display_format = ch;
+          break;
+
+        case 'b': // bytes
+        case 'h': // halfwords (two bytes)
+        case 'w': // words (4 bytes)
+        case 'g': // giant words (8 bytes)
+          unit_size = ch;
+          break;
+
+	case 'm': // memory dump
+	  memory_dump = true;
+          break;
+
+        default:
+          dbg_printf("dbg_examine: invalid format passed. \'%c\'\n", ch);
+          bx_dbg_exit(1);
+          break;
+      }
+    }
+  }
+
+  if ((display_format == 'i') || (display_format == 's')) {
+    dbg_printf("error: dbg_examine: 'i' and 's' formats not supported.\n");
+    return;
+  }
+
+  if (unit_size == 'g') {
+    dbg_printf("error: dbg_examine: 'g' (8-byte) unit size not supported.\n");
+    return;
+  }
+
+  if (format_passed) {
+    // store current options as default
+    bx_debugger.default_display_format = display_format;
+    bx_debugger.default_unit_size      = unit_size;
+  }
+
+  data_size = 0;
+  per_line  = 0;
+  offset = 0;
+
+  if (memory_dump) {
+    if (display_format == 'c') {
+      // Display character dump in lines of 64 characters
+      unit_size = 'b';
+      data_size = 1;
+      per_line = 64;
+    }
+    else
+      switch (unit_size) {
+        case 'b': data_size = 1; per_line = 16; break;
+        case 'h': data_size = 2; per_line = 8; break;
+        case 'w': data_size = 4; per_line = 4; break;
+        //case 'g': data_size = 8; per_line = 2; break;
+      }
+      // binary format is quite large
+      if (display_format == 't')
+        per_line /= 4;
+  }
+  else {
+    switch (unit_size) {
+      case 'b': data_size = 1; per_line = 8; break;
+      case 'h': data_size = 2; per_line = 8; break;
+      case 'w': data_size = 4; per_line = 4; break;
+    //case 'g': data_size = 8; per_line = 2; break;
+    }
+  }
+
+  columns = per_line + 1; // set current number columns past limit
+
+  for (i=1; i<=repeat_count; i++) {
+    if (columns > per_line) {
+      // if not 1st run, need a newline from last line
+      if (i!=1)
+        dbg_printf("\n");
+      if (memory_dump)
+        dbg_printf("0x" FMT_ADDRX ":", addr);
+      else
+        dbg_printf("0x" FMT_ADDRX " <bogus+%8u>:", addr, offset);
+      columns = 1;
+    }
+
+    /* Put a space in the middle of dump, for readability */
+    if ((columns - 1) == per_line / 2
+     && memory_dump && display_format != 'c')
+      dbg_printf(" ");
+
+    if (is_linear) {
+      if (! bx_dbg_read_linear(dbg_cpu, addr, data_size, databuf)) return;
+    }
+    else {
+      // address is already physical address
+      BX_MEM(0)->dbg_fetch_mem(BX_CPU(dbg_cpu), (bx_phy_address) addr, data_size, databuf);
+    }
+
+    //FIXME HanishKVC The char display for data to be properly integrated
+    //      so that repeat_count, columns, etc. can be set or used properly.
+    //      Also for data_size of 2 and 4 how to display the individual
+    //      characters i.e in which order to be decided.
+    switch (data_size) {
+      case 1:
+        data8 = databuf[0];
+        if (memory_dump)
+          switch (display_format) {
+	    case 'd': dbg_printf("%03d ", data8); break;
+	    case 'u': dbg_printf("%03u ", data8); break;
+	    case 'o': dbg_printf("%03o ", data8); break;
+	    case 't': dbg_printf_binary ("%s ", data8, 8); break;
+            case 'c': dbg_printf("%c", isprint(data8) ? data8 : '.'); break;
+	    default : dbg_printf("%02X ", data8); break;
+        }
+	else
+        switch (display_format) {
+          case 'x': dbg_printf("\t0x%02x", (unsigned) data8); break;
+          case 'd': dbg_printf("\t%d", (int) (Bit8s) data8); break;
+          case 'u': dbg_printf("\t%u", (unsigned) data8); break;
+          case 'o': dbg_printf("\t%o", (unsigned) data8); break;
+            case 't': dbg_printf_binary("\t%s", data8, 8); break;
+            case 'c': bx_print_char(data8); break;
+        }
+        break;
+
+      case 2:
+        ReadHostWordFromLittleEndian(databuf, data16);
+
+        if (memory_dump)
+          switch (display_format) {
+	    case 'd': dbg_printf("%05d ", data16); break;
+	    case 'u': dbg_printf("%05u ", data16); break;
+	    case 'o': dbg_printf("%06o ", data16); break;
+	    case 't': dbg_printf_binary ("%s ", data16, 16); break;
+	    default : dbg_printf("%04X ", data16); break;
+        }
+	else
+        switch (display_format) {
+          case 'x': dbg_printf("\t0x%04x", (unsigned) data16); break;
+          case 'd': dbg_printf("\t%d", (int) (Bit16s) data16); break;
+          case 'u': dbg_printf("\t%u", (unsigned) data16); break;
+          case 'o': dbg_printf("\t%o", (unsigned) data16); break;
+            case 't': dbg_printf_binary("\t%s", data16, 16); break;
+          case 'c':
+            bx_print_char(data16>>8);
+            bx_print_char(data16 & 0xff);
+            break;
+        }
+        break;
+
+      case 4:
+        ReadHostDWordFromLittleEndian(databuf, data32);
+
+        if (memory_dump)
+          switch (display_format) {
+	    case 'd': dbg_printf("%10d ", data32); break;
+	    case 'u': dbg_printf("%10u ", data32); break;
+	    case 'o': dbg_printf("%12o ", data32); break;
+	    case 't': dbg_printf_binary ("%s ", data32, 32); break;
+	    default : dbg_printf("%08X ", data32); break;
+        }
+	else
+        switch (display_format) {
+          case 'x': dbg_printf("\t0x%08x", (unsigned) data32); break;
+          case 'd': dbg_printf("\t%d", (int) (Bit32s) data32); break;
+          case 'u': dbg_printf("\t%u", (unsigned) data32); break;
+          case 'o': dbg_printf("\t%o", (unsigned) data32); break;
+          case 't': dbg_printf_binary("\t%s", data32, 32); break;
+          case 'c':
+            bx_print_char(0xff & (data32>>24));
+            bx_print_char(0xff & (data32>>16));
+            bx_print_char(0xff & (data32>> 8));
+            bx_print_char(0xff & (data32>> 0));
+            break;
+        }
+        break;
+    }
+
+    addr += data_size;
+    bx_debugger.default_addr = addr;
+    columns++;
+    offset += data_size;
+  }
+  dbg_printf("\n");
+}
+
+Bit32u bx_dbg_lin_indirect(bx_address addr)
+{
+  Bit8u  databuf[4];
+  Bit32u result;
+
+  if (! bx_dbg_read_linear(dbg_cpu, addr, 4, databuf)) {
+    /* bx_dbg_read_linear already printed an error message if it failed */
+    return 0;
+  }
+
+  ReadHostDWordFromLittleEndian(databuf, result);
+  return result;
+}
+
+Bit32u bx_dbg_phy_indirect(bx_phy_address paddr)
+{
+  Bit8u  databuf[4];
+  Bit32u result;
+
+  if (! BX_MEM(0)->dbg_fetch_mem(BX_CPU(dbg_cpu), paddr, 4, databuf)) {
+    /* dbg_fetch_mem already printed an error message if it failed */
+    return 0;
+  }
+
+  ReadHostDWordFromLittleEndian(databuf, result);
+  return result;
+}
+
+void bx_dbg_setpmem_command(bx_phy_address paddr, unsigned len, Bit32u val)
+{
+  Bit8u buf[4];
+
+  switch (len) {
+    case 1:
+      buf[0] = (Bit8u) val;
+      break;
+    case 2:
+      buf[0] = val & 0xff; val >>= 8;
+      buf[1] = val & 0xff;
+      break;
+    case 4:
+      buf[0] = val & 0xff; val >>= 8;
+      buf[1] = val & 0xff; val >>= 8;
+      buf[2] = val & 0xff; val >>= 8;
+      buf[3] = val & 0xff;
+      break;
+    default:
+      dbg_printf("Error: setpmem: bad length value = %u\n", len);
+      return;
+    }
+
+  if (! BX_MEM(0)->dbg_set_mem(paddr, len, buf)) {
+    dbg_printf("Error: setpmem: could not set memory, out of physical bounds?\n");
+  }
+}
+
+void bx_dbg_set_symbol_command(const char *symbol, Bit32u val)
+{
+  bx_bool is_OK = false;
+  symbol++; // get past '$'
+
+  if (!strcmp(symbol, "eip")) {
+    is_OK = BX_CPU(dbg_cpu)->dbg_set_reg(BX_DBG_REG_EIP, val);
+  }
+  else if (!strcmp(symbol, "eflags")) {
+    is_OK = BX_CPU(dbg_cpu)->dbg_set_reg(BX_DBG_REG_EFLAGS, val);
+  }
+  else if (!strcmp(symbol, "cpu")) {
+    if (val >= BX_SMP_PROCESSORS) {
+      dbg_printf("invalid cpu id number %d\n", val);
+      return;
+    }
+    char cpu_param_name[10];
+    sprintf(cpu_param_name, "cpu%d", val);
+    dbg_cpu_list = (bx_list_c*) SIM->get_param(cpu_param_name, SIM->get_bochs_root());
+    dbg_cpu = val;
+    return;
+  }
+  else if (!strcmp(symbol, "synchronous_dma")) {
+    bx_guard.async.dma = !val;
+    return;
+  }
+  else if (!strcmp(symbol, "synchronous_irq")) {
+    bx_guard.async.irq = !val;
+    return;
+  }
+  else if (!strcmp(symbol, "event_reports")) {
+    bx_guard.report.irq   = val;
+    bx_guard.report.a20   = val;
+    bx_guard.report.io    = val;
+    bx_guard.report.dma   = val;
+    return;
+  }
+  else if (!strcmp(symbol, "auto_disassemble")) {
+    bx_dbg_set_auto_disassemble(val != 0);
+    return;
+  }
+  else {
+    dbg_printf("Error: set: unrecognized symbol.\n");
+    return;
+  }
+
+  if (!is_OK) {
+    dbg_printf("Error: could not set register '%s'.\n", symbol);
+  }
+}
+
+void bx_dbg_query_command(const char *what)
+{
+  unsigned pending;
+
+  if (! strcmp(what, "pending")) {
+    pending = BX_CPU(0)->dbg_query_pending();
+
+    if (pending & BX_DBG_PENDING_DMA)
+      dbg_printf("pending DMA\n");
+
+    if (pending & BX_DBG_PENDING_IRQ)
+      dbg_printf("pending IRQ\n");
+
+    if (!pending)
+      dbg_printf("pending none\n");
+
+    dbg_printf("done\n");
+  }
+  else {
+    dbg_printf("Error: Query '%s' not understood.\n", what);
+  }
+}
+
+void bx_dbg_restore_command(const char *param_name, const char *restore_path)
+{
+  const char *path = (restore_path == NULL) ? "." : restore_path;
+  dbg_printf("restoring param (%s) state from file (%s/%s)\n",
+      param_name, path, param_name);
+  if (! SIM->restore_bochs_param(SIM->get_bochs_root(), path, param_name)) {
+    dbg_printf("Error: error occured during restore\n");
+  }
+  else {
+    bx_sr_after_restore_state();
+  }
+}
+
+void bx_dbg_disassemble_current(const char *format)
+{
+  Bit64u addr = bx_dbg_get_laddr(bx_dbg_get_selector_value(BX_DBG_SREG_CS), 
+     BX_CPU(dbg_cpu)->get_instruction_pointer());
+  bx_dbg_disassemble_command(format, addr, addr);
+}
+
+void bx_dbg_disassemble_command(const char *format, Bit64u from, Bit64u to)
+{
+  int numlines = INT_MAX;
+
+  if (from > to) {
+     Bit64u temp = from;
+     from = to;
+     to = temp;
+  }
+
+  if (format) {
+    // format always begins with '/' (checked in lexer)
+    // so we won't bother checking it here second time.
+    numlines = atoi(format + 1);
+    if (to == from)
+      to = BX_MAX_BIT64U; // Disassemble just X lines
+  }
+
+  unsigned dis_size = bx_debugger.disassemble_size;
+  if (dis_size == 0) {
+    dis_size = 16; 		// until otherwise proven
+    if (BX_CPU(dbg_cpu)->sregs[BX_SEG_REG_CS].cache.u.segment.d_b)
+      dis_size = 32;
+    if (BX_CPU(dbg_cpu)->get_cpu_mode() == BX_MODE_LONG_64)
+      dis_size = 64;
+  }
+
+  do {
+    numlines--;
+
+    if (! bx_dbg_read_linear(dbg_cpu, from, 16, bx_disasm_ibuf)) break;
+
+    unsigned ilen = bx_disassemble.disasm(dis_size==32, dis_size==64,
+       (bx_address)(-1), (bx_address)(-1), bx_disasm_ibuf, bx_disasm_tbuf);
+
+    const char *Sym=bx_dbg_disasm_symbolic_address((Bit32u)from, 0);
+
+    dbg_printf("%08x: ", (unsigned) from);
+    dbg_printf("(%20s): ", Sym?Sym:"");
+    dbg_printf("%-25s ; ", bx_disasm_tbuf);
+
+    for (unsigned j=0; j<ilen; j++)
+      dbg_printf("%02x", (unsigned) bx_disasm_ibuf[j]);
+    dbg_printf("\n");
+
+    from += ilen;
+  } while ((from < to) && numlines > 0);
+}
+
+void bx_dbg_instrument_command(const char *comm)
+{
+#if BX_INSTRUMENTATION
+  dbg_printf("Command '%s' passed to instrumentation module\n", comm);
+  BX_INSTR_DEBUG_CMD(comm);
+#else
+  UNUSED(comm);
+  dbg_printf("Error: instrumentation not enabled.\n");
+#endif
+}
+
+void bx_dbg_doit_command(unsigned n)
+{
+  // generic command to add temporary hacks to
+  // for debugging purposes
+  bx_dbg.interrupts = n;
+  bx_dbg.exceptions = n;
+}
+
+void bx_dbg_crc_command(bx_phy_address addr1, bx_phy_address addr2)
+{
+  Bit32u crc1;
+
+  if (addr1 >= addr2) {
+    dbg_printf("Error: crc32: invalid range\n");
+    return;
+  }
+
+  if (!BX_MEM(0)->dbg_crc32(addr1, addr2, &crc1)) {
+    dbg_printf("Error: could not crc32 memory\n");
+    return;
+  }
+  dbg_printf("0x%lx\n", crc1);
+}
+
+void bx_dbg_print_descriptor(Bit32u lo, Bit32u hi)
+{
+  Bit32u base = ((lo >> 16) & 0xffff)
+             | ((hi << 16) & 0xff0000)
+             | (hi & 0xff000000);
+  Bit32u limit = (hi & 0x000f0000) | (lo & 0xffff);
+  Bit32u segment = (lo >> 16) & 0xffff;
+  Bit32u offset = (lo & 0xffff) | (hi & 0xffff0000);
+  unsigned type = (hi >> 8) & 0xf;
+  unsigned dpl = (hi >> 13) & 0x3;
+  unsigned s = (hi >> 12) & 0x1;
+  unsigned d_b = (hi >> 22) & 0x1;
+  unsigned g = (hi >> 23) & 0x1;
+
+  // 32-bit trap gate, target=0010:c0108ec4, DPL=0, present=1
+  // code segment, base=0000:00cfffff, length=0xffff
+  if (s) {
+    // either a code or a data segment. bit 11 (type file MSB) then says
+    // 0=data segment, 1=code seg
+    if (type&8) {
+      dbg_printf("Code segment, base=0x%08x, limit=0x%08x, %s%s%s, %d-bit\n",
+        base, g ? (limit * 4096 + 4095) : limit,
+        (type&2)? "Execute/Read" : "Execute-Only",
+        (type&4)? ", Conforming" : "",
+        (type&1)? ", Accessed" : "",
+        d_b ? 32 : 16);
+    } else {
+      dbg_printf("Data segment, base=0x%08x, limit=0x%08x, %s%s%s\n",
+        base, g ? (limit * 4096 + 4095) : limit,
+        (type&2)? "Read/Write" : "Read-Only",
+        (type&4)? ", Expand-down" : "",
+        (type&1)? ", Accessed" : "");
+    }
+  } else {
+    // types from IA32-devel-guide-3, page 3-15.
+    static const char *undef = "???";
+    static const char *type_names[16] = { 
+        undef,
+        "16-Bit TSS (available)",
+        "LDT",
+        "16-Bit TSS (Busy)",
+        "16-Bit Call Gate",
+        "Task Gate",
+        "16-Bit Interrupt Gate",
+        "16-Bit Trap Gate",
+        undef,
+        "32-Bit TSS (Available)",
+        undef,
+        "32-Bit TSS (Busy)",
+        "32-Bit Call Gate",
+        undef,
+        "32-Bit Interrupt Gate",
+        "32-Bit Trap Gate"
+    };
+    dbg_printf("%s ", type_names[type]);
+    // only print more if type is valid
+    if (type_names[type] == undef)  {
+      dbg_printf("descriptor hi=0x%08x, lo=0x%08x", hi, lo);
+    } else {
+      // for call gates, print segment:offset and parameter count p.4-15
+      // for task gate, only present,dpl,TSS segment selector exist. p.5-13
+      // for interrupt gate, segment:offset,p,dpl
+      // for trap gate, segment:offset,p,dpl
+      // for TSS, base address and segment limit
+      switch (type) {
+      case BX_SYS_SEGMENT_AVAIL_286_TSS:
+      case BX_SYS_SEGMENT_BUSY_286_TSS:
+      case BX_SYS_SEGMENT_AVAIL_386_TSS:
+      case BX_SYS_SEGMENT_BUSY_386_TSS:
+        dbg_printf("at 0x%08x, length 0x%05x", base, limit);
+        break;
+      case BX_SYS_SEGMENT_LDT:
+        // it's an LDT. not much to print.
+        break;
+      default:
+        // task, int, trap, or call gate.
+        dbg_printf("target=0x%04x:0x%08x, DPL=%d", segment, offset, dpl);
+        break;
+      }
+    }
+    dbg_printf("\n");
+  }
+}
+
+#if BX_SUPPORT_X86_64
+void bx_dbg_print_descriptor64(Bit32u lo1, Bit32u hi1, Bit32u lo2, Bit32u hi2)
+{
+  Bit32u segment = (lo1 >> 16) & 0xffff;
+  Bit64u offset = (lo1 & 0xffff) | (hi1 & 0xffff0000) | ((Bit64u)(lo2) << 32);
+  unsigned type = (hi1 >> 8) & 0xf;
+  unsigned dpl = (hi1 >> 13) & 0x3;
+  unsigned s = (hi1 >> 12) & 0x1;
+
+  if (s) {
+    dbg_printf("bx_dbg_print_descriptor64: only system entries displayed in 64bit mode\n");
+  }
+  else {
+    static const char *undef = "???";
+    static const char *type_names[16] = { 
+        undef,
+        undef,
+        "LDT",
+        undef,
+        undef,
+        undef,
+        undef,
+        undef,
+        undef,
+        "64-Bit TSS (Available)",
+        undef,
+        "64-Bit TSS (Busy)",
+        "64-Bit Call Gate",
+        undef,
+        "64-Bit Interrupt Gate",
+        "64-Bit Trap Gate"
+    };
+    dbg_printf("%s ", type_names[type]);
+    // only print more if type is valid
+    if (type_names[type] == undef)  {
+      dbg_printf("\ndescriptor dword2 hi=0x%08x, lo=0x%08x", hi2, lo2);
+      dbg_printf("\n           dword1 hi=0x%08x, lo=0x%08x", hi1, lo1);
+    } else {
+      // for call gates, print segment:offset and parameter count p.4-15
+      // for task gate, only present,dpl,TSS segment selector exist. p.5-13
+      // for interrupt gate, segment:offset,p,dpl
+      // for trap gate, segment:offset,p,dpl
+      // for TSS, base address and segment limit
+      switch (type) {
+      case BX_SYS_SEGMENT_AVAIL_286_TSS:
+      case BX_SYS_SEGMENT_BUSY_286_TSS:
+      case BX_SYS_SEGMENT_AVAIL_386_TSS:
+      case BX_SYS_SEGMENT_BUSY_386_TSS:
+        // don't print nothing about 64-bit TSS
+        break;
+      case BX_SYS_SEGMENT_LDT:
+        // it's an LDT. not much to print.
+        break;
+      default:
+        // task, int, trap, or call gate.
+        dbg_printf("target=0x%04x:"FMT_ADDRX", DPL=%d", segment, offset, dpl);
+        break;
+      }
+    }
+    dbg_printf("\n");
+  }
+}
+#endif
+
+void bx_dbg_info_idt_command(unsigned from, unsigned to)
+{
+  bx_dbg_global_sreg_t idtr;
+  BX_CPU(dbg_cpu)->dbg_get_idtr(&idtr);
+  bx_bool all = 0;
+
+  if (to == (unsigned) EMPTY_ARG) {
+    to = from;
+    if(from == (unsigned) EMPTY_ARG) { from = 0; to = 255; all = 1; }
+  }
+  if (from > 255 || to > 255) {
+    dbg_printf("IDT entry should be [0-255], 'info idt' command malformed\n");
+    return;
+  }
+  if (from > to) {
+    unsigned temp = from;
+    from = to;
+    to = temp;
+  }
+
+#if BX_SUPPORT_X86_64
+  if (BX_CPU(dbg_cpu)->long_mode()) {
+    dbg_printf("Interrupt Descriptor Table (base=0x" FMT_ADDRX ", limit=%d):\n", idtr.base, idtr.limit);
+    for (unsigned n = from; n<=to; n++) {
+      Bit8u entry[16];
+      if (16*n + 15 > idtr.limit) break;
+      if (bx_dbg_read_linear(dbg_cpu, idtr.base + 16*n, 16, entry)) {
+        dbg_printf("IDT[0x%02x]=", n);
+
+        Bit32u lo1 = (entry[3]  << 24) | (entry[2]  << 16) | (entry[1]  << 8) | (entry[0]);
+        Bit32u hi1 = (entry[7]  << 24) | (entry[6]  << 16) | (entry[5]  << 8) | (entry[4]);
+        Bit32u lo2 = (entry[11] << 24) | (entry[10] << 16) | (entry[9]  << 8) | (entry[8]);
+        Bit32u hi2 = (entry[15] << 24) | (entry[14] << 16) | (entry[13] << 8) | (entry[12]);
+
+        bx_dbg_print_descriptor64(lo1, hi1, lo2, hi2);
+      }
+      else {
+        dbg_printf("error: IDTR+16*%d points to invalid linear address 0x" FMT_ADDRX "\n", n, idtr.base);
+      }
+    }
+  }
+  else
+#endif
+  {
+    dbg_printf("Interrupt Descriptor Table (base=0x" FMT_ADDRX ", limit=%d):\n", idtr.base, idtr.limit);
+    for (unsigned n = from; n<=to; n++) {
+      Bit8u entry[8];
+      if (8*n + 7 > idtr.limit) break;
+      if (bx_dbg_read_linear(dbg_cpu, idtr.base + 8*n, 8, entry)) {
+        dbg_printf("IDT[0x%02x]=", n);
+
+        Bit32u lo = (entry[3]  << 24) | (entry[2]  << 16) | (entry[1]  << 8) | (entry[0]);
+        Bit32u hi = (entry[7]  << 24) | (entry[6]  << 16) | (entry[5]  << 8) | (entry[4]);
+
+        bx_dbg_print_descriptor(lo, hi);
+      }
+      else {
+        dbg_printf("error: IDTR+8*%d points to invalid linear address 0x" FMT_ADDRX "\n", n, idtr.base);
+      }
+    }
+  }
+
+  if (all)
+    dbg_printf("You can list individual entries with 'info idt [NUM]' or groups with 'info idt [NUM] [NUM]'\n");
+}
+
+void bx_dbg_info_gdt_command(unsigned from, unsigned to)
+{
+  bx_dbg_global_sreg_t gdtr;
+  BX_CPU(dbg_cpu)->dbg_get_gdtr(&gdtr);
+  bx_bool all = 0;
+
+  if (to == (unsigned) EMPTY_ARG) {
+    to = from;
+    if(from == (unsigned) EMPTY_ARG) { from = 0; to = 0xffff; all = 1; }
+  }
+  if (from > 0xffff || to > 0xffff) {
+    dbg_printf("GDT entry should be [0-65535], 'info gdt' command malformed\n");
+    return;
+  }
+  if (from > to) {
+    unsigned temp = from;
+    from = to;
+    to = temp;
+  }
+
+  dbg_printf("Global Descriptor Table (base=0x" FMT_ADDRX ", limit=%d):\n", gdtr.base, gdtr.limit);
+  for (unsigned n = from; n<=to; n++) {
+    Bit8u entry[8];
+    if (8*n + 7 > gdtr.limit) break;
+    if (bx_dbg_read_linear(dbg_cpu, gdtr.base + 8*n, 8, entry)) {
+      dbg_printf("GDT[0x%02x]=", n);
+
+      Bit32u lo = (entry[3]  << 24) | (entry[2]  << 16) | (entry[1]  << 8) | (entry[0]);
+      Bit32u hi = (entry[7]  << 24) | (entry[6]  << 16) | (entry[5]  << 8) | (entry[4]);
+
+      bx_dbg_print_descriptor(lo, hi);
+    }
+    else {
+      dbg_printf("error: GDTR+8*%d points to invalid linear address 0x" FMT_ADDRX "\n",
+        n, gdtr.base);
+    }
+  }
+  if (all)
+    dbg_printf("You can list individual entries with 'info gdt [NUM]' or groups with 'info gdt [NUM] [NUM]'\n");
+}
+
+void bx_dbg_info_ldt_command(unsigned from, unsigned to)
+{
+  bx_address ldtr_base = SIM->get_param_num("LDTR.base", dbg_cpu_list)->get64();
+  Bit32u ldtr_limit = SIM->get_param_num("LDTR.limit_scaled", dbg_cpu_list)->get();
+
+  bx_bool all = 0;
+
+  if (to == (unsigned) EMPTY_ARG) {
+    to = from;
+    if(from == (unsigned) EMPTY_ARG) { from = 0; to = 0xffff; all = 1; }
+  }
+  if (from > 0xffff || to > 0xffff) {
+    dbg_printf("LDT entry should be [0-65535], 'info ldt' command malformed\n");
+    return;
+  }
+  if (from > to) {
+    unsigned temp = from;
+    from = to;
+    to = temp;
+  }
+
+  dbg_printf("Local Descriptor Table (base=0x" FMT_ADDRX ", limit=%d):\n", ldtr_base, ldtr_limit);
+  for (unsigned n = from; n<=to; n++) {
+    Bit8u entry[8];
+    if (8*n + 7 > ldtr_limit) break;
+    if (bx_dbg_read_linear(dbg_cpu, ldtr_base + 8*n, 8, entry)) {
+      dbg_printf("LDT[0x%02x]=", n);
+
+      Bit32u lo = (entry[3]  << 24) | (entry[2]  << 16) | (entry[1]  << 8) | (entry[0]);
+      Bit32u hi = (entry[7]  << 24) | (entry[6]  << 16) | (entry[5]  << 8) | (entry[4]);
+
+      bx_dbg_print_descriptor(lo, hi);
+    }
+    else {
+      dbg_printf("error: LDTR+8*%d points to invalid linear address 0x" FMT_ADDRX "\n",
+        n, ldtr_base);
+    }
+  }
+  if (all)
+    dbg_printf("You can list individual entries with 'info ldt [NUM]' or groups with 'info ldt [NUM] [NUM]'\n");
+}
+
+/*form RB list*/
+static const char* bx_dbg_ivt_desc(int intnum)
+{
+  const char* ret;
+  switch (intnum) {
+    case 0x00: ret = "DIVIDE ERROR"                        ; break;
+    case 0x01: ret = "SINGLE STEP"                         ; break;
+    case 0x02: ret = "NON-MASKABLE INTERRUPT"              ; break;
+    case 0x03: ret = "BREAKPOINT"                          ; break;
+    case 0x04: ret = "INT0 DETECTED OVERFLOW"              ; break;
+    case 0x05: ret = "BOUND RANGE EXCEED"                  ; break;
+    case 0x06: ret = "INVALID OPCODE"                      ; break;
+    case 0x07: ret = "PROCESSOR EXTENSION NOT AVAILABLE"   ; break;
+    case 0x08: ret = "IRQ0 - SYSTEM TIMER"                 ; break;
+    case 0x09: ret = "IRQ1 - KEYBOARD DATA READY"          ; break;
+    case 0x0a: ret = "IRQ2 - LPT2"                         ; break;
+    case 0x0b: ret = "IRQ3 - COM2"                         ; break;
+    case 0x0c: ret = "IRQ4 - COM1"                         ; break;
+    case 0x0d: ret = "IRQ5 - FIXED DISK"                   ; break;
+    case 0x0e: ret = "IRQ6 - DISKETTE CONTROLLER"          ; break;
+    case 0x0f: ret = "IRQ7 - PARALLEL PRINTER"             ; break;
+    case 0x10: ret = "VIDEO"                               ; break;
+    case 0x11: ret = "GET EQUIPMENT LIST"                  ; break;
+    case 0x12: ret = "GET MEMORY SIZE"                     ; break;
+    case 0x13: ret = "DISK"                                ; break;
+    case 0x14: ret = "SERIAL"                              ; break;
+    case 0x15: ret = "SYSTEM"                              ; break;
+    case 0x16: ret = "KEYBOARD"                            ; break;
+    case 0x17: ret = "PRINTER"                             ; break;
+    case 0x18: ret = "CASETTE BASIC"                       ; break;
+    case 0x19: ret = "BOOTSTRAP LOADER"                    ; break;
+    case 0x1a: ret = "TIME"                                ; break;
+    case 0x1b: ret = "KEYBOARD - CONTROL-BREAK HANDLER"    ; break;
+    case 0x1c: ret = "TIME - SYSTEM TIMER TICK"            ; break;
+    case 0x1d: ret = "SYSTEM DATA - VIDEO PARAMETER TABLES"; break;
+    case 0x1e: ret = "SYSTEM DATA - DISKETTE PARAMETERS"   ; break;
+    case 0x1f: ret = "SYSTEM DATA - 8x8 GRAPHICS FONT"     ; break;
+    case 0x70: ret = "IRQ8 - CMOS REAL-TIME CLOCK"         ; break;
+    case 0x71: ret = "IRQ9 - REDIRECTED TO INT 0A BY BIOS" ; break;
+    case 0x72: ret = "IRQ10 - RESERVED"                    ; break;
+    case 0x73: ret = "IRQ11 - RESERVED"                    ; break;
+    case 0x74: ret = "IRQ12 - POINTING DEVICE"             ; break;
+    case 0x75: ret = "IRQ13 - MATH COPROCESSOR EXCEPTION"  ; break;
+    case 0x76: ret = "IRQ14 - HARD DISK CONTROLLER OPERATION COMPLETE"; break;
+    case 0x77: ret = "IRQ15 - SECONDARY IDE CONTROLLER OPERATION COMPLETE"; break;
+    default  : ret = ""                                    ; break;
+  }
+  return ret;
+}
+
+void bx_dbg_info_ivt_command(unsigned from, unsigned to)
+{
+  unsigned char buff[4];
+  unsigned seg, off;
+  bx_bool all = 0;
+  bx_dbg_global_sreg_t idtr;
+
+  BX_CPU(dbg_cpu)->dbg_get_idtr(&idtr);
+
+  if (! BX_CPU(dbg_cpu)->protected_mode())
+  {
+    if (to == (unsigned) EMPTY_ARG) {
+      to = from;
+      if(from == (unsigned) EMPTY_ARG) { from = 0; to = 255; all = 1; }
+    }
+    if (from > 255 || to > 255) {
+      dbg_printf("IVT entry should be [0-255], 'info ivt' command malformed\n");
+      return;
+    }
+    if (from > to) {
+      unsigned temp = from;
+      from = to;
+      to = temp;
+    }
+
+    for (unsigned i = from; i <= to; i++)
+    {
+      bx_dbg_read_linear(dbg_cpu, idtr.base + i*4, 4, buff);
+      seg = ((Bit32u) buff[3] << 8) | buff[2];
+      off = ((Bit32u) buff[1] << 8) | buff[0];
+      bx_dbg_read_linear(dbg_cpu, (seg << 4) + off, 1, buff);
+      dbg_printf("INT# %02x > %04X:%04X (0x%08x) %s%s\n", i, seg, off,
+         (unsigned) ((seg << 4) + off), bx_dbg_ivt_desc(i),
+         (buff[0] == 0xcf) ? " ; dummy iret" : "");
+    }
+    if (all) dbg_printf("You can list individual entries with 'info ivt [NUM]' or groups with 'info ivt [NUM] [NUM]'\n");
+  }
+  else
+    dbg_printf("cpu in protected mode, use info idt\n");
+}
+
+static void bx_dbg_print_tss(Bit8u *tss, int len)
+{
+  if (len<104) {
+    dbg_printf("Invalid tss length (limit must be greater then 103)\n");
+    return;
+  }
+
+  dbg_printf("ss:esp(0): 0x%04x:0x%08x\n",
+    *(Bit16u*)(tss+8), *(Bit32u*)(tss+4));
+  dbg_printf("ss:esp(1): 0x%04x:0x%08x\n",
+    *(Bit16u*)(tss+0x10), *(Bit32u*)(tss+0xc));
+  dbg_printf("ss:esp(2): 0x%04x:0x%08x\n",
+    *(Bit16u*)(tss+0x18), *(Bit32u*)(tss+0x14));
+  dbg_printf("cr3: 0x%08x\n", *(Bit32u*)(tss+0x1c));
+  dbg_printf("eip: 0x%08x\n", *(Bit32u*)(tss+0x20));
+  dbg_printf("eflags: 0x%08x\n", *(Bit32u*)(tss+0x24));
+
+  dbg_printf("cs: 0x%04x ds: 0x%04x ss: 0x%04x\n",
+    *(Bit16u*)(tss+76), *(Bit16u*)(tss+84), *(Bit16u*)(tss+80));
+  dbg_printf("es: 0x%04x fs: 0x%04x gs: 0x%04x\n",
+    *(Bit16u*)(tss+72), *(Bit16u*)(tss+88), *(Bit16u*)(tss+92));
+
+  dbg_printf("eax: 0x%08x  ebx: 0x%08x  ecx: 0x%08x  edx: 0x%08x\n",
+    *(Bit32u*)(tss+0x28), *(Bit32u*)(tss+0x34), *(Bit32u*)(tss+0x2c), *(Bit32u*)(tss+0x30));
+  dbg_printf("esi: 0x%08x  edi: 0x%08x  ebp: 0x%08x  esp: 0x%08x\n",
+    *(Bit32u*)(tss+0x40), *(Bit32u*)(tss+0x44), *(Bit32u*)(tss+0x3c), *(Bit32u*)(tss+0x38));
+
+  dbg_printf("ldt: 0x%04x\n", *(Bit16u*)(tss+0x60));
+  dbg_printf("i/o map: 0x%04x\n", *(Bit16u*)(tss+0x66));
+}
+
+void bx_dbg_info_tss_command(void)
+{
+  bx_dbg_sreg_t tr;
+  BX_CPU(dbg_cpu)->dbg_get_tr(&tr);
+
+  bx_address base = (tr.des_l>>16) |
+                   ((tr.des_h<<16)&0x00ff0000) | (tr.des_h & 0xff000000);
+#if BX_SUPPORT_X86_64
+  base |= (Bit64u)(tr.dword3) << 32;
+#endif
+  Bit32u len = (tr.des_l & 0xffff) + 1;
+
+  dbg_printf("tr:s=0x%x, base=0x" FMT_ADDRX ", valid=%u\n",
+      (unsigned) tr.sel, base, (unsigned) tr.valid);
+
+  bx_phy_address paddr = 0;
+  if (BX_CPU(dbg_cpu)->dbg_xlate_linear2phy(base, &paddr)) {
+    bx_dbg_print_tss(BX_MEM(0)->get_vector(paddr), len);
+  }
+  else {
+    dbg_printf("bx_dbg_info_tss_command: failed to get physical address for TSS.BASE !");
+  }
+}
+
+/*
+ * this function implements the info ne2k commands in the debugger
+ * info ne2k - shows all registers
+ * info ne2k page N - shows all registers in a page
+ * info ne2k page N reg M - shows just one register
+ */
+void bx_dbg_info_ne2k(int page, int reg)
+{
+#if BX_SUPPORT_NE2K
+  DEV_ne2k_print_info(stderr, page, reg, 0);
+#else
+  dbg_printf("NE2000 support is not compiled in\n");
+#endif
+}
+
+/*
+ * this implements the info pic command in the debugger.
+ * info pic - shows pic registers
+ */
+void bx_dbg_info_pic()
+{
+  DEV_pic_debug_dump();
+}
+
+/*
+ * this implements the info vga command in the debugger.
+ * info vga - shows vga registers
+ */
+void bx_dbg_info_vga()
+{
+  DEV_vga_debug_dump();
+}
+
+/*
+ * this implements the info pci command in the debugger.
+ * info pci - shows i440fx state
+ */
+void bx_dbg_info_pci()
+{
+#if BX_SUPPORT_PCI
+  if (SIM->get_param_bool(BXPN_I440FX_SUPPORT)->get()) {
+    DEV_pci_debug_dump();
+  }
+  else {
+    dbg_printf("PCI support is disabled in .bochsrc\n");
+  }
+#else
+  dbg_printf("PCI support is not compiled in\n");
+#endif
+}
+
+//
+// Reports from various events
+//
+
+void bx_dbg_iac_report(unsigned vector, unsigned irq)
+{
+  if (bx_guard.report.irq) {
+    dbg_printf("event at t=" FMT_LL "d IRQ irq=%u vec=%x\n",
+      bx_pc_system.time_ticks(), irq, vector);
+  }
+}
+
+void bx_dbg_a20_report(unsigned val)
+{
+  if (bx_guard.report.a20) {
+    dbg_printf("event at t=" FMT_LL "d A20 val=%u\n",
+      bx_pc_system.time_ticks(), val);
+  }
+}
+
+void bx_dbg_io_report(Bit32u port, unsigned size, unsigned op, Bit32u val)
+{
+  if (bx_guard.report.io) {
+    dbg_printf("event at t=" FMT_LL "d IO addr=0x%x size=%u op=%s val=0x%x\n",
+      bx_pc_system.time_ticks(),
+      port,
+      size,
+      (op==BX_READ) ? "read" : "write",
+      (unsigned) val);
+  }
+}
+
+void bx_dbg_dma_report(bx_phy_address addr, unsigned len, unsigned what, Bit32u val)
+{
+  if (bx_dbg_batch_dma.this_many == 0) {
+    dbg_printf("%s: DMA batch this_many=0.\n", argv0);
+    bx_dbg_exit(1);
+  }
+
+  // if Q is full, post events (and flush)
+  if (bx_dbg_batch_dma.Qsize >= bx_dbg_batch_dma.this_many) {
+    dbg_printf("%s: DMA batch Q was not flushed.\n", argv0);
+    bx_dbg_exit(1);
+  }
+
+  // if Q already has MAX elements in it
+  if (bx_dbg_batch_dma.Qsize >= BX_BATCH_DMA_BUFSIZE) {
+    dbg_printf("%s: DMA batch buffer overrun.\n", argv0);
+    bx_dbg_exit(1);
+  }
+
+  bx_dbg_batch_dma.Qsize++;
+  bx_dbg_batch_dma.Q[bx_dbg_batch_dma.Qsize-1].addr = addr;
+  bx_dbg_batch_dma.Q[bx_dbg_batch_dma.Qsize-1].len  = len;
+  bx_dbg_batch_dma.Q[bx_dbg_batch_dma.Qsize-1].what = what;
+  bx_dbg_batch_dma.Q[bx_dbg_batch_dma.Qsize-1].val  = val;
+  bx_dbg_batch_dma.Q[bx_dbg_batch_dma.Qsize-1].time = bx_pc_system.time_ticks();
+
+  // if Q is full, post events (and flush)
+  if (bx_dbg_batch_dma.Qsize >= bx_dbg_batch_dma.this_many)
+    bx_dbg_post_dma_reports();
+}
+
+void bx_dbg_post_dma_reports(void)
+{
+  unsigned i;
+  unsigned addr, len, what, val;
+  unsigned last_addr, last_len, last_what;
+  unsigned print_header;
+  unsigned first_iteration;
+
+  if (bx_guard.report.dma) {
+    if (bx_dbg_batch_dma.Qsize == 0) return; // nothing batched to print
+
+    // compress output so all contiguous DMA ops of the same type and size
+    // are printed on the same line
+    last_addr = bx_dbg_batch_dma.Q[0].addr;
+    last_len  = bx_dbg_batch_dma.Q[0].len;
+    last_what = bx_dbg_batch_dma.Q[0].what;
+    first_iteration = 1;
+
+    for (i=0; i<bx_dbg_batch_dma.Qsize; i++) {
+      addr = bx_dbg_batch_dma.Q[i].addr;
+      len  = bx_dbg_batch_dma.Q[i].len;
+      what = bx_dbg_batch_dma.Q[i].what;
+      val  = bx_dbg_batch_dma.Q[i].val;
+
+      if (len != last_len)
+        print_header = 1;
+      else if (what != last_what)
+        print_header = 1;
+      else if (addr != (last_addr + last_len))
+        print_header = 1;
+      else
+        print_header = 0;
+
+      // now store current values for next iteration
+      last_addr = addr;
+      last_len  = len;
+      last_what = what;
+
+      if (print_header) {
+        if (!first_iteration) // need return from previous line
+          dbg_printf("\n");
+        else
+          first_iteration = 0;
+        // need to output the event header
+        dbg_printf("event at t=" FMT_LL "d DMA addr=0x%x size=%u op=%s val=0x%x",
+                         bx_pc_system.time_ticks(),
+                         addr, len, (what==BX_READ) ? "read" : "write", val);
+        print_header = 0;
+      }
+      else {
+        // *no* need to output the event header
+        dbg_printf(" 0x%x", val);
+      }
+    }
+    if (bx_dbg_batch_dma.Qsize)
+      dbg_printf("\n");
+  }
+
+  // empty Q, regardless of whether reports are printed
+  bx_dbg_batch_dma.Qsize = 0;
+}
+
+void bx_dbg_dump_table(void)
+{
+  Bit32u lin, start_lin; // show only low 32 bit
+  bx_phy_address phy, start_phy; // start of a valid translation interval
+  bx_bool valid;
+
+  if (! BX_CPU(dbg_cpu)->cr0.get_PG()) {
+    printf("paging off\n");
+    return;
+  }
+
+  printf("cr3: 0x"FMT_PHY_ADDRX"\n", BX_CPU(dbg_cpu)->cr3);
+
+  lin = 0;
+  phy = 0;
+
+  start_lin = 1;
+  start_phy = 2;
+  while(1) {
+    valid = BX_CPU(dbg_cpu)->dbg_xlate_linear2phy(lin, &phy);
+    if(valid) {
+      if((lin - start_lin) != (phy - start_phy)) {
+        if(start_lin != 1)
+          dbg_printf("0x%08x-0x%08x -> 0x"FMT_PHY_ADDRX"-0x"FMT_PHY_ADDRX"\n",
+            start_lin, lin - 1, start_phy, start_phy + (lin-1-start_lin));
+        start_lin = lin;
+        start_phy = phy;
+      }
+    } else {
+      if(start_lin != 1)
+        dbg_printf("0x%08x-0x%08x -> 0x"FMT_PHY_ADDRX"-0x"FMT_PHY_ADDRX"\n",
+          start_lin, lin - 1, start_phy, start_phy + (lin-1-start_lin));
+      start_lin = 1;
+      start_phy = 2;
+    }
+
+    if(lin == 0xfffff000) break;
+    lin += 0x1000;
+  }
+  if(start_lin != 1)
+    dbg_printf("0x%08x-0x%08x -> 0x"FMT_PHY_ADDRX"-0x"FMT_PHY_ADDRX"\n",
+         start_lin, 0xffffffff, start_phy, start_phy + (0xffffffff-start_lin));
+}
+
+void bx_dbg_print_help(void)
+{
+  dbg_printf("h|help - show list of debugger commands\n");
+  dbg_printf("h|help command - show short command description\n");
+  dbg_printf("-*- Debugger control -*-\n");
+  dbg_printf("    help, q|quit|exit, set, instrument, show, trace, trace-reg,\n");
+  dbg_printf("    trace-mem, u|disasm, record, playback, ldsym, slist\n");
+  dbg_printf("-*- Execution control -*-\n");
+  dbg_printf("    c|cont|continue, s|step, p|n|next, modebp\n");
+  dbg_printf("-*- Breakpoint management -*-\n");
+  dbg_printf("    vb|vbreak, lb|lbreak, pb|pbreak|b|break, sb, sba, blist,\n");
+  dbg_printf("    bpe, bpd, d|del|delete, watch, unwatch\n");
+  dbg_printf("-*- CPU and memory contents -*-\n");
+  dbg_printf("    x, xp, setpmem, crc, info,\n");
+  dbg_printf("    r|reg|regs|registers, fp|fpu, mmx, sse, sreg, dreg, creg,\n");
+  dbg_printf("    page, set, ptime, print-stack, ?|calc\n");
+  dbg_printf("-*- Working with bochs param tree -*-\n");
+  dbg_printf("    show \"param\", restore\n");
+}
+
+void bx_dbg_calc_command(Bit64u value)
+{
+  dbg_printf("0x" FMT_LL "x " FMT_LL "d\n", value, value);
+}
+
+Bit8u bx_dbg_get_reg8l_value(unsigned reg)
+{
+  if (reg < BX_GENERAL_REGISTERS)
+    return BX_CPU(dbg_cpu)->get_reg8l(reg);
+
+  dbg_printf("Unknown 8BL register [%d] !!!\n", reg);
+  return 0;
+}
+
+Bit8u bx_dbg_get_reg8h_value(unsigned reg)
+{
+  if (reg < BX_GENERAL_REGISTERS)
+    return BX_CPU(dbg_cpu)->get_reg8h(reg);
+
+  dbg_printf("Unknown 8BH register [%d] !!!\n", reg);
+  return 0;
+}
+
+Bit16u bx_dbg_get_reg16_value(unsigned reg)
+{
+  if (reg < BX_GENERAL_REGISTERS)
+    return BX_CPU(dbg_cpu)->get_reg16(reg);
+
+  dbg_printf("Unknown 16B register [%d] !!!\n", reg);
+  return 0;
+}
+
+Bit32u bx_dbg_get_reg32_value(unsigned reg)
+{
+  if (reg < BX_GENERAL_REGISTERS)
+    return BX_CPU(dbg_cpu)->get_reg32(reg);
+
+  dbg_printf("Unknown 32B register [%d] !!!\n", reg);
+  return 0;
+}
+
+Bit64u bx_dbg_get_reg64_value(unsigned reg)
+{
+#if BX_SUPPORT_X86_64
+  if (reg < BX_GENERAL_REGISTERS)
+    return BX_CPU(dbg_cpu)->get_reg64(reg);
+#endif
+
+  dbg_printf("Unknown 64B register [%d] !!!\n", reg);
+  return 0;
+}
+
+void bx_dbg_set_reg8l_value(unsigned reg, Bit8u value)
+{
+  if (reg < BX_GENERAL_REGISTERS)
+    BX_CPU(dbg_cpu)->set_reg8l(reg, value);
+  else
+    dbg_printf("Unknown 8BL register [%d] !!!\n", reg);
+}
+
+void bx_dbg_set_reg8h_value(unsigned reg, Bit8u value)
+{
+  if (reg < BX_GENERAL_REGISTERS)
+    BX_CPU(dbg_cpu)->set_reg8h(reg, value);
+  else
+    dbg_printf("Unknown 8BH register [%d] !!!\n", reg);
+}
+
+void bx_dbg_set_reg16_value(unsigned reg, Bit16u value)
+{
+  if (reg < BX_GENERAL_REGISTERS)
+    BX_CPU(dbg_cpu)->set_reg16(reg, value);
+  else
+    dbg_printf("Unknown 16B register [%d] !!!\n", reg);
+}
+
+void bx_dbg_set_reg32_value(unsigned reg, Bit32u value)
+{
+  if (reg < BX_GENERAL_REGISTERS)
+    BX_CPU(dbg_cpu)->set_reg32(reg, value);
+  else
+    dbg_printf("Unknown 32B register [%d] !!!\n", reg);
+}
+
+void bx_dbg_set_reg64_value(unsigned reg, Bit64u value)
+{
+#if BX_SUPPORT_X86_64
+  if (reg < BX_GENERAL_REGISTERS)
+    BX_CPU(dbg_cpu)->set_reg64(reg, value);
+  else
+#endif
+    dbg_printf("Unknown 64B register [%d] !!!\n", reg);
+}
+
+Bit16u bx_dbg_get_selector_value(unsigned int seg_no)
+{
+  bx_dbg_sreg_t sreg;
+
+  if (seg_no > 5) {
+    dbg_printf("Error: seg_no out of bounds\n");
+    return 0;
+  }
+  BX_CPU(dbg_cpu)->dbg_get_sreg(&sreg, seg_no);
+  if (!sreg.valid) {
+    dbg_printf("Error: segment valid bit cleared\n");
+    return 0;
+  }
+  return sreg.sel;
+}
+
+Bit16u bx_dbg_get_ip(void)
+{
+  return BX_CPU(dbg_cpu)->get_ip();
+}
+
+Bit32u bx_dbg_get_eip(void)
+{
+  return BX_CPU(dbg_cpu)->get_eip();
+}
+
+bx_address bx_dbg_get_instruction_pointer(void)
+{
+  return BX_CPU(dbg_cpu)->get_instruction_pointer();
+}
+
+bx_bool bx_dbg_read_pmode_descriptor(Bit16u sel, bx_descriptor_t *descriptor)
+{
+  bx_selector_t selector;
+  Bit32u dword1, dword2;
+  bx_address desc_base;
+
+  /* if selector is NULL, error */
+  if ((sel & 0xfffc) == 0) {
+    dbg_printf("bx_dbg_read_pmode_descriptor: Dereferencing a NULL selector!\n");
+    return 0;
+  }
+
+  /* parse fields in selector */
+  parse_selector(sel, &selector);
+
+  if (selector.ti) {
+    // LDT
+    if (((Bit32u)selector.index*8 + 7) > BX_CPU(dbg_cpu)->ldtr.cache.u.segment.limit_scaled) {
+      dbg_printf("bx_dbg_read_pmode_descriptor: selector (0x%04x) > LDT size limit\n", selector.index*8);
+      return 0;
+    }
+    desc_base = BX_CPU(dbg_cpu)->ldtr.cache.u.segment.base;
+  }
+  else {
+    // GDT
+    if (((Bit32u)selector.index*8 + 7) > BX_CPU(dbg_cpu)->gdtr.limit) {
+      dbg_printf("bx_dbg_read_pmode_descriptor: selector (0x%04x) > GDT size limit\n", selector.index*8);
+      return 0;
+    }
+    desc_base = BX_CPU(dbg_cpu)->gdtr.base;
+  }
+
+  if (! bx_dbg_read_linear(dbg_cpu, desc_base + selector.index * 8,     4, (Bit8u*) &dword1)) {
+    dbg_printf("bx_dbg_read_pmode_descriptor: cannot read selector 0x%04x (index=0x%04x)\n", sel, selector.index);
+    return 0;
+  }
+  if (! bx_dbg_read_linear(dbg_cpu, desc_base + selector.index * 8 + 4, 4, (Bit8u*) &dword2)) {
+    dbg_printf("bx_dbg_read_pmode_descriptor: cannot read selector 0x%04x (index=0x%04x)\n", sel, selector.index);
+    return 0;
+  }
+
+  memset (descriptor, 0, sizeof (descriptor));
+  parse_descriptor(dword1, dword2, descriptor);
+
+  if (!descriptor->segment) {
+    dbg_printf("bx_dbg_read_pmode_descriptor: selector 0x%04x points to a system descriptor and is not supported!\n", sel);
+    return 0;
+  }
+
+  /* #NP(selector) if descriptor is not present */
+  if (descriptor->p==0) {
+    dbg_printf("bx_dbg_read_pmode_descriptor: descriptor 0x%04x not present!\n", sel);
+    return 0;
+  }
+
+  return 1;
+}
+
+void bx_dbg_load_segreg(unsigned seg_no, unsigned value)
+{
+  bx_segment_reg_t sreg;
+
+  if (seg_no > 6) {
+    dbg_printf("bx_dbg_load_segreg: unknown segment register !");
+    return;
+  }
+
+  if (value > 0xffff) {
+    dbg_printf("bx_dbg_load_segreg: segment selector out of limits !");
+    return;
+  }
+
+  unsigned cpu_mode = BX_CPU(dbg_cpu)->get_cpu_mode();
+  if (cpu_mode == BX_MODE_LONG_64) {
+    dbg_printf("bx_dbg_load_segreg: not supported in long64 mode !");
+    return;
+  }
+
+  if (! BX_CPU(dbg_cpu)->protected_mode()) {
+    parse_selector(value, &sreg.selector);
+
+    sreg.cache.valid   = SegValidCache;
+    sreg.cache.p       = 1;
+    sreg.cache.dpl     = (cpu_mode == BX_MODE_IA32_V8086);
+    sreg.cache.segment = 1;
+    sreg.cache.type    = BX_DATA_READ_WRITE_ACCESSED;
+
+    sreg.cache.u.segment.base = sreg.selector.value << 4;
+    sreg.cache.u.segment.limit_scaled = 0xffff;
+    sreg.cache.u.segment.g            = 0;
+    sreg.cache.u.segment.d_b          = 0;
+    sreg.cache.u.segment.avl          = 0;
+    sreg.selector.rpl                 = (cpu_mode == BX_MODE_IA32_V8086);
+
+    BX_CPU(dbg_cpu)->dbg_set_sreg(seg_no, &sreg);
+  }
+  else {
+    parse_selector(value, &sreg.selector);
+    if (bx_dbg_read_pmode_descriptor(value, &sreg.cache)) {
+      BX_CPU(dbg_cpu)->dbg_set_sreg(seg_no, &sreg);
+    }
+  }
+}
+
+bx_address bx_dbg_get_laddr(Bit16u sel, bx_address ofs)
+{
+  bx_address laddr;
+
+  if (BX_CPU(dbg_cpu)->protected_mode()) {
+    bx_descriptor_t descriptor;
+    Bit32u lowaddr, highaddr;
+
+    if (! bx_dbg_read_pmode_descriptor(sel, &descriptor))
+      return 0;
+
+    // expand-down
+    if (IS_DATA_SEGMENT(descriptor.type) && IS_DATA_SEGMENT_EXPAND_DOWN(descriptor.type)) {
+      lowaddr = descriptor.u.segment.limit_scaled;
+      highaddr = descriptor.u.segment.g ? 0xffffffff : 0xffff;
+    }
+    else {
+      lowaddr = 0;
+      highaddr = descriptor.u.segment.limit_scaled;
+    }
+
+    if (ofs < lowaddr || ofs > highaddr) {
+      dbg_printf("WARNING: Offset %08X is out of selector %04x limit (%08x...%08x)!\n",
+        ofs, sel, lowaddr, highaddr);
+    }
+
+    laddr = descriptor.u.segment.base + ofs;
+  }
+  else {
+    laddr = sel * 16 + ofs;
+  }
+
+  return laddr;
+}
+
+void bx_dbg_step_over_command()
+{
+  bx_address laddr = BX_CPU(dbg_cpu)->guard_found.laddr;
+
+  if (! bx_dbg_read_linear(dbg_cpu, laddr, 16, bx_disasm_ibuf))
+  {
+    return;
+  }
+
+  x86_insn insn = bx_disassemble.decode(IS_CODE_32(BX_CPU(dbg_cpu)->guard_found.code_32_64),
+      IS_CODE_64(BX_CPU(dbg_cpu)->guard_found.code_32_64),
+      BX_CPU(dbg_cpu)->get_segment_base(BX_SEG_REG_CS),
+      BX_CPU(dbg_cpu)->guard_found.eip, bx_disasm_ibuf, bx_disasm_tbuf);
+
+  unsigned b1 = insn.b1;
+
+  switch(b1) {
+    // Jcc short
+    case 0x70:
+    case 0x71:
+    case 0x72:
+    case 0x73:
+    case 0x74:
+    case 0x75:
+    case 0x76:
+    case 0x77:
+    case 0x78:
+    case 0x79:
+    case 0x7A:
+    case 0x7B:
+    case 0x7C:
+    case 0x7D:
+    case 0x7E:
+    case 0x7F:
+
+    // Jcc near
+    case 0x180:
+    case 0x181:
+    case 0x182:
+    case 0x183:
+    case 0x184:
+    case 0x185:
+    case 0x186:
+    case 0x187:
+    case 0x188:
+    case 0x189:
+    case 0x18A:
+    case 0x18B:
+    case 0x18C:
+    case 0x18D:
+    case 0x18E:
+    case 0x18F:
+
+    // jcxz
+    case 0xE3:
+
+    // retn n
+    case 0xC2:
+    // retn
+    case 0xC3:
+    // retf n
+    case 0xCA:
+    // retf
+    case 0xCB:
+    // iret
+    case 0xCF:
+
+    // jmp near
+    case 0xE9:
+    // jmp far
+    case 0xEA:
+    // jmp short
+    case 0xEB:
+      bx_dbg_stepN_command(dbg_cpu, 1);
+      return;
+    // jmp absolute indirect
+    case 0xFF:
+      switch (insn.nnn) {
+        // near
+        case 4:
+        // far
+        case 5:
+         bx_dbg_stepN_command(dbg_cpu, 1);
+         return;
+      }
+  }
+
+  // calls, ints, loops and so on
+  int BpId = bx_dbg_lbreakpoint_command(bkStepOver, laddr + insn.ilen);
+  if (BpId == -1) {
+    dbg_printf("bx_dbg_step_over_command:: Failed to set lbreakpoint !\n");
+    return;
+  }
+
+  bx_dbg_continue_command();
+
+  if (bx_dbg_del_lbreak(BpId))
+    bx_dbg_breakpoint_changed();
+}
+
+#endif /* if BX_DEBUGGER */
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/config.h.in bochs_py/config.h.in
--- bochs/config.h.in	2010-03-01 13:27:09.000000000 +0100
+++ bochs_py/config.h.in	2010-03-01 13:27:53.000000000 +0100
@@ -636,6 +636,7 @@
 #endif
 
 #define BX_INSTRUMENTATION    0
+#define BX_INSTRUMENTATION_PYTHON_HOOKS    0
 
 // enable BX_DEBUG/BX_ERROR/BX_INFO messages
 #define BX_NO_LOGGING 0
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/configure.in bochs_py/configure.in
--- bochs/configure.in	2010-03-01 13:27:14.000000000 +0100
+++ bochs_py/configure.in	2010-03-01 13:28:01.000000000 +0100
@@ -56,7 +56,7 @@
     fi
     ;;
   *-macosx* | *-darwin*)
-    ADD_FLAGS="-fpascal-strings -fno-common -Wno-four-char-constants -Wno-unknown-pragmas -Dmacintosh"      # required for macosx compile
+    ADD_FLAGS="-fpascal-strings -fno-common -arch i386 -Wno-four-char-constants -Wno-unknown-pragmas -Dmacintosh"      # required for macosx compile
     DEFAULT_GUI=carbon                # default to carbon
     need_dlcompat_for_plugins=1
     ;;
@@ -1228,6 +1228,13 @@
 
 INSTRUMENT_DIR='instrument/stubs'
 
+
+PYTHON=
+PYTHON_VERSION=
+PYTHON_INCLUDES=
+PYTHON_LIB=
+BX_DEBUGGER=dbg_main
+
 AC_MSG_CHECKING(for instrumentation support)
 AC_ARG_ENABLE(instrumentation,
   [  --enable-instrumentation          compile in support for instrumentation],
@@ -1239,6 +1246,81 @@
     AC_MSG_RESULT(no)
     AC_DEFINE(BX_INSTRUMENTATION, 0)
     INSTRUMENT_VAR=''
+   elif test "$enableval" = python_hooks; then
+    AC_MSG_RESULT(yes)
+    AC_DEFINE(BX_INSTRUMENTATION, 1)
+    AC_DEFINE(BX_INSTRUMENTATION_PYTHON_HOOKS, 1)
+
+    dnl
+    dnl check for python
+    dnl
+    
+    AC_ARG_WITH(python, [  --with-python[=DIR]    Build Python bindings if found])
+
+    # We always need Python for this to work
+    if test "$with_python" == "no" ; then
+        AC_MSG_ERROR(Python support cannot be disabled if the Python Hooking instrumentation is enabled)
+    fi
+    
+    if test "$with_python" != "no" ; then
+        if test -x "$with_python/bin/python"
+        then
+            echo Found python in $with_python/bin/python
+            PYTHON="$with_python/bin/python"
+        else
+        if test -x "$with_python"
+        then
+            echo Found python in $with_python
+            PYTHON="$with_python"
+        else
+            AC_PATH_PROG(PYTHON, python python2.3 python2.2 python2.1 python2.0 python1.6 python1.5)
+            with_python=`dirname $PYTHON`
+            with_python=`dirname $with_python`
+        fi
+        fi
+        if test "$PYTHON" != ""
+        then
+            PYTHON_VERSION=`$PYTHON -c "import sys; print sys.version[[0:3]]"`
+            echo Found Python version $PYTHON_VERSION
+        
+            # Guess PYTHON_LIB
+            if test `uname` = Darwin; then
+                if $PYTHON -c 'import sys, string; sys.exit(string.find(sys.prefix,"Framework")+1)'; then
+                    PYTHON_LIB="-lpython$PYTHON_VERSION instrument/python_hooks/interpreter.o"
+                else
+                    PYTHON_LIB="-framework Python instrument/python_hooks/interpreter.o"
+                fi
+            else
+                PYTHON_LIB="-lpython$PYTHON_VERSION instrument/python_hooks/interpreter.o"
+            fi
+            echo Set PYTHON_LIB to $PYTHON_LIB
+        fi
+            
+        if test "$PYTHON_VERSION" != ""
+        then
+        if test -r $with_python/include/python$PYTHON_VERSION/Python.h -a \
+           -d $with_python/lib/python$PYTHON_VERSION/site-packages
+        then
+            PYTHON_INCLUDES=$with_python/include/python$PYTHON_VERSION
+        else
+            if test -r $prefix/include/python$PYTHON_VERSION/Python.h
+            then
+                PYTHON_INCLUDES='$(prefix)/include/python$(PYTHON_VERSION)'
+            else
+            if test -r /usr/include/python$PYTHON_VERSION/Python.h
+            then
+                PYTHON_INCLUDES=/usr/include/python$PYTHON_VERSION
+            else
+                echo could not find python$PYTHON_VERSION/Python.h
+            fi
+            fi
+        fi
+        fi
+    fi
+
+    INSTRUMENT_DIR='instrument/python_hooks'
+    INSTRUMENT_VAR='$(INSTRUMENT_LIB)'
+    BX_DEBUGGER=dbg_python
    else
     AC_MSG_RESULT(yes)
     AC_DEFINE(BX_INSTRUMENTATION, 1)
@@ -1253,6 +1335,10 @@
   )
 AC_SUBST(INSTRUMENT_DIR)
 AC_SUBST(INSTRUMENT_VAR)
+AC_SUBST(PYTHON_INCLUDES)
+AC_SUBST(PYTHON_LIB)
+AC_SUBST(BX_DEBUGGER)
+
 
 dnl // serial mode 'socket' needs wsock32.dll in non-plugin mode
 if test "$bx_plugins" = 0; then
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/cpu/Makefile.in bochs_py/cpu/Makefile.in
--- bochs/cpu/Makefile.in	2010-02-22 19:36:36.000000000 +0100
+++ bochs_py/cpu/Makefile.in	2010-02-22 19:35:39.000000000 +0100
@@ -37,7 +37,7 @@
 
 
 
-BX_INCDIRS = -I.. -I$(srcdir)/.. -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@
+BX_INCDIRS = -I.. -I$(srcdir)/.. -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@ -I@PYTHON_INCLUDES@
 
 # Objects which are synced between the cpu and cpu64 code and
 # are used for either compile.
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/fpu/Makefile.in bochs_py/fpu/Makefile.in
--- bochs/fpu/Makefile.in	2010-02-22 19:36:37.000000000 +0100
+++ bochs_py/fpu/Makefile.in	2010-02-22 19:35:41.000000000 +0100
@@ -39,7 +39,7 @@
 L_TARGET = libfpu.a
 
 
-BX_INCDIRS = -I.. -I$(srcdir)/.. -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@ -I. -I$(srcdir)/. -I./stubs -I$(srcdir)/./stubs
+BX_INCDIRS = -I.. -I$(srcdir)/.. -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@ -I. -I$(srcdir)/. -I./stubs -I$(srcdir)/./stubs -I@PYTHON_INCLUDES@
 
 OBJS = ferr.o fpu.o fpu_arith.o fpu_compare.o fpu_const.o \
                fpu_load_store.o fpu_misc.o fpu_trans.o fpu_tags.o \
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/gui/Makefile.in bochs_py/gui/Makefile.in
--- bochs/gui/Makefile.in	2010-02-22 19:36:37.000000000 +0100
+++ bochs_py/gui/Makefile.in	2010-02-22 19:35:41.000000000 +0100
@@ -49,7 +49,7 @@
 top_builddir    = ..
 LIBTOOL=@LIBTOOL@
 WIN32_DLL_IMPORT_LIBRARY=../dllexports.a
-BX_INCDIRS = -I.. -I$(srcdir)/.. -I../iodev -I$(srcdir)/../iodev -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@
+BX_INCDIRS = -I.. -I$(srcdir)/.. -I../iodev -I$(srcdir)/../iodev -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@ -I@PYTHON_INCLUDES@
 
 GUI_OBJS_X11  = x.o
 GUI_OBJS_SDL = sdl.o
Binary files bochs/instrument/.DS_Store and bochs_py/instrument/.DS_Store differ
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/instrument/python_hooks/Makefile.in bochs_py/instrument/python_hooks/Makefile.in
--- bochs/instrument/python_hooks/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ bochs_py/instrument/python_hooks/Makefile.in	2009-08-07 04:08:13.000000000 +0200
@@ -0,0 +1,81 @@
+# Copyright (C) 2001  MandrakeSoft S.A.
+#
+#   MandrakeSoft S.A.
+#   43, rue d'Aboukir
+#   75002 Paris - France
+#   http://www.linux-mandrake.com/
+#   http://www.mandrakesoft.com/
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+
+@SUFFIX_LINE@
+
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+SHELL = /bin/sh
+
+@SET_MAKE@
+
+CC = @CC@
+CFLAGS = @CFLAGS@
+CXX = @CXX@
+CXXFLAGS = @CXXFLAGS@
+
+LDFLAGS = @LDFLAGS@
+LIBS = @LIBS@
+RANLIB = @RANLIB@
+
+
+# ===========================================================
+# end of configurable options
+# ===========================================================
+
+
+BX_OBJS = \
+  instrument.o interpreter.o
+
+BX_INCLUDES = 
+
+BX_INCDIRS = -I../.. -I$(srcdir)/../.. -I. -I$(srcdir)/. -I@PYTHON_INCLUDES@
+
+.@CPP_SUFFIX@.o:
+	$(CXX) -c $(CXXFLAGS) $(BX_INCDIRS) @CXXFP@$< @OFP@$@
+
+
+.c.o:
+	$(CXX) -c $(CFLAGS) $(BX_INCDIRS) @CFP@$< @OFP@$@
+
+
+
+libinstrument.a: $(BX_OBJS)
+	@RMCOMMAND@ libinstrument.a
+	@MAKELIB@ $(BX_OBJS)
+	$(RANLIB) libinstrument.a
+
+$(BX_OBJS): $(BX_INCLUDES)
+
+
+clean:
+	@RMCOMMAND@ *.o
+	@RMCOMMAND@ *.a
+
+dist-clean: clean
+	@RMCOMMAND@ Makefile
+
+
+instrument.o: instrument.@CPP_SUFFIX@ ../../bochs.h ../../config.h
+interpreter.o: interpreter.@CPP_SUFFIX@ ../../bochs.h ../../config.h
\ No newline at end of file
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/instrument/python_hooks/instrument.cc bochs_py/instrument/python_hooks/instrument.cc
--- bochs/instrument/python_hooks/instrument.cc	1970-01-01 01:00:00.000000000 +0100
+++ bochs_py/instrument/python_hooks/instrument.cc	2010-02-24 11:43:34.000000000 +0100
@@ -0,0 +1,939 @@
+/////////////////////////////////////////////////////////////////////////
+// $Id: instrument.cc,v 1.13.2.1 2005/07/08 07:17:06 vruppert Exp $
+/////////////////////////////////////////////////////////////////////////
+//
+//  Copyright (C) 2001  MandrakeSoft S.A.
+//
+//    MandrakeSoft S.A.
+//    43, rue d'Aboukir
+//    75002 Paris - France
+//    http://www.linux-mandrake.com/
+//    http://www.mandrakesoft.com/
+//
+//  This library is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU Lesser General Public
+//  License as published by the Free Software Foundation; either
+//  version 2 of the License, or (at your option) any later version.
+//
+//  This library is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//  Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public
+//  License along with this library; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+
+
+#include "bochs.h"
+#include "cpu/cpu.h"
+#include "instrument.h"
+#include "interpreter.h"
+
+#ifndef Py_RETURN_NONE
+    #define Py_RETURN_NONE  {Py_INCREF(Py_None); return Py_None;}
+#endif
+
+#define MAX_CR3_FILTERS     128
+
+bx_bool    CR3_filter_active = 0;
+bx_address CR3_filter[MAX_CR3_FILTERS];
+
+
+PyObject *pCallbacks[INSTR_CALLBACK_COUNT] = {
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL  };
+
+const char *callback_strings[] = {
+
+    "INSTR_INIT_ENV",
+    "INSTR_EXIT_ENV",
+
+    "INSTR_INITIALIZE",
+    "INSTR_EXIT",
+    "INSTR_RESET",
+    "INSTR_HLT",
+    "INSTR_MWAIT",
+    "INSTR_NEW_INSTRUCTION",
+
+    /*
+    "INSTR_DEBUG_PROMPT",
+    */
+    //"INSTR_DEBUG_CMD",
+
+    "INSTR_CNEAR_BRANCH_TAKEN",
+    "INSTR_CNEAR_BRANCH_NOT_TAKEN",
+    "INSTR_UCNEAR_BRANCH",
+    "INSTR_FAR_BRANCH",
+
+    "INSTR_OPCODE",
+    "INSTR_EXCEPTION",
+    "INSTR_INTERRUPT",
+    "INSTR_HWINTERRUPT",
+
+    "INSTR_CLFLUSH",
+    "INSTR_CACHE_CNTRL",
+    "INSTR_TLB_CNTRL",
+    "INSTR_PREFETCH_HINT",
+
+    "INSTR_BEFORE_EXECUTION",
+    "INSTR_AFTER_EXECUTION",
+    "INSTR_REPEAT_ITERATION",
+
+    "INSTR_LIN_ACCESS",
+    "INSTR_MEM_DATA_ACCESS",
+    "INSTR_PHY_READ",
+    "INSTR_PHY_WRITE",
+
+    "INSTR_INP",
+    "INSTR_INP2",
+    "INSTR_OUTP",
+    
+    "INSTR_WRMSR",
+
+    "INSTR_CALLBACK_COUNT"
+};
+
+
+
+// Read and output any data which Python code
+// might have written to stdout or stderr.
+
+void bochs_process_std(PyObject *source)
+{
+    PyObject *std_data;
+    char *std_str;
+
+	std_data = PyObject_GetAttrString(source, "data");
+	std_str = PyString_AsString(std_data);
+	
+	if(strlen(std_str)>0) {
+        dbg_printf("bochs-python: error:\n%s\n", std_str);
+        Py_DECREF(std_data);
+        PyObject_SetAttrString(source, "data", PyString_FromString(""));
+    }
+}
+
+
+
+// Handle errors in the input. If the error is a syntax
+// error it might be due to incomplete input. That's
+// checked for and if so, more input is requested.
+
+int bochs_handle_error(void)
+{
+	PyObject *err;
+	PyObject *exc_type, *exc_value, *exc_traceback;
+	char *exc_text, *exc_input_file, *exc_input;
+	int exc_err_line, exc_err_column, exc_input_length;
+	int return_value = ERROR_NONE;
+
+    // Write all the output generated before the error.
+    // The error might have occurred, for instance, in
+    // a loop after running several times and printing
+    // some results after each repetition.
+    bochs_process_std(interpreter_state->capture_stdout);
+    bochs_process_std(interpreter_state->capture_stderr);
+
+    // Has an error occured?
+    err = PyErr_Occurred();
+    if(err) {
+    
+        // If so, is the exception a SyntaxError one?
+        if(PyErr_GivenExceptionMatches(PyExc_SyntaxError, err)) {
+        
+            // Get the details of the SyntaxError
+            PyErr_Fetch(&exc_type, &exc_value, &exc_traceback);
+            
+            if(exc_type) {
+                if(exc_value) {
+                
+                    //printf("[%s]\n",
+                    //    PyString_AsString(PyObject_Repr(exc_value)));
+                    
+                    // Parse the SyntaxError exception information.
+                    
+                    PyArg_ParseTuple(exc_value, "s(siis#)",
+                        &exc_text, &exc_input_file, &exc_err_line,
+                        &exc_err_column, &exc_input, &exc_input_length);
+                        
+                    //printf("%d %d %d\n",
+                    //    exc_err_line, exc_err_column, exc_input_length);
+                    
+                    // Free the unneeded references.
+                    Py_XDECREF(exc_type);
+                    Py_XDECREF(exc_value);
+                    Py_XDECREF(exc_traceback);
+                    
+                    // If the SyntaxError is indicated in the
+                    // last character/column of input, it means
+                    // the Python compiler expected more code to
+                    // follow, we indicate so; so more input can
+                    // be requested.
+                    
+                    if(exc_input_length==exc_err_column)
+                        return_value = ERROR_INCOMPLETE_INPUT;
+                    else
+                        return_value = ERROR_SYNTAX_ERROR;
+                }
+            }
+        } else {
+            // Other exeception than a SyntaxError occurred.
+            // The information is written to stdout.
+            PyErr_Print();
+            bochs_process_std(interpreter_state->capture_stderr);
+            return_value = ERROR_OTHER;
+        }
+    }
+    
+    return return_value;
+}
+
+
+
+int get_long_from_python_object(PyObject *pObj, bx_address *val)
+{
+    if(PyLong_Check(pObj))
+        *val = (bx_address)PyLong_AsLong(pObj);
+    else if(PyInt_Check(pObj))
+        *val = (bx_address)PyInt_AsLong(pObj);
+    else
+        return 0;
+        
+    return 1;
+}
+
+// Filter to only run python callbacks when the CR3 register matches the filter.
+//
+PyObject *set_filter_cr3(PyObject *self, PyObject *args)
+{
+    PyObject *pCR3_filter;
+    bx_address addr;
+    int idx;
+	
+    if(!PyArg_ParseTuple(args, "O", &pCR3_filter)) {
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+    
+    if( pCR3_filter == Py_None) {
+    
+        CR3_filter_active = 0;
+        memset(CR3_filter, 0, sizeof(CR3_filter));
+        dbg_printf("set_filter_cr3: CR3 filter removed\n");
+        
+    } else {
+    
+        if( get_long_from_python_object(pCR3_filter, &addr) ) {
+        
+            CR3_filter[0] = addr;
+            
+            dbg_printf("set_filter_cr3: will filter for CR3 = 0x%08x\n", CR3_filter[0]);
+        }
+        
+        else if(PySequence_Check(pCR3_filter)) {
+            
+            memset(CR3_filter, 0, sizeof(CR3_filter));
+            
+            if(PySequence_Size(pCR3_filter)>MAX_CR3_FILTERS)
+                dbg_printf("set_filter_cr3: warning, list longer than "
+                    "maximum accepted CR3 filter address, only the first "
+                    "%d will be set\n", MAX_CR3_FILTERS);
+            
+            for(idx=0;
+                idx<PySequence_Length(pCR3_filter) && idx<MAX_CR3_FILTERS;
+                idx++) {
+            
+                    if( get_long_from_python_object(
+                            PySequence_GetItem(pCR3_filter, idx), &addr) ) {
+                            
+                        CR3_filter[idx] = addr;
+                        dbg_printf("set_filter_cr3: will filter for "
+                            "CR3 = 0x%08x\n", CR3_filter[idx]);
+                            
+                    } else {
+                        dbg_printf("set_filter_cr3: Invalid arguments, "
+                            "object at index %d must be long or integer\n", idx);
+                        memset(CR3_filter, 0, sizeof(CR3_filter));
+                        break;
+                    }
+                }
+
+        }
+        else {
+            dbg_printf("set_filter_cr3: Invalid arguments, "
+                "must be long, integer or a list of them\n");
+            Py_RETURN_NONE;
+        }
+
+        CR3_filter_active = 1;
+    }
+        
+    Py_RETURN_NONE;
+}
+
+
+PyObject *set_callback(PyObject *self, PyObject *args)
+{
+	Bit32u callback_idx;
+    PyObject *callback;
+	
+    if(!PyArg_ParseTuple(args, "IO", &callback_idx, &callback)) {
+        bochs_handle_error();
+        Py_RETURN_NONE;
+    }
+    
+    dbg_printf("set_callback: setting callback %d\n", callback_idx);
+    
+    if(callback_idx<0 || callback_idx>=INSTR_CALLBACK_COUNT)
+        Py_RETURN_NONE;
+
+    if(callback==Py_None) {
+        pCallbacks[callback_idx] = NULL;
+    }
+    else {
+        pCallbacks[callback_idx] = callback;
+    }
+    
+    Py_RETURN_NONE;
+}
+
+
+void call_python_callback(PyObject *callback, PyObject *args)
+{
+    PyObject *result;
+    
+    /*
+     * The args can actually be Null for a function with none of them
+     * hence I commented this check out.
+    */
+    
+    /* 
+    if(!args) {
+        dbg_printf("call_python_callback: Invalid arguments\n");
+        bochs_handle_error();
+        return;
+    }
+    */
+        
+    if(PyCallable_Check(callback)) {
+        result = PyObject_CallObject(callback, args);
+        if(result == NULL)
+            bochs_handle_error();
+        else
+            Py_DECREF(result);
+    }
+    else
+        dbg_printf("call_python_callback: callback not callable\n");
+}
+
+
+void instr_callback(int callback_idx, unsigned cpu, ...)
+{
+    va_list ap;
+    va_start(ap, cpu);
+    
+    unsigned    arg_unsg_1, arg_unsg_2, arg_unsg_3, arg_unsg_4;
+    bx_address  arg_addr_1, arg_addr_2, arg_addr_3, arg_addr_4;
+    bx_bool     bool_is32, bool_is64;
+    Bit8u       *arg_bit8, arg_bit8_1;
+    Bit32u      arg_Bit32u;
+    Bit64u      arg_bit64_1;
+    PyObject    *arglist, *obj, *instruction_dict, *metainfo_dict;
+    int         idx;
+    unsigned int cr3_reg;
+    bxInstruction_c *instruction;
+
+    // Callback not set
+    if(!pCallbacks[callback_idx]) {
+        va_end(ap);
+        return;
+    }
+        
+    // If the CR3 filter is set and the register doesn't match the filter, do nothing.
+    // Otherwise proceed as usual.
+    // EXCEPT when the instrumentation being called is for global events such as a reset.
+    // Those should bypass the CR3 filter.
+    //
+    if( CR3_filter_active && (
+        callback_idx!=INSTR_INIT_ENV &&
+        callback_idx!=INSTR_EXIT_ENV &&
+        callback_idx!=INSTR_INITIALIZE &&
+        callback_idx!=INSTR_EXIT &&
+        callback_idx!=INSTR_RESET &&
+        callback_idx!=INSTR_HLT &&
+        callback_idx!=INSTR_MWAIT)
+        ) {
+    
+        cr3_reg = BX_CPU(cpu)->cr3;
+        
+        // Scan the filter list for a cr3 value to track
+        //
+        for( idx = 0; idx<MAX_CR3_FILTERS && CR3_filter[idx]!=0; idx++)
+            if( CR3_filter[idx] == cr3_reg )
+                break;
+          
+        // If no value was found, i.e. the list was scanned up to the end
+        // then return
+        if(idx==MAX_CR3_FILTERS || CR3_filter[idx]==0)
+            return;
+    }
+        
+    switch(callback_idx) {
+    
+        case INSTR_CNEAR_BRANCH_TAKEN:
+                        
+            arg_addr_1 = va_arg(ap, bx_address); // new_eip
+
+#if BX_SUPPORT_X86_64
+            arglist = Py_BuildValue("(kK)", cpu, arg_addr_1);
+#else
+            arglist = Py_BuildValue("(kk)", cpu, arg_addr_1);
+#endif
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                    
+            break;
+
+        case INSTR_UCNEAR_BRANCH:
+        
+            arg_unsg_1 = va_arg(ap, unsigned); // what
+            arg_addr_1 = va_arg(ap, bx_address); // new_eip
+
+#if BX_SUPPORT_X86_64
+            arglist = Py_BuildValue("(kkK)", cpu, arg_unsg_1, arg_addr_1);
+#else
+            arglist = Py_BuildValue("(kkk)", cpu, arg_unsg_1, arg_addr_1);
+#endif
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                    
+            break;
+
+        case INSTR_FAR_BRANCH:
+        
+            arg_unsg_1 = va_arg(ap, unsigned); // what
+            arg_unsg_2 = va_arg(ap, unsigned); // new_cs
+            arg_addr_1 = va_arg(ap, bx_address); // new_eip
+
+#if BX_SUPPORT_X86_64
+            arglist = Py_BuildValue("(kkkK)",
+                    cpu, arg_unsg_1, arg_unsg_2, arg_addr_1);
+#else
+            arglist = Py_BuildValue("(kkkk)",
+                    cpu, arg_unsg_1, arg_unsg_2, arg_addr_1);
+#endif
+                    
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                    
+            break;
+
+        case INSTR_EXCEPTION:
+                        
+            arg_unsg_1 = va_arg(ap, unsigned); // vector
+            arg_unsg_2 = va_arg(ap, unsigned); // error_code
+
+            arglist = Py_BuildValue("(kkk)", cpu, arg_unsg_1, arg_unsg_2);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                    
+            break;
+
+        case INSTR_INTERRUPT:
+
+            arg_unsg_1 = va_arg(ap, unsigned); // vector
+
+            arglist = Py_BuildValue("(kk)", cpu, arg_unsg_1);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+
+            break;
+
+        case INSTR_LIN_ACCESS:
+        
+            // cpu_id, lin, phy, len, rw
+            arg_addr_1 = va_arg(ap, bx_address); // linear address
+            arg_addr_2 = va_arg(ap, bx_address); // physical address
+            arg_unsg_1 = va_arg(ap, unsigned); // length
+            arg_unsg_2 = va_arg(ap, unsigned); // rw
+
+#if BX_SUPPORT_X86_64
+            arglist = Py_BuildValue("(kKKkk)",
+                    cpu, arg_addr_1, arg_addr_2, arg_unsg_1, arg_unsg_2);
+#else
+            arglist = Py_BuildValue("(kkkkk)",
+                    cpu, arg_addr_1, arg_addr_2, arg_unsg_1, arg_unsg_2);
+#endif
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                    
+            break;
+
+        case INSTR_MEM_DATA_ACCESS:
+        
+            //cpu_id, seg, offset, len, rw
+            arg_unsg_1 = va_arg(ap, unsigned); // segment
+            arg_unsg_2 = va_arg(ap, unsigned); // offset
+            arg_unsg_3 = va_arg(ap, unsigned); // length
+            arg_unsg_4 = va_arg(ap, unsigned); // rw
+
+            arglist = Py_BuildValue("(kkkkk)",
+                    cpu, arg_unsg_1, arg_unsg_2, arg_unsg_3, arg_unsg_4);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+
+            break;
+
+        case INSTR_MWAIT:
+
+            arg_addr_1 = va_arg(ap, bx_address); // linear address
+            arg_unsg_1 = va_arg(ap, unsigned); // length
+            arg_unsg_2 = va_arg(ap, unsigned); // flags
+
+#if BX_SUPPORT_X86_64
+            arglist = Py_BuildValue("(kKkk)",
+                    cpu, arg_addr_1, arg_unsg_1, arg_unsg_2);
+#else
+            arglist = Py_BuildValue("(kkkk)",
+                    cpu, arg_addr_1, arg_unsg_1, arg_unsg_2);
+#endif
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                    
+            break;
+
+        case INSTR_OPCODE:
+        
+
+            arg_bit8 = (Bit8u *) va_arg(ap, Bit8u *); // opcode
+            arg_unsg_1 = va_arg(ap, unsigned); // len
+            bool_is32 = va_arg(ap, bx_bool); // is32
+            bool_is64 = va_arg(ap, bx_bool); // is64
+
+            arglist = Py_BuildValue("(ks#kk)",
+                    cpu, arg_bit8, arg_unsg_1, arg_addr_2,
+                    (unsigned long)bool_is32, (unsigned long)bool_is32);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                    
+            break;
+
+
+        case INSTR_BEFORE_EXECUTION:
+        case INSTR_AFTER_EXECUTION:
+        case INSTR_REPEAT_ITERATION:
+        
+            instruction = va_arg(ap, bxInstruction_c *); // bxInstruction_c
+            
+            instruction_dict = PyDict_New();
+            
+            // Wrap the metaInfo struct
+            //
+            metainfo_dict = PyDict_New();
+            
+            obj = PyLong_FromLong((unsigned) instruction->metaInfo.metaInfo1);
+            PyDict_SetItemString(metainfo_dict, "metaInfo1", obj);
+            Py_DECREF(obj);
+            
+            obj = PyLong_FromLong((unsigned) instruction->metaInfo.metaInfo2);
+            PyDict_SetItemString(metainfo_dict, "metaInfo2", obj);
+            Py_DECREF(obj);
+            /*
+            obj = PyLong_FromLong((unsigned) instruction->metaInfo.metaInfo3);
+            PyDict_SetItemString(metainfo_dict, "metaInfo3", obj);
+            Py_DECREF(obj);
+            
+            obj = PyLong_FromLong((unsigned) instruction->metaInfo.metaInfo4);
+            PyDict_SetItemString(metainfo_dict, "metaInfo4", obj);
+            Py_DECREF(obj);
+            */
+            
+            PyDict_SetItemString(instruction_dict, "metaInfo", metainfo_dict);
+            Py_DECREF(metainfo_dict);
+            
+            
+            // Wrap the metaData array
+            //
+
+            obj = PyString_FromStringAndSize((const char *) instruction->metaData, 8);
+            PyDict_SetItemString(instruction_dict, "metaData", obj);
+            Py_DECREF(obj);
+            
+
+            // Wrap the modRMForm/IxIxForm union
+            //
+
+            obj = PyLong_FromLong((long) instruction->modRMForm.Id);
+            PyDict_SetItemString(instruction_dict, "modRMForm_Id", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->modRMForm.Iw);
+            PyDict_SetItemString(instruction_dict, "modRMForm_Iw", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->modRMForm.Ib);
+            PyDict_SetItemString(instruction_dict, "modRMForm_Ib", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->modRMForm.displ16u);
+            PyDict_SetItemString(instruction_dict, "modRMForm_displ16u", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->modRMForm.displ32u);
+            PyDict_SetItemString(instruction_dict, "modRMForm_displ32u", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->IxIxForm.Id);
+            PyDict_SetItemString(instruction_dict, "IxIxForm_Id", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->IxIxForm.Iw);
+            PyDict_SetItemString(instruction_dict, "IxIxForm_Iw", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->IxIxForm.Ib);
+            PyDict_SetItemString(instruction_dict, "IxIxForm_Ib", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->IxIxForm.Id2);
+            PyDict_SetItemString(instruction_dict, "IxIxForm_Id2", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->IxIxForm.Iw2);
+            PyDict_SetItemString(instruction_dict, "IxIxForm_Iw2", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->IxIxForm.Ib2);
+            PyDict_SetItemString(instruction_dict, "IxIxForm_Ib2", obj);
+            Py_DECREF(obj);
+            
+            
+#if BX_SUPPORT_X86_64
+            obj = PyLong_FromLong((long) instruction->IqForm.Iq);
+            PyDict_SetItemString(instruction_dict, "IqForm_Iq", obj);
+            Py_DECREF(obj);
+
+#endif
+
+
+            // Wrap bxInstruction_c's methods
+            //
+
+            obj = PyLong_FromLong((long) instruction->modC0());
+            PyDict_SetItemString(instruction_dict, "modC0", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->opcodeReg());
+            PyDict_SetItemString(instruction_dict, "opcodeReg", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->modrm());
+            PyDict_SetItemString(instruction_dict, "modrm", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->nnn());
+            PyDict_SetItemString(instruction_dict, "nnn", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->rm());
+            PyDict_SetItemString(instruction_dict, "rm", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->sibScale());
+            PyDict_SetItemString(instruction_dict, "sibScale", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->sibIndex());
+            PyDict_SetItemString(instruction_dict, "sibIndex", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->sibBase());
+            PyDict_SetItemString(instruction_dict, "sibBase", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->displ32s());
+            PyDict_SetItemString(instruction_dict, "displ32s", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->displ16s());
+            PyDict_SetItemString(instruction_dict, "displ16s", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->Id());
+            PyDict_SetItemString(instruction_dict, "Id", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->Iw());
+            PyDict_SetItemString(instruction_dict, "Iw", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->Ib());
+            PyDict_SetItemString(instruction_dict, "Ib", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->Iw2());
+            PyDict_SetItemString(instruction_dict, "Iw2", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->Ib2());
+            PyDict_SetItemString(instruction_dict, "Ib2", obj);
+            Py_DECREF(obj);
+
+#if BX_SUPPORT_X86_64
+            obj = PyLong_FromLongLong((long) instruction->Iq());
+            PyDict_SetItemString(instruction_dict, "Iq", obj);
+            Py_DECREF(obj);
+
+#endif
+            obj = PyLong_FromLong((long) instruction->seg());
+            PyDict_SetItemString(instruction_dict, "seg", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->os32L());
+            PyDict_SetItemString(instruction_dict, "os32L", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->as32L());
+            PyDict_SetItemString(instruction_dict, "as32L", obj);
+            Py_DECREF(obj);
+
+#if BX_SUPPORT_X86_64
+            obj = PyLong_FromLong((long) instruction->os64L());
+            PyDict_SetItemString(instruction_dict, "os64L", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->as64L());
+            PyDict_SetItemString(instruction_dict, "as64L", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->extend8bitL());
+            PyDict_SetItemString(instruction_dict, "extend8bitL", obj);
+            Py_DECREF(obj);
+
+#else
+            obj = PyLong_FromLong((long) 0);
+            PyDict_SetItemString(instruction_dict, "os64L", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) 0);
+            PyDict_SetItemString(instruction_dict, "as64L", obj);
+            Py_DECREF(obj);
+
+#endif
+
+            obj = PyLong_FromLong((long) instruction->ilen());
+            PyDict_SetItemString(instruction_dict, "ilen", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->repUsedL());
+            PyDict_SetItemString(instruction_dict, "repUsedL", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->repUsedValue());
+            PyDict_SetItemString(instruction_dict, "repUsedValue", obj);
+            Py_DECREF(obj);
+
+            obj = PyLong_FromLong((long) instruction->b1());
+            PyDict_SetItemString(instruction_dict, "b1", obj);
+            Py_DECREF(obj);
+
+            arglist = Py_BuildValue("(kO)",
+                    cpu, instruction_dict);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                    
+            break;
+
+
+        case INSTR_PHY_WRITE:
+        case INSTR_PHY_READ:
+        
+            arg_addr_1 = va_arg(ap, bx_address); // physical address
+            arg_unsg_1 = va_arg(ap, unsigned); // legnth
+            
+#if BX_SUPPORT_X86_64
+            arglist = Py_BuildValue("(kKk)",
+                    cpu, arg_addr_1, arg_unsg_1);
+#else
+            arglist = Py_BuildValue("(kkk)",
+                    cpu, arg_addr_1, arg_unsg_1);
+#endif
+                    
+             call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                            
+            break;
+                        
+        case INSTR_INIT_ENV:
+        case INSTR_EXIT_ENV:
+            
+            call_python_callback(
+                pCallbacks[callback_idx], NULL);
+            Py_DECREF(arglist);
+            
+            break;
+            
+        case INSTR_INITIALIZE:
+        case INSTR_EXIT:
+        case INSTR_HLT:
+        case INSTR_NEW_INSTRUCTION:
+        case INSTR_CNEAR_BRANCH_NOT_TAKEN:
+        
+            arglist = Py_BuildValue("(k)", cpu);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+
+            break;
+            
+        case INSTR_HWINTERRUPT:
+        
+            arg_unsg_1 = va_arg(ap, unsigned); // vector
+            arg_unsg_2 = va_arg(ap, unsigned); // cs
+            arg_addr_1 = va_arg(ap, bx_address); // eip
+
+#if BX_SUPPORT_X86_64
+            arglist = Py_BuildValue("(kkkK)",
+                    cpu, arg_unsg_1, arg_unsg_2, arg_addr_1);
+#else
+            arglist = Py_BuildValue("(kkkk)",
+                    cpu, arg_unsg_1, arg_unsg_2, arg_addr_1);
+#endif
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                            
+            break;
+
+
+        case INSTR_INP:
+        case INSTR_RESET: // Reset takes the type (software/hardware) as 2nd arg
+        
+            arg_addr_1 = (Bit16u)cpu;   // addr
+            arg_unsg_1 = va_arg(ap, unsigned); // len
+
+            arglist = Py_BuildValue("(Hk)",
+                    arg_addr_1, arg_unsg_1);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                            
+            break;
+
+
+        case INSTR_INP2:
+        case INSTR_OUTP:
+        
+            arg_addr_1 = (Bit16u)cpu;
+            arg_unsg_1 = va_arg(ap, unsigned); // len
+            arg_unsg_2 = va_arg(ap, Bit32u); // val
+
+            arglist = Py_BuildValue("(Hkk)",
+                    arg_addr_1, arg_unsg_1, arg_unsg_2);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                            
+            break;
+
+
+        case INSTR_WRMSR:
+        
+            arg_unsg_1 = va_arg(ap, unsigned); // addr
+            arg_bit64_1 = va_arg(ap, Bit64u); // value
+
+#if BX_SUPPORT_X86_64
+#else
+#endif
+            arglist = Py_BuildValue("(kkK)",
+                    cpu, arg_unsg_1, arg_bit64_1);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                            
+            break;
+            
+
+        case INSTR_CACHE_CNTRL:
+        
+            arg_unsg_1 = va_arg(ap, unsigned); // what
+
+            arglist = Py_BuildValue("(kk)", cpu, arg_unsg_1);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                            
+            break;
+            
+
+        case INSTR_TLB_CNTRL:
+        
+            arg_unsg_1 = va_arg(ap, unsigned); // what
+            arg_Bit32u = va_arg(ap, Bit32u); // new_cr3
+
+            arglist = Py_BuildValue("(kkk)",
+                cpu, arg_unsg_1, arg_Bit32u);
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                            
+            break;
+
+
+        case INSTR_PREFETCH_HINT:
+        
+            arg_unsg_1 = va_arg(ap, unsigned); // what
+            arg_unsg_2 = va_arg(ap, unsigned); // seg
+            arg_addr_1 = va_arg(ap, bx_address); // offset
+
+#if BX_SUPPORT_X86_64
+            arglist = Py_BuildValue("(kkkK)",
+                    cpu, arg_unsg_1, arg_unsg_2, arg_addr_1);
+#else
+            arglist = Py_BuildValue("(kkkk)",
+                    cpu, arg_unsg_1, arg_unsg_2, arg_addr_1);
+#endif
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+                            
+            break;
+
+        case INSTR_CLFLUSH:
+
+            arg_addr_1 = va_arg(ap, bx_address); // laddr
+            arg_addr_2 = va_arg(ap, bx_address); // paddr
+
+#if BX_SUPPORT_X86_64
+            arglist = Py_BuildValue("(kKK)",
+                cpu, arg_unsg_1, arg_unsg_2, arg_addr_1);
+#else
+            arglist = Py_BuildValue("(kkk)",
+                cpu, arg_unsg_1, arg_unsg_2, arg_addr_1);
+#endif
+            call_python_callback(
+                pCallbacks[callback_idx], arglist);
+            Py_DECREF(arglist);
+
+            break;
+
+    }
+    
+    va_end(ap);
+}
+
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/instrument/python_hooks/instrument.h bochs_py/instrument/python_hooks/instrument.h
--- bochs/instrument/python_hooks/instrument.h	1970-01-01 01:00:00.000000000 +0100
+++ bochs_py/instrument/python_hooks/instrument.h	2010-02-22 20:14:14.000000000 +0100
@@ -0,0 +1,258 @@
+/////////////////////////////////////////////////////////////////////////
+// $Id: instrument.h,v 1.17.2.2 2005/07/08 07:17:06 vruppert Exp $
+/////////////////////////////////////////////////////////////////////////
+//
+//  Copyright (C) 2001  MandrakeSoft S.A.
+//
+//    MandrakeSoft S.A.
+//    43, rue d'Aboukir
+//    75002 Paris - France
+//    http://www.linux-mandrake.com/
+//    http://www.mandrakesoft.com/
+//
+//  This library is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU Lesser General Public
+//  License as published by the Free Software Foundation; either
+//  version 2 of the License, or (at your option) any later version.
+//
+//  This library is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//  Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public
+//  License along with this library; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+#include <Python.h>
+
+// The ifndef makes sure that the enum is included only once
+// as several files include this one and having it defined multiple
+// times leads to compilation errors
+//
+#ifndef INSTR_CALLBACKS
+enum {
+    INSTR_INIT_ENV,
+    INSTR_EXIT_ENV,
+    
+    INSTR_INITIALIZE,
+    INSTR_EXIT,
+    INSTR_RESET,
+    INSTR_HLT,
+    INSTR_MWAIT,
+    INSTR_NEW_INSTRUCTION,
+
+    /*
+    INSTR_DEBUG_PROMPT,
+    */
+    // INSTR_DEBUG_CMD,
+
+    INSTR_CNEAR_BRANCH_TAKEN,
+    INSTR_CNEAR_BRANCH_NOT_TAKEN,
+    INSTR_UCNEAR_BRANCH,
+    INSTR_FAR_BRANCH,
+
+    INSTR_OPCODE,
+    INSTR_EXCEPTION,
+    INSTR_INTERRUPT,
+    INSTR_HWINTERRUPT,
+
+    INSTR_CLFLUSH,
+    INSTR_CACHE_CNTRL,
+    INSTR_TLB_CNTRL,
+    INSTR_PREFETCH_HINT,
+
+    INSTR_BEFORE_EXECUTION,
+    INSTR_AFTER_EXECUTION,
+    INSTR_REPEAT_ITERATION,
+
+    INSTR_LIN_ACCESS,
+    INSTR_MEM_DATA_ACCESS,
+    INSTR_PHY_READ,
+    INSTR_PHY_WRITE,
+
+    INSTR_INP,
+    INSTR_INP2,
+    INSTR_OUTP,
+    
+    INSTR_WRMSR,
+
+    INSTR_CALLBACK_COUNT
+    } ;
+#define INSTR_CALLBACKS
+#endif
+
+
+// possible types passed to BX_INSTR_TLB_CNTRL()
+#define BX_INSTR_MOV_CR3      10
+#define BX_INSTR_INVLPG       11
+#define BX_INSTR_TASKSWITCH   12
+
+// possible types passed to BX_INSTR_CACHE_CNTRL()
+#define BX_INSTR_INVD         20
+#define BX_INSTR_WBINVD       21
+
+// possible types passed to BX_INSTR_FAR_BRANCH()
+#define BX_INSTR_IS_CALL      10
+#define BX_INSTR_IS_RET       11
+#define BX_INSTR_IS_IRET      12
+#define BX_INSTR_IS_JMP       13
+#define BX_INSTR_IS_INT       14
+#define BX_INSTR_IS_SYSCALL   15
+#define BX_INSTR_IS_SYSRET    16
+#define BX_INSTR_IS_SYSENTER  17
+#define BX_INSTR_IS_SYSEXIT   18
+
+// possible types passed to BX_INSTR_PREFETCH_HINT()
+#define BX_INSTR_PREFETCH_NTA 0
+#define BX_INSTR_PREFETCH_T0  1
+#define BX_INSTR_PREFETCH_T1  2
+#define BX_INSTR_PREFETCH_T2  3
+
+
+
+extern const char *callback_strings[];
+    
+int bochs_handle_error(void);
+void instr_callback(int callback_idx, unsigned cpu, ...);
+PyObject *set_callback(PyObject *self, PyObject *args);
+PyObject *set_filter_cr3(PyObject *self, PyObject *args);
+
+
+
+class bxInstruction_c;
+
+// called from the CPU core
+
+
+void bx_instr_cnear_branch_taken(unsigned cpu, bx_address new_eip);
+void bx_instr_ucnear_branch(unsigned cpu, unsigned what, bx_address new_eip);
+void bx_instr_far_branch(unsigned cpu, unsigned what, Bit16u new_cs, bx_address new_eip);
+void bx_instr_interrupt(unsigned cpu, unsigned vector);
+void bx_instr_exception(unsigned cpu, unsigned vector, unsigned error_code);
+void bx_instr_hwinterrupt(unsigned cpu, unsigned vector, Bit16u cs, bx_address eip);
+void bx_instr_lin_access(unsigned cpu, bx_address lin, bx_address phy, unsigned len, unsigned rw);
+void bx_instr_wrmsr(unsigned cpu, unsigned addr, Bit64u value);
+
+
+
+void bx_instr_tlb_cntrl(unsigned cpu, unsigned what, Bit32u new_cr3);
+void bx_instr_cache_cntrl(unsigned cpu, unsigned what);
+void bx_instr_prefetch_hint(unsigned cpu, unsigned what, unsigned seg, bx_address offset);
+void bx_instr_before_execution(unsigned cpu, const bxInstruction_c *i);
+void bx_instr_after_execution(unsigned cpu, const bxInstruction_c *i);
+void bx_instr_repeat_iteration(unsigned cpu, const bxInstruction_c *i);
+void bx_instr_inp(Bit16u addr, unsigned len);
+void bx_instr_outp(Bit16u addr, unsigned len);
+void bx_instr_inp2(Bit16u addr, unsigned len, unsigned val);
+//void bx_instr_outp2(Bit16u addr, unsigned len, unsigned val);
+void bx_instr_opcode(unsigned cpu, Bit8u *opcode, unsigned len, bx_bool is32);
+void bx_instr_fetch_decode_completed(unsigned cpu, bxInstruction_c *i);
+void bx_instr_prefix(unsigned cpu, Bit8u prefix);
+void bx_instr_debug_promt();
+
+
+/* simulation init, shutdown, reset */
+#define BX_INSTR_INIT_ENV() instr_callback(INSTR_INIT_ENV, 0)
+#define BX_INSTR_EXIT_ENV() instr_callback(INSTR_EXIT_ENV, 0)
+
+#define BX_INSTR_INITIALIZE(cpu_id)             \
+                    instr_callback(INSTR_INITIALIZE, cpu_id)
+
+#define BX_INSTR_EXIT(cpu_id)             \
+                    instr_callback(INSTR_EXIT, cpu_id)
+
+#define BX_INSTR_RESET(cpu_id, type)            \
+                    instr_callback(INSTR_RESET, cpu_id, type)
+#define BX_INSTR_HLT(cpu_id)              \
+                    instr_callback(INSTR_HLT, cpu_id)
+#define BX_INSTR_MWAIT(cpu_id, addr, len, flags)  \
+                    instr_callback(INSTR_MWAIT, cpu_id, addr, len, flags)
+
+#define BX_INSTR_NEW_INSTRUCTION(cpu_id)  \
+                    instr_callback(INSTR_NEW_INSTRUCTION, cpu_id)
+
+/* called from memory object */
+#define BX_INSTR_PHY_WRITE(cpu_id, addr, len)         \
+                    instr_callback(INSTR_PHY_WRITE, cpu_id, addr, len)
+#define BX_INSTR_PHY_READ(cpu_id, addr, len)          \
+                    instr_callback(INSTR_PHY_READ, cpu_id, addr, len)
+
+/* memory access */
+#define BX_INSTR_LIN_ACCESS(cpu_id, lin, phy, len, rw)    \
+                      instr_callback(INSTR_LIN_ACCESS, cpu_id, lin, phy, len, rw)
+
+#define BX_INSTR_MEM_DATA_ACCESS(cpu_id, seg, offset, len, rw) \
+                instr_callback(INSTR_MEM_DATA_ACCESS, cpu_id, seg, offset, len, rw)
+                //bx_instr_mem_data_access(cpu_id, seg, offset, len, rw)
+
+
+
+/* branch resolution */
+#define BX_INSTR_CNEAR_BRANCH_TAKEN(cpu_id, new_eip)  \
+                    instr_callback(INSTR_CNEAR_BRANCH_TAKEN, cpu_id, new_eip)
+#define BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(cpu_id)       \
+                    instr_callback(INSTR_CNEAR_BRANCH_NOT_TAKEN, cpu_id)
+#define BX_INSTR_UCNEAR_BRANCH(cpu_id, what, new_eip) \
+                    instr_callback(INSTR_UCNEAR_BRANCH, cpu_id, what, new_eip)
+#define BX_INSTR_FAR_BRANCH(cpu_id, what, new_cs, new_eip)    \
+                    instr_callback(INSTR_FAR_BRANCH, cpu_id, what, new_cs, new_eip)
+
+
+/* exceptional case and interrupt */
+#define BX_INSTR_EXCEPTION(cpu_id, vector, error_code)    \
+                    instr_callback(INSTR_EXCEPTION, cpu_id, vector, error_code)
+#define BX_INSTR_INTERRUPT(cpu_id, vector)    \
+                    instr_callback(INSTR_INTERRUPT, cpu_id, vector)
+#define BX_INSTR_HWINTERRUPT(cpu_id, vector, cs, eip) \
+                    instr_callback(INSTR_HWINTERRUPT, cpu_id, vector, cs, eip)
+
+/* wrmsr callback */
+#define BX_INSTR_WRMSR(cpu_id, addr, value)   \
+                    instr_callback(INSTR_WRMSR, cpu_id, addr, value)
+
+
+/* feedback from device units */
+#define BX_INSTR_INP(addr, len)           \
+                    instr_callback(INSTR_INP, addr, len)
+#define BX_INSTR_INP2(addr, len, val)     \
+                    instr_callback(INSTR_INP2, addr, len, val)
+#define BX_INSTR_OUTP(addr, len, val)    \
+                    instr_callback(INSTR_OUTP, addr, len, val)
+
+
+/* decoding completed */
+#define BX_INSTR_OPCODE(cpu_id, opcode, len, is32, is64)  \
+                    instr_callback(INSTR_OPCODE, cpu_id, opcode, len, is32, is64)
+//#define BX_INSTR_FETCH_DECODE_COMPLETED(cpu_id, i)        \
+//                    instr_callback(INSTR_FETCH_DECODE_COMPLETED, cpu_id, i)
+
+     
+/* prefix byte decoded */
+//#define BX_INSTR_PREFIX(cpu_id, prefix)       \
+//                    instr_callback(INSTR_PREFIX, cpu_id, prefix)
+
+/* execution */
+#define BX_INSTR_BEFORE_EXECUTION(cpu_id, i)  \
+                    instr_callback(INSTR_BEFORE_EXECUTION, cpu_id, i)
+#define BX_INSTR_AFTER_EXECUTION(cpu_id, i)   \
+                    instr_callback(INSTR_AFTER_EXECUTION, cpu_id, i)
+#define BX_INSTR_REPEAT_ITERATION(cpu_id, i)  \
+                    instr_callback(INSTR_REPEAT_ITERATION, cpu_id, i)
+
+
+/* TLB/CACHE control instruction executed */
+#define BX_INSTR_CLFLUSH(cpu_id, laddr, paddr)    \
+                    instr_callback(INSTR_CLFLUSH, cpu_id, laddr, paddr)
+
+#define BX_INSTR_CACHE_CNTRL(cpu_id, what)                \
+                    instr_callback(INSTR_CACHE_CNTRL, cpu_id, what)
+#define BX_INSTR_TLB_CNTRL(cpu_id, what, new_cr3)          \
+                    instr_callback(INSTR_TLB_CNTRL, cpu_id, what, new_cr3)
+#define BX_INSTR_PREFETCH_HINT(cpu_id, what, seg, offset) \
+                    instr_callback(INSTR_PREFETCH_HINT, cpu_id, what)
+
+
+/* called from command line debugger */
+#define BX_INSTR_DEBUG_PROMPT()
+#define BX_INSTR_DEBUG_CMD(cmd)
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/instrument/python_hooks/interpreter.cc bochs_py/instrument/python_hooks/interpreter.cc
--- bochs/instrument/python_hooks/interpreter.cc	1970-01-01 01:00:00.000000000 +0100
+++ bochs_py/instrument/python_hooks/interpreter.cc	2009-08-07 04:08:13.000000000 +0200
@@ -0,0 +1,854 @@
+#include "bochs.h"
+
+#ifdef HAVE_LIBREADLINE
+#include <readline/readline.h>
+#include <readline/history.h>
+#endif
+
+#define XXXX
+#include "interpreter.h"
+#undef XXXX
+
+
+// Python code run at initialization time to
+// set instances of a class to capture the
+// stdin and stdout generated by the Python
+// code.
+
+char *interpreter_initialization_code = \
+"import sys\n"
+"class Capture:\n"
+"	def __init__(self):\n"
+"		self.data = ''\n"
+"	def write(self, str):\n"
+"		self.data += str\n"
+"stdout = sys.stdout\n"
+"stderr = sys.stderr\n"
+"capture_stdout = Capture()\n"
+"capture_stderr = Capture()\n"
+"sys.stdout = capture_stdout\n"
+"sys.stderr = capture_stderr\n"
+"sys.stdout.orig_obj = stdout\n"
+"sys.stderr.orig_obj = stderr\n";
+
+InterpreterState *interpreter_state;
+
+#ifdef HAVE_LIBREADLINE
+
+char **builtins = NULL;
+char **keywords = NULL;
+
+
+// Chec whether the attribute name is one of SWIG's
+// class attributes. Those don't need to be completed.
+
+int swig_class_attribute_name(char *attr)
+{
+    if(
+        !strncmp(attr, "this", 4) ||
+        !strncmp(attr, "thisown", 7) ||
+        !strncmp(attr, "<class ", 7) )
+        
+        return 1;
+    
+    return 0;
+}
+
+
+// Return a python list/tuple of strings as an array of
+// strings.
+
+char **string_obj_list_to_str_array(PyObject *list)
+{
+    int i, j;
+    char **array, *str;
+    PyObject *item, *pystr;
+    
+    if(!list)
+        return NULL;
+        
+	array = (char **)malloc(
+	   sizeof(char *)*(PySequence_Length(list)+1));
+	
+	for(i=0, j=0;; i++) {
+    	item = PySequence_GetItem(list, i);
+    	if(!item) {
+    	   // The error needs to be cleared in order to
+    	   // keep the interpreter in a good state.
+    	   PyErr_Clear();
+    	   break;
+        }
+        // Only get string objects, SWIG adds other
+        // kinds of objects than 'str' that end up showing
+        // in a dir()
+        pystr = PyObject_Str(item);
+        str = PyString_AsString(pystr);
+        if(!swig_class_attribute_name(str) && str) {
+            array[j] = (char *)strdup(str);
+            j++;
+        }
+        Py_DECREF(pystr);
+        Py_DECREF(item);
+    }
+    
+    // If no acceptable strings were found for completion
+    // an NULL is returned and the memory is freed.
+    if(array && j==0) {
+        free(array);
+        return NULL;
+    }
+    
+    array[j] = NULL;
+	
+	return array;
+}
+
+
+
+// Get an object's dir() and return the items
+// as an array of strings.
+
+char **get_object_dir(PyObject *obj)
+{
+    PyObject *obj_dir;
+    char **dir_str;
+
+	obj_dir = PyObject_Dir(obj);
+	if(!obj_dir)
+	   return NULL;
+	
+    dir_str = string_obj_list_to_str_array(obj_dir);
+
+	Py_DECREF(obj_dir);
+	
+	return dir_str;
+}
+
+
+
+// Get an object's __dict__ keys and return them
+// as an array of strings.
+
+char **get_object_dict_keys(PyObject *obj)
+{
+    PyObject *dict, *keys;
+    char **key_list;
+
+	dict = PyObject_GetAttrString(obj, "__dict__");
+	if(!dict) {
+	   PyErr_Clear();
+	   return NULL;
+    }
+	   
+	keys = PyDict_Keys(dict);
+	if(!keys) {
+	   Py_DECREF(dict);
+	   return NULL;
+    }
+	
+    key_list = string_obj_list_to_str_array(keys);
+
+	Py_DECREF(keys);
+	Py_DECREF(dict);
+	
+	return key_list;
+}
+
+
+
+// Harvest the Python keyword for readline's completions.
+
+void load_keywords(void)
+{
+    PyObject *keyword, *kwlist, *kw;
+    char *kw_str;
+    int i;
+
+    execute_input("import keyword");
+    
+    keyword = PyMapping_GetItemString(interpreter_state->main_dict, "keyword");
+	kwlist = PyObject_GetAttrString(keyword, "kwlist");
+	
+	keywords = (char **)malloc(sizeof(char *) * (PySequence_Length(kwlist)+1));
+	
+	for(i=0;; i++) {
+    	kw = PySequence_GetItem(kwlist, i);
+    	if(!kw)
+    	   break;
+        kw_str = PyString_AsString(kw);
+        
+        keywords[i] = (char *)strdup(kw_str);
+    }
+    keywords[i] = NULL;
+	
+	Py_DECREF(keyword);
+	Py_DECREF(kwlist);
+}
+
+
+
+// Harvest the builtins for readline's completions.
+
+void load_builtins(void)
+{
+
+    interpreter_state->__builtins__ = PyMapping_GetItemString(
+        interpreter_state->main_dict, "__builtins__");
+    builtins = get_object_dict_keys(
+        interpreter_state->__builtins__);
+}
+
+
+
+// Free an array of strings and all the strings
+// within it.
+
+void free_array_of_strings(char **str_list)
+{
+    int i;
+    
+    if(!str_list)
+        return;
+        
+    for(i=0;;i++) {
+        if(str_list[i])
+            free(str_list[i]);
+        else {
+            free(str_list);
+            break;
+        }
+    }
+}
+
+
+
+// Retrieve a matching string from an array of candidates.
+// The beginning of each string in the candidates list will
+// be matched against the provided "text", skipping a "skip"
+// number of matches.
+
+char *fetch_match(char **str_list, const char *text, int *skip)
+{
+    int idx;
+    char *str, *match;
+    
+    if(!str_list)
+        return NULL;
+    
+    for(idx=0;; idx++) {
+        str = str_list[idx];
+        if(!str)
+            break;
+        if(strncmp(text, str, strlen(text))==0) {
+            if(!(*skip)) {
+                match = (char *)strdup(str);
+                if(!match) {
+                    // FIXME no mem!
+                }
+                return match;
+            }
+            (*skip)--;
+        }
+    }
+    return NULL;
+}
+
+
+
+// Splits the module path into individual
+// components, the first component is returned
+// after skipping the first "skip" of them.
+
+char *split_module_path(const char *path, int skip)
+{
+    int idx, last_idx;
+    char *match;
+    
+    if(!path)
+        return NULL;
+    
+    // "last_idx" will always point to the beginning
+    // of the last component. Components are retrieved
+    // in the range [last_idx, idx].
+    
+    for(last_idx = 0, idx = 0;; idx++) {
+    
+        // If enf of path
+        if(!path[idx]) {
+        
+            // If no more to skip and we still
+            // have a component left,return it.
+            if(!skip && last_idx!=idx) {
+                match = strdup(&path[last_idx]);
+                return match;
+            }
+            return NULL;
+        }
+        
+        // If component separator is found
+        if(path[idx]=='.') {
+        
+            // If no more to skip and we still
+            // have a component left,return it.
+            if(!skip && last_idx!=idx) {
+                match = strdup(&path[last_idx]);
+                match[idx-last_idx] = 0;
+                return match;
+            }
+            last_idx = idx+1;
+            skip --;
+        }
+    }
+    return NULL;
+}
+
+
+// Set the completion character according to what the
+// object being completed. If the object is callable
+// a parenthesis will be opened. If the object has
+// a __dict__ attribute, i.e. it's a module, a dot will
+// be added, otherwise a space will be added.
+
+char *set_completion_append_character(PyObject *parent, char *match)
+{
+    PyObject *obj;
+
+
+    if(match==NULL || (*match)==0)
+        return match;
+    
+    // Set the default completion character.    
+    rl_completion_append_character = ' ';
+
+    obj = PyObject_GetAttrString(parent, match);
+    if(obj) {
+        if(PyCallable_Check(obj))    
+            rl_completion_append_character = '(';
+        else if(PyObject_HasAttrString(obj, "__dict__"))
+            rl_completion_append_character = '.';
+    
+        Py_DECREF(obj);
+    } else {
+        // Errors here are normal, attributes are being looked for
+        // which don't exist. We just silently ignore those.
+        // No harm done.
+        PyErr_Clear();
+    }
+        
+    return match;
+}
+
+
+
+// Harvest possible completios of different kinds and return
+// the candidates to readline.
+
+char *rl_python_completion_function(const char *text, int skip)
+{
+    int idx, length;
+    char **completion_list, *match;
+    PyObject *attr, *new_attr, *last_attr;
+    char *text_cpy, *attr_name, **path_items = NULL, *item;
+    char **completions[] = {builtins, keywords, NULL};
+    char **obj_completions = NULL;
+    int path_depth;
+
+
+    // Iterate the builtins and keywords and return matching
+    // strings.
+    
+    for(idx=0;; idx++) {
+        completion_list = completions[idx];
+        if(!completion_list)
+            break;
+        match = fetch_match(completion_list, text, &skip);
+        if(match)
+            return set_completion_append_character(
+                interpreter_state->__builtins__, match);
+    }
+    
+    // If nothing found so far or all skipped, gather the object's
+    // __dict__ keys and search for candidates there.
+    
+    obj_completions = get_object_dict_keys(interpreter_state->main_module);
+    match = fetch_match(obj_completions, text, &skip);
+    free_array_of_strings(obj_completions);
+    if(match)
+        return set_completion_append_character(
+            interpreter_state->main_module, match);
+            
+            
+    // If nothing found so far or all skipped...
+    
+    
+    // Count number of components in module path. (Number of '.' + 1)
+    for(idx=0, path_depth = 1; text[idx]; idx++)
+        if(text[idx]=='.')
+            path_depth++;
+    
+            
+    // If at least one '.' i.e. string is a module path...
+    if(path_depth>1) {
+
+        // Create an array of strings to hold the individual items.
+        
+        path_items = (char **)malloc((path_depth+1)*sizeof(char *));
+        attr_name = text_cpy = strdup(text);
+    
+        // Get all the components of the module path.
+        for(idx=0;; idx++) {
+            item = strsep(&attr_name, ".");
+            if(!item) {
+                path_items[idx] = NULL;
+                break;
+            }
+            path_items[idx] = strdup(item);
+        }
+        free(text_cpy);
+
+        // Walk the module path, getting the attributes as we go.
+	for(idx=0; idx+1<path_depth; idx++) {
+            if(!path_items[idx])
+                break;
+
+	    // If looking for the first element...
+	    if(idx==0) {
+
+            // Search in the globals
+            new_attr = PyObject_GetAttrString(
+                interpreter_state->main_module, path_items[idx]);
+
+            // If not found there search in the __builtins__
+            if(!new_attr) {
+                PyErr_Clear();
+                new_attr = PyObject_GetAttrString(
+                    interpreter_state->__builtins__, path_items[idx]);
+            }
+
+	    } else {
+		    // Otherwise just search in the last object
+		    // retrieved.
+	            new_attr = PyObject_GetAttrString(attr, path_items[idx]);
+	    }
+            if(!new_attr) {
+                PyErr_Clear();
+                break;
+            }
+            if(idx>0)
+                Py_DECREF(attr);
+            attr = new_attr;
+        }
+        
+        // If at least one level deep fetch the possible completions
+        
+        if(idx>0 && idx==path_depth-1 && attr) {
+            
+            // Get the keys for the object's __dict__ attribute
+            obj_completions = get_object_dict_keys(attr);
+            
+            // If none, get the objects dir() items
+            if(!obj_completions)
+                obj_completions = get_object_dir(attr);
+                
+            // and search within...
+            
+            match = fetch_match(obj_completions,
+                            path_items[path_depth-1], &skip);
+                            
+            if(match) {
+                set_completion_append_character(
+                    attr, match);
+
+                // Calculate the maximum length of the path
+                // plus the matched attribute.                    
+                length = strlen(text)+strlen(match);
+                
+                // Allocate memory and compose full path to
+                // attribute.
+                text_cpy = (char *)malloc(length+1);
+                memset(text_cpy, 0, length+1);
+                strncpy(text_cpy, text,
+                    strlen(text)-strlen(path_items[path_depth-1]));
+                strcat(text_cpy, match);
+                
+                
+                free(match);
+                free_array_of_strings(obj_completions);
+                free_array_of_strings(path_items);
+                Py_DECREF(attr);
+                return text_cpy;
+            }
+            free_array_of_strings(obj_completions);
+        }
+        
+        free_array_of_strings(path_items);
+    }
+
+
+    return NULL;
+}
+#endif
+
+
+// Read and output any data which Python code
+// might have written to stdout or stderr.
+
+void process_std(PyObject *source)
+{
+    PyObject *std_data;
+    char *std_str;
+
+    DEBUG("process_std: getting data")
+	std_data = PyObject_GetAttrString(source, "data");
+    DEBUG("process_std: getting string from data")
+	std_str = PyString_AsString(std_data);
+	
+	if(strlen(std_str)>0) {
+        DEBUG("process_std: showing string")
+        printf("%s", std_str);
+        Py_DECREF(std_data);
+        
+        PyObject_SetAttrString(source, "data", PyString_FromString(""));
+    }
+}
+
+
+// Handle errors in the input. If the error is a syntax
+// error it might be due to incomplete input. That's
+// checked for and if so, more input is requested.
+
+int handle_error(void)
+{
+	PyObject *err;
+	PyObject *exc_type, *exc_value, *exc_traceback;
+	char *exc_text, *exc_input_file, *exc_input;
+	int exc_err_line, exc_err_column, exc_input_length;
+	int return_value = ERROR_NONE;
+
+    // Write all the output generated before the error.
+    // The error might have occurred, for instance, in
+    // a loop after running several times and printing
+    // some results after each repetition.
+    process_std(interpreter_state->capture_stdout);
+    process_std(interpreter_state->capture_stderr);
+
+    // Has an error occured?
+    err = PyErr_Occurred();
+    if(err) {
+    
+        // If so, is the exception a SyntaxError one?
+        if(PyErr_GivenExceptionMatches(PyExc_SyntaxError, err)) {
+        
+            DEBUG("handle_error: syntax error")
+            
+            // Get the details of the SyntaxError
+            PyErr_Fetch(&exc_type, &exc_value, &exc_traceback);
+            
+            if(exc_type) {
+                if(exc_value) {
+                
+                    //printf("[%s]\n",
+                    //    PyString_AsString(PyObject_Repr(exc_value)));
+                    
+                    // Parse the SyntaxError exception information.
+                    
+                    PyArg_ParseTuple(exc_value, "s(siis#)",
+                        &exc_text, &exc_input_file, &exc_err_line,
+                        &exc_err_column, &exc_input, &exc_input_length);
+                        
+                    //printf("%d %d %d\n",
+                    //    exc_err_line, exc_err_column, exc_input_length);
+                    
+                    // Free the unneeded references.
+                    Py_XDECREF(exc_type);
+                    Py_XDECREF(exc_value);
+                    Py_XDECREF(exc_traceback);
+                    
+                    // If the SyntaxError is indicated in the
+                    // last character/column of input, it means
+                    // the Python compiler expected more code to
+                    // follow, we indicate so; so more input can
+                    // be requested.
+                    
+                    if(exc_input_length==exc_err_column)
+                        return_value = ERROR_INCOMPLETE_INPUT;
+                    else
+                        return_value = ERROR_SYNTAX_ERROR;
+                }
+            }
+        } else {
+            // Other exeception than a SyntaxError occurred.
+            // The information is written to stdout.
+            PyErr_Print();
+            process_std(interpreter_state->capture_stderr);
+            return_value = ERROR_OTHER;
+        }
+    }
+    
+    return return_value;
+}
+
+
+
+// Evaluate a compiled "code object"
+
+int eval_code(PyObject *code_obj, int parse_mode)
+{
+	PyObject *code_executed, *repr;
+
+    DEBUG("eval_code: running PyEval_EvalCode")
+    
+    // Evaluate the code.
+    code_executed = (PyObject *)PyEval_EvalCode(
+        (PyCodeObject *)code_obj,
+        interpreter_state->main_dict,
+        interpreter_state->main_dict);
+        
+    if(!code_executed) {
+        DEBUG("eval_code: PyEval_EvalCode failed")
+        return handle_error();
+    }
+    DEBUG("eval_code: code executed")
+    
+    DEBUG("eval_code: showing output")
+    
+    
+    if(parse_mode==Py_eval_input) {
+    
+        // If the mode is Py_eval_input and the code evaluated
+        // successfully, an expression has been executed and the
+        // resulting value is the returned Python object.
+        // The interpreter will output a string representation of
+        // the object.
+        DEBUG("eval_code: showing repr")
+        
+        process_std(interpreter_state->capture_stdout);
+        if(code_executed != Py_None) {
+            repr = PyObject_Repr(code_executed);
+            printf("[%s]\n", PyString_AsString(repr));
+            Py_DECREF(repr);
+        }
+        
+    } else {
+    
+        // Otherwise, the code evaluated was one or more statements
+        // which do not return a value, if any output has been
+        // produced, it will be available in the Capture instance
+        // The output is shown by the interpreter.
+        DEBUG("eval_code: showing stdout")
+        process_std(interpreter_state->capture_stdout);
+    }
+    
+    // Free unneeded object.
+    Py_DECREF(code_executed);
+    
+    return ERROR_NONE;
+}
+
+
+// Attempt to execute the input typed by the user.
+
+int execute_input(char *input)
+{
+    PyObject *code_obj;
+    int status;
+    
+    // Compile the user input as an expression.  
+    code_obj = Py_CompileString(input, "User Input", Py_eval_input);
+    
+    if(code_obj) {
+    
+        // If the compilation was successful, the resulting code
+        // object is evaluated.
+        DEBUG("execute_input: evaluating eval_input")
+        
+        status = eval_code(code_obj, Py_eval_input);
+        Py_DECREF(code_obj);
+        
+        return status;
+        
+    } else {
+    
+        DEBUG("execute_input: evaluating file_input")
+        
+        // If the compilation did not succeed probably the
+        // code was not an expression. Subsequently it will now
+        // be compiled as a statement or group of statements.
+        // The error is therefore cleared. If it triggers again
+        // after this compilation then there will be a syntax
+        // or other kind or error in the user's input.
+        PyErr_Clear();
+        
+        code_obj = Py_CompileString(input, "User Input", Py_file_input);
+        if(code_obj) {
+            status = eval_code(code_obj, Py_file_input);
+            Py_DECREF(code_obj);
+        
+            return status;
+        }
+	}
+	
+	return handle_error();
+}
+
+
+// Main interpreter loop. It will loop fetching
+// user input until EOF is entered.
+
+void main_loop(void)
+{
+    char input_buffer[MAX_INPUT_LENGTH];
+    char *input_line;
+    char *prompt;
+    int line_length, status, multi_line = 0;
+    
+        
+    // FIXME: use dynamically allocated input buffers!
+    
+    // Reset the input buffer and set the default prompt
+    memset(input_buffer, 0, MAX_INPUT_LENGTH);
+    prompt = PROMPT1;
+    
+    while(1) {
+
+#ifdef HAVE_LIBREADLINE
+        input_line = readline(prompt);
+/*        {
+            int i;
+            for(i=0; input_line[i]; i++)
+                printf("[%x,%c]\n", input_line[i], input_line[i]);        
+        }*/
+        line_length = 0;
+        if(input_line) {
+            if(*input_line) {
+                line_length = strlen(input_line);
+                add_history(input_line);
+            }
+            input_line = (char *)realloc(input_line, line_length+2);
+            if(!input_line) {
+                // FIXME
+            }
+            input_line[line_length] = '\n';
+            input_line[line_length+1] = '0';
+            line_length += 1;
+        }
+#else
+        // Show prompt and read user's input
+        write(2, prompt, strlen(prompt));
+
+        input_line = (char *)malloc(MAX_LINE_LENGTH);
+        line_length = read(1, input_line, MAX_LINE_LENGTH-1);
+        input_line[line_length] = 0;
+#endif
+
+        // If Ctrl-D aka EOF is entered, the loop is ended
+        // and the interpreter exits.
+        if(line_length==0 && 
+            (input_line==NULL || input_line[0]==0) ) {
+            
+            // If not in multiline mode exit, otherwise
+            // ends multiline mode and empty buffer.
+            if(multi_line==0)
+                return ;
+            else {
+                memset(input_buffer, 0, MAX_INPUT_LENGTH);
+                multi_line=0;
+            }
+            
+        }
+            
+        if(line_length==1){
+            if(input_line[0]=='\n')
+                multi_line = 0;
+        }
+        
+        // Multiline mode might have been reseted, which means
+        // input_line might be NULL, so no we check for that.
+        if(input_line) {
+            strncat(input_buffer, input_line, line_length);
+            free(input_line);
+        }
+//        printf("%d [%s]\n", line_length, input_line);        
+//        write(2, input_buffer, line_length);
+
+        if(multi_line==0) {
+            if(strlen(input_buffer)>1 || *input_buffer!='\n')
+                status = execute_input(input_buffer);
+        }
+        
+        if(multi_line || status==ERROR_INCOMPLETE_INPUT) {
+            prompt = PROMPT2;
+            multi_line = 1;
+        } else {
+            memset(input_buffer, 0, MAX_INPUT_LENGTH);
+            prompt = PROMPT1;
+        }
+    }
+}
+
+
+
+
+void init_interpreter(void)
+{
+	PyObject *code_executed;
+
+#ifdef HAVE_LIBREADLINE
+    rl_initialize();
+    
+/*
+    On the macintosh (freeBSD?), rl_completion_entry_function is
+    declared as returning "int" while in other systems "char *"
+*/
+#ifdef macintosh
+    rl_completion_entry_function = (int(*)(const char*, int))rl_python_completion_function;
+#else
+    rl_completion_entry_function = rl_python_completion_function;
+#endif
+#endif
+
+    Py_Initialize();
+    
+    interpreter_state = (InterpreterState *)malloc(sizeof(InterpreterState));
+    
+    // Get the main dictionary
+    interpreter_state->main_module  = PyImport_AddModule("__main__");
+    interpreter_state->main_dict    = PyModule_GetDict(
+                                        interpreter_state->main_module);
+    
+    code_executed = PyRun_String(
+        interpreter_initialization_code, Py_file_input,
+        interpreter_state->main_dict, NULL);
+    interpreter_state->capture_stdout = PyMapping_GetItemString(
+        interpreter_state->main_dict, "capture_stdout");
+    interpreter_state->capture_stderr = PyMapping_GetItemString(
+        interpreter_state->main_dict, "capture_stderr");
+                
+    Py_DECREF(code_executed);
+    
+#ifdef HAVE_LIBREADLINE
+    load_keywords();
+    load_builtins();
+#endif
+    
+    return;
+}
+
+
+void shutdown_interpreter(void)
+{
+    int i;
+
+    Py_DECREF(interpreter_state->capture_stdout);
+    Py_DECREF(interpreter_state->capture_stderr);
+    
+#ifdef HAVE_LIBREADLINE
+	Py_DECREF(interpreter_state->__builtins__);
+    
+    free_array_of_strings(builtins);
+    free_array_of_strings(keywords);
+#endif
+
+    Py_Finalize();
+}
+
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/instrument/python_hooks/interpreter.h bochs_py/instrument/python_hooks/interpreter.h
--- bochs/instrument/python_hooks/interpreter.h	1970-01-01 01:00:00.000000000 +0100
+++ bochs_py/instrument/python_hooks/interpreter.h	2009-08-07 04:08:13.000000000 +0200
@@ -0,0 +1,44 @@
+#include <Python.h>
+#include <pyport.h>
+#include <compile.h>
+#include <object.h>
+#include <eval.h>
+
+
+#define MAX_INPUT_LENGTH        8192
+#define MAX_LINE_LENGTH         1024
+
+#define ERROR_INCOMPLETE_INPUT  1
+#define ERROR_SYNTAX_ERROR      2
+#define ERROR_OTHER             3
+#define ERROR_NONE              0
+
+#define PROMPT1     ">>> "
+#define PROMPT2     "... "
+
+
+//#define DEBUG(x)    {printf("DEBUG: "); printf(x); printf("\n");}
+#define DEBUG(x)    {}
+
+
+
+// Structure holding the objects dealing
+// with a interactive interpreter instance.
+
+typedef struct InterpreterStateType {
+    PyObject *main_module;
+    PyObject *main_dict;
+    PyObject *capture_stdout;
+    PyObject *capture_stderr;
+    PyObject *__builtins__;
+} InterpreterState;
+
+#ifndef XXXX
+extern InterpreterState *interpreter_state;
+#endif
+
+void main_loop(void);
+void init_interpreter(void);
+void shutdown_interpreter(void);
+int handle_error(void);
+int execute_input(char *input);
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/iodev/Makefile.in bochs_py/iodev/Makefile.in
--- bochs/iodev/Makefile.in	2010-02-22 19:36:37.000000000 +0100
+++ bochs_py/iodev/Makefile.in	2010-02-22 19:35:42.000000000 +0100
@@ -38,9 +38,6 @@
 
 @SET_MAKE@
 
-CXX = @CXX@
-CXXFLAGS = $(BX_INCDIRS) @CXXFLAGS@ @GUI_CXXFLAGS@
-
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
 RANLIB = @RANLIB@
@@ -55,9 +52,12 @@
 USBDEV_OBJS = @USBDEV_OBJS@
 SCSI_OBJS = @SCSI_OBJS@
 
-BX_INCDIRS = -I.. -I$(srcdir)/.. -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@
+BX_INCDIRS = -I.. -I$(srcdir)/.. -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@ -I@PYTHON_INCLUDES@
 LOCAL_CXXFLAGS = $(MCH_CFLAGS)
 
+CXX = @CXX@
+CXXFLAGS = $(BX_INCDIRS) @CXXFLAGS@ @GUI_CXXFLAGS@
+
 PCIDEV_CXXFLAGS = -I$(srcdir)/../host/linux/pcidev
 
 OBJS_THAT_CANNOT_BE_PLUGINS = \
diff -x bxversion.rc -x autom4te.cache -x CVS -x '*.#*' -x configure -urN bochs/memory/Makefile.in bochs_py/memory/Makefile.in
--- bochs/memory/Makefile.in	2010-02-22 19:36:38.000000000 +0100
+++ bochs_py/memory/Makefile.in	2010-02-22 19:35:42.000000000 +0100
@@ -36,7 +36,7 @@
 RANLIB = @RANLIB@
 
 
-BX_INCDIRS = -I.. -I$(srcdir)/.. -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@
+BX_INCDIRS = -I.. -I$(srcdir)/.. -I../@INSTRUMENT_DIR@ -I$(srcdir)/../@INSTRUMENT_DIR@ -I@PYTHON_INCLUDES@
 
 BX_OBJS = \
 	memory.o misc_mem.o
